<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!--
   Licensed to the Apache Software Foundation (ASF) under one
   or more contributor license agreements.  See the NOTICE file
   distributed with this work for additional information
   regarding copyright ownership.  The ASF licenses this file
   to you under the Apache License, Version 2.0 (the
   "License"); you may not use this file except in compliance
   with the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing,
   software distributed under the License is distributed on an
   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied.  See the License for the
   specific language governing permissions and limitations
   under the License.    
-->
<html>
<head>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
	<script type="text/javascript">var xookiConfig = {level: 0};</script>	
	

	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<title>Documentation | Apache Ivy&#153; 2.3.0</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="style/print-style.css" />

<script language="javascript" type="text/javascript">xooki = {u: function(url) {return "xooki/"+url;}};</script>
</head>
<body>

<div id="body">

<table id="header" summary="Navigation elements." border="0"
	cellpadding="0" cellspacing="0" width="100%">
	<tr>
        <td id="home" width="30%"><a href="http://ant.apache.org/"
            title="Apache Ant"><img src="images/ant-group-logo.gif" alt="Apache Ant"
            border="0" /></a></td>

		<td class="product" width="70%" align="right" valign="middle"><img
			src="images/logo.png" alt="ivy" border="0" /></td>
	</tr>
</table>

		<div id="main">
            <div id="xooki-messages" onclick="xooki.html.hide('xooki-messages')" style="zIndex:999;display:none;position:absolute;top:30px;padding:10px;border-style:solid;background:#eeeeee;"></div><div class='toc-title toc-title-1'>Documentation</div><br class="xooki-br"/>Welcome to the official Ivy documentation.<br class="xooki-br"/><br class="xooki-br"/><h1>What is Ivy?</h1>
Ivy is a tool for managing (recording, tracking, resolving and reporting) project dependencies. It is characterized by the following:<br class="xooki-br"/><ol>
<li>flexibility and configurability - Ivy is essentially process agnostic and is not tied to any methodology or structure. Instead it provides the necessary flexibility and configurability to be adapted to a broad range of dependency management and build processes.</li>

<li>tight integration with Apache Ant - while available as a standalone tool, Ivy works particularly well with Apache Ant providing a number of powerful Ant tasks ranging from dependency resolution to dependency reporting and publication.</li>
</ol>
Ivy is open source and released under a very permissive Apache License.<br class="xooki-br"/><br class="xooki-br"/>Ivy has a lot of powerful features, the most popular and useful being its flexibility, integration with ant, and its strong transitive dependencies management engine.<br class="xooki-br"/><br class="xooki-br"/>The transitive dependencies management is a feature which lets you get dependencies of your dependencies, transitively. In order to address this general problem, ivy needs to find metadata about your modules, usually in an <a href="ivyfile.html">ivy file</a>. To find the metadata and your dependencies' artifacts (usually jars), Ivy can be configured to use a lot of different <a href="configuration/resolvers.html">repositories</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>About this doc</h1>
<div class="postit" style="width: 250px;">
Tip: The menu on the left is dynamic, you  can click on the arrows to browse the menu without going to each page.
</div>
This documentation has been migrated from the old Ivy web site hosted by Jayasoft, feel free to report any problem on the mailing-lists.<br class="xooki-br"/><br class="xooki-br"/>If you browse this documentation from your installation of Ivy, you can also check the <a href="http://ant.apache.org/ivy/">online version</a> for the latest updates.<br class="xooki-br"/><br class="xooki-br"/>You can also browse this documentation offline either by downloading the documentation distribution, or by checking out the doc directory from svn. This documentation uses <a href="http://xooki.sourceforge.net/">xooki</a> as its documentation engine, so you can very easily edit it and submit patches when you browse it from source.<br class="xooki-br"/><br class="xooki-br"/>A <a href="book.html">printer-friendly version</a> of this whole documentation is also provided for your convenience.<br class="xooki-br"/><br class="xooki-br"/>Since Ivy 2.0.0-alpha-2, we keep an online history of the documentation. You can thus browse history versions online (in the history menu in the web site) and even check the trunk version documentation currently in development.<br class="xooki-br"/><br class="xooki-br"/>For earlier versions, we suggest downloading the documentation to browse the documentation corresponding to the version you use. The full history of Ivy versions with corresponding links for download is available in the history menu on the web site.<br class="xooki-br"/><br class="xooki-br"/><h1>Other places to go</h1>
Check out Ivy features. <br class="xooki-br"/>Read our FAQ.<br class="xooki-br"/>Ask for help on our mailing lists.<br class="xooki-br"/>Report a bug or feature request in our issue tracking system.<br class="xooki-br"/>Check external tools and resources.<br class="xooki-br"/><br class="xooki-br"/><h1>Overview</h1>
This documentation is composed of three main parts:
<ul>
  <li><a href="tutorial.html">Tutorials</a></li> 
The tutorials is the best way to begin to play with Ivy. You will easily and quickly learn the basics of Ivy.<br class="xooki-br"/>  <li><a href="reference.html">Reference</a></li> 
The reference documentation gives you all the details of Ivy. <br class="xooki-br"/>The introduction part is particularly useful: it defines some vocabulary, explains main concepts such as dependency resolvers and patterns, and gives an overview of how ivy works internally. <br class="xooki-br"/>It's also in the reference doc that you will find all you always dreamed to know about ivy settings, ivy files, and ivy use (especially with ant).<br class="xooki-br"/>  <li><a href="dev.html">Developer doc</a></li> 
The developers's doc is useful for users who would like to extend Ivy or build it from source. It's also the documentation used by the Ivy team, so you will also find information about how we make releases.
</ul>
<hr/><div class='toc-title toc-title-2'>Release Notes</div><br class="xooki-br"/><h2>Announcement</h2>

<pre>
Jan 20, 2013 - The Apache Ivy project is pleased to announce its 2.3.0 release.<br class="xooki-br"/><br class="xooki-br"/>Apache Ivy is a tool for managing (recording, tracking, resolving and<br class="xooki-br"/>reporting) project dependencies, characterized by flexibility,<br class="xooki-br"/>configurability, and tight integration with Apache Ant.<br class="xooki-br"/><br class="xooki-br"/>Key features of this 2.3.0 release are<br class="xooki-br"/>* improved Ant support with some new Ant tasks and enhancements to existing tasks<br class="xooki-br"/>* improved Maven2 compatibility<br class="xooki-br"/>* some new resolvers<br class="xooki-br"/>* numerous bug fixes as documented in Jira and in the release notes<br class="xooki-br"/><br class="xooki-br"/>In addition, experimental OSGI support has been added to the Ivy core.<br class="xooki-br"/><br class="xooki-br"/>You can download this 2.3.0 release at:<br class="xooki-br"/><a href="http://ant.apache.org/ivy/download.cgi">http://ant.apache.org/ivy/download.cgi</a><br class="xooki-br"/><br class="xooki-br"/>Issues should be reported to:<br class="xooki-br"/><a href="https://issues.apache.org/jira/browse/IVY">https://issues.apache.org/jira/browse/IVY</a><br class="xooki-br"/><br class="xooki-br"/>More information can be found on the website:<br class="xooki-br"/><a href="http://ant.apache.org/ivy/">http://ant.apache.org/ivy/</a><br class="xooki-br"/><br class="xooki-br"/>Regards,<br class="xooki-br"/>Maarten Coene
</pre>

<h2>Release Notes</h2>

CONTENTS<br class="xooki-br"/>1. What is Apache Ivy?<br class="xooki-br"/>2. How to Get Involved<br class="xooki-br"/>3. How to Report Issues<br class="xooki-br"/>4. Committers and Contributors for this release<br class="xooki-br"/>5. List of Changes in this Release   <br class="xooki-br"/>   <br class="xooki-br"/>   <br class="xooki-br"/><h3>1. What is Apache Ivy?</h3>

Apache Ivy is a tool for managing (recording, tracking, resolving and reporting) <br class="xooki-br"/>project dependencies. <br class="xooki-br"/>It is characterized by the following:<br class="xooki-br"/><br class="xooki-br"/>   1. flexibility and configurability <br class="xooki-br"/>        Apache Ivy is essentially process agnostic and is not tied to any <br class="xooki-br"/>        methodology or structure. <br class="xooki-br"/>        Instead it provides the necessary flexibility and configurability <br class="xooki-br"/>        to be adapted to a broad range of dependency management and build <br class="xooki-br"/>        processes.<br class="xooki-br"/>   2. tight integration with Apache Ant<br class="xooki-br"/>        while available as a standalone tool, Apache Ivy works particularly well <br class="xooki-br"/>        with Apache Ant providing a number of powerful Ant tasks ranging <br class="xooki-br"/>        from dependency resolution to dependency reporting and publication.<br class="xooki-br"/><br class="xooki-br"/><h3>2. How to Get Involved</h3> 

The Apache Ivy project really needs and appreciates any contributions, <br class="xooki-br"/>including documentation help, source code and feedback.  If you are interested<br class="xooki-br"/>in contributing, please visit <a href="http://ant.apache.org/ivy/get-involved.html">http://ant.apache.org/ivy/get-involved.html</a>.<br class="xooki-br"/><br class="xooki-br"/><h3>3. How to Report Issues</h3>

The Apache Ivy project uses JIRA for issue tracking.  Please report any <br class="xooki-br"/>issues you find at <a href="http://issues.apache.org/jira/browse/IVY">http://issues.apache.org/jira/browse/IVY</a><br class="xooki-br"/><br class="xooki-br"/><h3>4. Committers and Contributors for this Release</h3>

Here is the list of people who have contributed source code and documentation<br class="xooki-br"/>to this release. Many thanks to all of them, and also to the whole Ivy community<br class="xooki-br"/>contributing ideas and feedback, and promoting the use of Ivy. The list would be too<br class="xooki-br"/>long, but Ivy couldn't be what it is without you!<br class="xooki-br"/><br class="xooki-br"/> Committers<br class="xooki-br"/>    Matt Benson<br class="xooki-br"/>    Jean-Louis Boudart<br class="xooki-br"/>    Maarten Coene<br class="xooki-br"/>    Xavier Hanin<br class="xooki-br"/>    Nicolas Lalevee<br class="xooki-br"/>    Jon Schneider<br class="xooki-br"/>    Gilles Scokart<br class="xooki-br"/><br class="xooki-br"/> Contributors<br class="xooki-br"/>    Arnold Blaasmo<br class="xooki-br"/>    Ed Burcher<br class="xooki-br"/>    Joseph Boyd<br class="xooki-br"/>    Wei Chen<br class="xooki-br"/>    Robin Fernandes<br class="xooki-br"/>    Wolfgang Frank<br class="xooki-br"/>    Mitch Gitman<br class="xooki-br"/>    Payam Hekmat<br class="xooki-br"/>    Stepan Koltsov<br class="xooki-br"/>    Thomas Kurpick<br class="xooki-br"/>    Ales Nosek<br class="xooki-br"/>    Douglas Palmer<br class="xooki-br"/>    Carl Quinn<br class="xooki-br"/>    Torkild U. Resheim<br class="xooki-br"/>    Jens Rohloff<br class="xooki-br"/>    Ben Schmidt<br class="xooki-br"/>    Nihal Sinha<br class="xooki-br"/>    Sven Zethelius<br class="xooki-br"/><br class="xooki-br"/>For the list of people who have contributed since Ivy inception, see CHANGES.txt file.<br class="xooki-br"/><br class="xooki-br"/><h3>5. List of Changes in this Release</h3>

For a full release history of Ivy see the file CHANGES.txt<br class="xooki-br"/><br class="xooki-br"/>For details about the following changes, check our JIRA install at <br class="xooki-br"/><a href="http://issues.apache.org/jira/browse/ivy">http://issues.apache.org/jira/browse/ivy</a><br class="xooki-br"/><br class="xooki-br"/>List of changes since Ivy 2.2.0:<br class="xooki-br"/>- DOCUMENTATION: Bad example in Project dependencies Tutorial (<a href="https://issues.apache.org/jira/browse/IVY-1263">IVY-1263</a>)<br class="xooki-br"/>- DOCUMENTATION: remove deprecated defaultCache setting from examples (<a href="https://issues.apache.org/jira/browse/IVY-1273">IVY-1273</a>) (thanks to Joseph Boyd)<br class="xooki-br"/>- DOCUMENTATION: link to FAQ is incorrect in distribution files (<a href="https://issues.apache.org/jira/browse/IVY-793">IVY-793</a>) (thanks to Joseph Boyd)<br class="xooki-br"/>- DOCUMENTATION: The tag version-matchers is missing attribute in documentation (<a href="https://issues.apache.org/jira/browse/IVY-1292">IVY-1292</a>) (thanks to Per Arnold Blaasmo)<br class="xooki-br"/>- DOCUMENTATION: wrong default resolver documented on the 'How does it work' page (<a href="https://issues.apache.org/jira/browse/IVY-1265">IVY-1265</a>)<br class="xooki-br"/>- DOCUMENTATION: Correct outdated links to configuration pages (<a href="https://issues.apache.org/jira/browse/IVY-1266">IVY-1266</a>)<br class="xooki-br"/>- DOCUMENTATION: Documentation and Implementation mismatch of makepom (<a href="https://issues.apache.org/jira/browse/IVY-1383">IVY-1383</a>) (thanks to Thomas Kurpick)<br class="xooki-br"/>- DOCUMENTATION: added link to extra beginners guide (<a href="https://issues.apache.org/jira/browse/IVY-1381">IVY-1381</a>)<br class="xooki-br"/><br class="xooki-br"/>- NEW: [orgPath] can now be used as token in ivy/artifact patterns<br class="xooki-br"/>- NEW: New Ant datatype ivy:resources, an Ant resource collection like ivy:cachepath or ivy:cachefileset (<a href="https://issues.apache.org/jira/browse/IVY-334">IVY-334</a>)<br class="xooki-br"/>- NEW: ivy:resolve and post resole task can now have inlined dependencies declaration.<br class="xooki-br"/>- NEW: Import Bushel into Ivy core (<a href="https://issues.apache.org/jira/browse/IVY-1241">IVY-1241</a>)<br class="xooki-br"/>- NEW: An new resolver 'mirroredurl' which can handle a list of mirrored URL repositories (<a href="https://issues.apache.org/jira/browse/IVY-468">IVY-468</a>)<br class="xooki-br"/>- NEW: Support for a jar resolver (<a href="https://issues.apache.org/jira/browse/IVY-1312">IVY-1312</a>)<br class="xooki-br"/><br class="xooki-br"/>- IMPROVEMENT: ivy:install task does not allow specification of conf (<a href="https://issues.apache.org/jira/browse/IVY-1313">IVY-1313</a>) (thanks to Nihal Sinha)<br class="xooki-br"/>- IMPROVEMENT: ivy:makepom ignores the artifact type in generated dependencies (<a href="https://issues.apache.org/jira/browse/IVY-1229">IVY-1229</a>) (thanks to Douglas Palmer)<br class="xooki-br"/>- IMPROVEMENT: ivy:makepom now honors exclusion of artifacts in generated pom files (<a href="https://issues.apache.org/jira/browse/IVY-1294">IVY-1294</a>) (thanks to Jens Rohloff)<br class="xooki-br"/>- IMPROVEMENT: Added support for dynamic revisions in <extends> tag (<a href="https://issues.apache.org/jira/browse/IVY-1281">IVY-1281</a>)<br class="xooki-br"/>- IMPROVEMENT: ivy:makepom child element dependency should support the type and classifier attributes (<a href="https://issues.apache.org/jira/browse/IVY-1262">IVY-1262</a>)<br class="xooki-br"/>- IMPROVEMENT: ivy:retrieve can now create a path or fileset containing the retrieved artifacts (<a href="https://issues.apache.org/jira/browse/IVY-1235">IVY-1235</a>)<br class="xooki-br"/>- IMPROVEMENT: Improve diagnostics in ssh resolver (<a href="https://issues.apache.org/jira/browse/IVY-1267">IVY-1267</a>) (thanks to Stepan Koltsov)<br class="xooki-br"/>- IMPROVEMENT: ivy:retrieve now accepts a nested mapper type.<br class="xooki-br"/><br class="xooki-br"/>- FIX: Ivy generates wrong revision in URL for Maven snapshots (<a href="https://issues.apache.org/jira/browse/IVY-1396">IVY-1396</a>)<br class="xooki-br"/>- FIX: Maven2: resolve failure when parent has <dependencyManagement> with dependency in 'import' scope (<a href="https://issues.apache.org/jira/browse/IVY-1376">IVY-1376</a>)<br class="xooki-br"/>- FIX: IvyPublish fails when using extend tags with no explicit location attribute (<a href="https://issues.apache.org/jira/browse/IVY-1391">IVY-1391</a>)<br class="xooki-br"/>- FIX: *.lck files created by "artifact-lock" lock strategy are not cleaned up if ivy quits abruptly (<a href="https://issues.apache.org/jira/browse/IVY-1388">IVY-1388</a>) (thanks to Wei Chen)<br class="xooki-br"/>- FIX: Ivy default cache path with non-ASCII character lets it crash (<a href="https://issues.apache.org/jira/browse/IVY-1378">IVY-1378</a>)<br class="xooki-br"/>- FIX: latest.integration isn't resolved against a Maven snapshot repository (when uniqueVersion = true) (<a href="https://issues.apache.org/jira/browse/IVY-1036">IVY-1036</a>)<br class="xooki-br"/>- FIX: Resolve does not deliver all dependent artifacts (<a href="https://issues.apache.org/jira/browse/IVY-1366">IVY-1366</a>) (thanks to Wolfgang Frank)<br class="xooki-br"/>- FIX: Ivy descriptors are merged incorrectly when there is an <exclude> element (<a href="https://issues.apache.org/jira/browse/IVY-1356">IVY-1356</a>)<br class="xooki-br"/>- FIX: SimpleDateFormat is not thread safe (<a href="https://issues.apache.org/jira/browse/IVY-1373">IVY-1373</a>)<br class="xooki-br"/>- FIX: Maven 'hk2-jar' packaging is now supported (<a href="https://issues.apache.org/jira/browse/IVY-1357">IVY-1357</a>)<br class="xooki-br"/>- FIX: Maven 'orbit' and 'pear' packaging is now supported (<a href="https://issues.apache.org/jira/browse/IVY-899">IVY-899</a>)<br class="xooki-br"/>- FIX: Memory leak and infinite loop in ModuleId.java (<a href="https://issues.apache.org/jira/browse/IVY-1362">IVY-1362</a>)<br class="xooki-br"/>- FIX: Unnecessary warning when parent ivy.xml is not found (<a href="https://issues.apache.org/jira/browse/IVY-1346">IVY-1346</a>)<br class="xooki-br"/>- FIX: StackOverflowError when using <extends> and ../ivy.xml is not the parent ivy.xml (<a href="https://issues.apache.org/jira/browse/IVY-1437">IVY-1437</a>)<br class="xooki-br"/>- FIX: NullPointerExeption in AbstractOSGiResolver (<a href="https://issues.apache.org/jira/browse/IVY-1343">IVY-1343</a>) (thanks to Thomas Kurpick)<br class="xooki-br"/>- FIX: Delivered ivy descriptor inconsistent with resolve report / retrieve and other post-resolve actions (<a href="https://issues.apache.org/jira/browse/IVY-1300">IVY-1300</a>) (thanks to Ed Burcher)<br class="xooki-br"/>- FIX: The Updatesite resolver is downloading Eclipse features instead of Eclipse bundle/plugin<br class="xooki-br"/>- FIX: ivy:buildlist task confused by extends feature using two parents (<a href="https://issues.apache.org/jira/browse/IVY-1363">IVY-1363</a>) (thanks to Mitch Gitman and Jean-Louis Boudart)<br class="xooki-br"/>- FIX: ivy.xml extends feature complains about Windows filesystem path (<a href="https://issues.apache.org/jira/browse/IVY-1359">IVY-1359</a>) (thanks to Mitch Gitman and Jean-Louis Boudart)<br class="xooki-br"/>- FIX: buildlist task chokes on absolute path to parent Ivy module (<a href="https://issues.apache.org/jira/browse/IVY-1364">IVY-1364</a>) (thanks to Mitch Gitman and Jean-Louis Boudart)<br class="xooki-br"/>- FIX: The ignore circular dependency strategy is clobbering the warn strategy (<a href="https://issues.apache.org/jira/browse/IVY-1353">IVY-1353</a>) (Thanks to Carl Quinn)<br class="xooki-br"/>- FIX: Buildnumber and IvyFindRevision Ant tasks should honour defaultBranch setting (<a href="https://issues.apache.org/jira/browse/IVY-1344">IVY-1344</a>) (Thanks to Ales Nosek)<br class="xooki-br"/>- FIX: ApacheURLLister.retrieveListing() fails if the encoding of the URL list is different from the default encoding (<a href="https://issues.apache.org/jira/browse/IVY-1060">IVY-1060</a>) (Thanks to Robin Fernandes)<br class="xooki-br"/>- FIX: global exclude rules is not applying to root ivy files<br class="xooki-br"/>- FIX: Exclude doesn't work when there is some circular dependencies (<a href="https://issues.apache.org/jira/browse/IVY-1309">IVY-1309</a>)<br class="xooki-br"/>- FIX: Impossible to get artifacts when data has not been loaded for multiple dynamic revisions (<a href="https://issues.apache.org/jira/browse/IVY-1333">IVY-1333</a>)<br class="xooki-br"/>- FIX: Ivy didn't properly handle some file: URLs (<a href="https://issues.apache.org/jira/browse/IVY-1340">IVY-1340</a>)<br class="xooki-br"/>- FIX: fallback mechanism didn't work properly for private configurations<br class="xooki-br"/>- FIX: /localivy target does not work when building Ivy jar (<a href="https://issues.apache.org/jira/browse/IVY-1338">IVY-1338</a>) (thanks to Ben Schmidt)<br class="xooki-br"/>- FIX: The showprogress=false attribute of ivy:resolve doesn't do what it should (<a href="https://issues.apache.org/jira/browse/IVY-1052">IVY-1052</a>) (thanks to Joseph Boyd)<br class="xooki-br"/>- FIX: extends ignores defaultconfmapping/defaultconf/confmappingoverride attributes from parent's configurations and dependencies tags (<a href="https://issues.apache.org/jira/browse/IVY-1213">IVY-1213</a>)<br class="xooki-br"/>- FIX: NullPointerException when providing empty password to <credentials> (<a href="https://issues.apache.org/jira/browse/IVY-1335">IVY-1335</a>)<br class="xooki-br"/>- FIX: [originalname] not expanded for source and javadoc types during publish in ivy:install (<a href="https://issues.apache.org/jira/browse/IVY-1324">IVY-1324</a>)<br class="xooki-br"/>- FIX: cannot resolve from repositories that return HTTP 204 in response to an HTTP HEAD request (<a href="https://issues.apache.org/jira/browse/IVY-1328">IVY-1328</a>)<br class="xooki-br"/>- FIX: extra attributes lost from info when ivy file is merged with parent (<a href="https://issues.apache.org/jira/browse/IVY-1206">IVY-1206</a>)<br class="xooki-br"/>- FIX: ivy:report ant task intermittently "cannot compile stylesheet" (<a href="https://issues.apache.org/jira/browse/IVY-1325">IVY-1325</a>)<br class="xooki-br"/>- FIX: Maven 'eclipse-plugin', 'jbi-component' and 'jbi-shared-library' packaging is now mapped to 'jar' extension (<a href="https://issues.apache.org/jira/browse/IVY-899">IVY-899</a>)<br class="xooki-br"/>- FIX: Infinite loop in latest-compatible conflict manager (<a href="https://issues.apache.org/jira/browse/IVY-1233">IVY-1233</a>) (thanks to Payam Hekmat and Sven Zethelius)<br class="xooki-br"/>- FIX: extends section of ivy.xml info does not replace variable in location tag (<a href="https://issues.apache.org/jira/browse/IVY-1287">IVY-1287</a>)<br class="xooki-br"/>- FIX: Valid Path does not work for Filesystem Resolver (<a href="https://issues.apache.org/jira/browse/IVY-1268">IVY-1268</a>)<br class="xooki-br"/>- FIX: quiet="true" does not surpress download 'dots' on packager resolver (<a href="https://issues.apache.org/jira/browse/IVY-1269">IVY-1269</a>)<br class="xooki-br"/>- FIX: Dynamic version resolution result can be incorrect when ivy metadata contains extra attributes (<a href="https://issues.apache.org/jira/browse/IVY-1236">IVY-1236</a>)<br class="xooki-br"/>- FIX: NullPointerException in FileUtil#forceDelete.<br class="xooki-br"/>- FIX: XmlModuleDescriptorUpdater is a mess that produces broken xmls in many cases (<a href="https://issues.apache.org/jira/browse/IVY-1010">IVY-1010</a>)<br class="xooki-br"/>- FIX: ivy.xml that contains UTF-8 encoded umlauts cannot be bigger than 10000 bytes (<a href="https://issues.apache.org/jira/browse/IVY-1253">IVY-1253</a>)<br class="xooki-br"/>- FIX: Can not use a v[revision] in an artifact pattern of a filesystem resolver (<a href="https://issues.apache.org/jira/browse/IVY-1238">IVY-1238</a>)<br class="xooki-br"/>- FIX: Cached ivy.xml is invalid if the description contains the ampersand entity (&amp;) (<a href="https://issues.apache.org/jira/browse/IVY-1237">IVY-1237</a>)<br class="xooki-br"/>- FIX: Couldn't authenticate against sites having the same address as the proxy server (<a href="https://issues.apache.org/jira/browse/IVY-1234">IVY-1234</a>)<br class="xooki-br"/>- FIX: OutOfMemoryError when uploading large files using commons-httpclient (<a href="https://issues.apache.org/jira/browse/IVY-1197">IVY-1197</a>) (thanks to Torkild U. Resheim)<br class="xooki-br"/>- FIX: Only the last dependency descriptor is taken into account on the same module (<a href="https://issues.apache.org/jira/browse/IVY-1240">IVY-1240</a>)<br class="xooki-br"/>- FIX: UseCacheOnly doesn't respect the cache configuration in the ivysettings (<a href="https://issues.apache.org/jira/browse/IVY-1227">IVY-1227</a>)<br class="xooki-br"/>- FIX: UseCacheOnly is influenced by the TTL on cached metadata (<a href="https://issues.apache.org/jira/browse/IVY-1243">IVY-1243</a>)<br class="xooki-br"/>- FIX: ConcurrentModificationException on ivy settings loading (<a href="https://issues.apache.org/jira/browse/IVY-1250">IVY-1250</a>)<br class="xooki-br"/>- FIX: Module inheritance sometimes fails to locate parent descriptor in deliver process (<a href="https://issues.apache.org/jira/browse/IVY-1248">IVY-1248</a>)<br class="xooki-br"/>- FIX: <cachefileset> on an empty configuration produces a very slow-to-evaluate fileset (<a href="https://issues.apache.org/jira/browse/IVY-1272">IVY-1272</a>)<br class="xooki-br"/>- FIX: Ivy does not apply overridden properties to m2 parent dependency versions specified using properties (<a href="https://issues.apache.org/jira/browse/IVY-1299">IVY-1299</a>)<br class="xooki-br"/>- FIX: Ivy does not apply overridden properties to m2 parent dependency versions specified using dependencyManagement properties (<a href="https://issues.apache.org/jira/browse/IVY-1301">IVY-1301</a>)<br class="xooki-br"/><hr/><div class='toc-title toc-title-2'>Tutorials</div><br class="xooki-br"/>The best way to learn is to practice! That's what the Ivy tutorials will help you to do, to discover some of the great Ivy features.<br class="xooki-br"/><br class="xooki-br"/>For the first tutorial you won't even have to install Ivy (assuming you have Ant and a JDK properly installed), and it shouldn't take more than 30 seconds.<br class="xooki-br"/><br class="xooki-br"/><b>First Tutorial</b><br class="xooki-br"/><ol>
<li>Make sure you have <a href="http://ant.apache.org/">ant</a> 1.6.0 or greater and a <a href="http://java.sun.com">jdk</a> properly installed</li>
<li>Copy <a href="samples/build.xml">this build file</a> in an empty directory on your local filesystem (and make sure you name it build.xml)</li>
<li>Open a console in this directory and run "ant". That's it!</li>
</ol>
If you have any trouble, check the <a href="http://ant.apache.org/ivy/faq.html">FAQ</a>. It is most likely related to your internet connection (proxy anyone?).<br class="xooki-br"/><br class="xooki-br"/>OK, you've just seen how easy it is to take your first step with Ivy. Go ahead with the other tutorials, but before you do, make sure you have properly <a href="install.html">installed</a> Ivy and downloaded the tutorials sources (included in all Ivy distributions, in the <tt><a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/example">src/example</a></tt> directory).<br class="xooki-br"/><br class="xooki-br"/>The following tutorials are available:
<ul>
<li><a href="tutorial/start.html">Quick Start</a></li> 
Guides you through your very first steps with ivy.
<li><a href="tutorial/defaultconf.html">Adjusting default settings</a></li> 
Gives you a better understanding of the default settings and shows you how to customize them to your needs.
<li><a href="tutorial/multiple.html">Multiple Resolvers</a></li> 
Teaches you how to configure Ivy to find its dependencies in multiple places.
<li><a href="tutorial/dual.html">Dual Resolver</a></li> 
Helps you configure Ivy to find ivy files in one place and artifacts in another.
<li><a href="tutorial/dependence.html">Project dependencies</a></a></li> 
A starting point for using Ivy in a multi-project environment.
<li><a href="tutorial/multiproject.html">Using Ivy in multiple projects environment</a></li> 
A more complex example demonstrating the use of Ant+Ivy in a multi-project environment.
<li><a href="tutorial/conf.html">Using Ivy Module Configurations</a></li> Shows you how to use configurations in an ivy file to define sets of artifacts.
<li><a href="tutorial/build-repository.html">Building a repository</a></li> 
Shows you how to build your own enterprise repository.
</ul>
	<hr/><div class='toc-title toc-title-3'>Quick Start</div><br class="xooki-br"/>In this tutorial, you will see one of the simplest ways to use Ivy. With no specific settings, Ivy uses the maven 2 repository to resolve the dependencies you declare in an Ivy file. Let's have a look at the content of the files involved. <br class="xooki-br"/><br class="xooki-br"/><em>You'll find this tutorial's sources in the ivy distribution in the src/example/hello-ivy directory.</em><br class="xooki-br"/><br class="xooki-br"/><h1>The ivy.xml file</h1>
This file is used to describe the dependencies of the project on other libraries.<br class="xooki-br"/>Here is the sample: 
<pre>
&lt;ivy-module version="2.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="hello-ivy"/&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="commons-lang" name="commons-lang" rev="2.0"/&gt;<br class="xooki-br"/>        &lt;dependency org="commons-cli" name="commons-cli" rev="1.0"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>

The format of this file should pretty easy to understand, but let's give some details about what is declared here. First, the root element ivy-module, with the version attribute used to tell Ivy which version of Ivy this file uses. <br class="xooki-br"/><br class="xooki-br"/>Then there is an info tag, which is used to give information about the module for which we are defining dependencies. Here we define only the organization and module name. You are free to choose whatever you want for them, but we recommend avoiding spaces for both.<br class="xooki-br"/><br class="xooki-br"/>Finally, the dependencies section lets you define dependencies. Here this module depends on two libraries: commons-lang and commons-cli. As you can see, we use the <tt>org</tt> and <tt>name</tt> attributes to define the organization and module name of the dependencies we need. The <tt>rev</tt> attribute is used to specify the version of the module you depend on. <br class="xooki-br"/><br class="xooki-br"/>To know what to put in these attributes, you need to know the exact information for the libraries you depend on. Ivy uses the maven 2 repository by default, so we recommend you use <a href="http://mvnrepository.com">mvnrepository.com</a> to look for the module you want. Once you find it, you will have the details on how to declare the dependency in a maven POM. For instance:
<pre>
&lt;dependency&gt;<br class="xooki-br"/>    &lt;groupId&gt;commons-lang&lt;/groupId&gt;<br class="xooki-br"/>    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;<br class="xooki-br"/>    &lt;version&gt;2.0&lt;/version&gt;<br class="xooki-br"/>&lt;/dependency&gt;
</pre>
To convert this into an Ivy dependency declaration, all you have to do is use the groupId as organization, the artifactId as module name, and the version as revision. That's what we did for the dependencies in this tutorial, that is commons-lang and commons-cli. Note that having commons-lang and commons-cli as organization is not the best example of what the organization should be. It would be better to use org.apache, org.apache.commons or org.apache.commons.lang. However, this is how these modules are identified in the maven 2 repository, so the simplest way to get them is to use the details as is (you will see in <a href="tutorial/build-repository.html">Building a repository</a> that you can use namespaces to redefine these names if you want something cleaner).<br class="xooki-br"/><br class="xooki-br"/>If you want more details on what you can do in Ivy files, you can have a look at the <a href="ivyfile.html">Ivy files reference documentation</a>.<br class="xooki-br"/><h1>The build.xml file</h1>
The corresponding build file contains a set of targets, allowing you to resolve dependencies declared in the Ivy file, to compile and run the sample code, produce a report of dependency resolution, and clean the cache or the project.<br class="xooki-br"/>You can use the standard "ant -p" to get the list of available targets. Feel free to have a look at the whole file, but here is the part relevant to dependency resolution:
<pre>
&lt;project xmlns:ivy="antlib:org.apache.ivy.ant" name="hello-ivy" default="run"&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    ...<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;!-- ================================= <br class="xooki-br"/>          target: resolve              <br class="xooki-br"/>         ================================= --&gt;<br class="xooki-br"/>    &lt;target name="resolve" description="--&gt; retrieve dependencies with ivy"&gt;<br class="xooki-br"/>        &lt;ivy:retrieve /&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/>&lt;/project&gt;
</pre>
As you can see, it's very easy to call Ivy to resolve and retrieve dependencies: all you need if Ivy is properly <a href="install.html">installed</a> is to define an XML namespace in your Ant file (xmlns:ivy="antlib:org.apache.ivy.ant"). Then all the <a href="ant.html">Ivy ant tasks</a> will be available in this namespace.<br class="xooki-br"/><br class="xooki-br"/>Here we use only one task: the <a href="use/retrieve.html">retrieve</a> task. With no attributes, it will use default settings and look for a file named <tt>ivy.xml</tt> for the dependency definitions. That's exactly what we want, so we need nothing more than that.<br class="xooki-br"/><br class="xooki-br"/>Note that in this case we define a <tt>resolve</tt> target and call the <tt><a href="use/retrieve.html">retrieve</a></tt> task. This may sound confusing, actually the retrieve task performs a <a href="use/resolve.html">resolve</a> (which resolves dependencies and downloads them to a cache) followed by a retrieve (a copy of those file to a local project directory). Check the <a href="principle.html">How does it work ?</a> page for details about that.<br class="xooki-br"/><h1>Running the project</h1>
OK, now that we have seen the files involved, let's run the sample to see what happens. Open a shell (or command line) window, and enter the <tt>hello-ivy</tt> example directory.<br class="xooki-br"/>Then, at the command prompt, run <tt>ant</tt>:
<div class="shell"><pre>
[ivy@apache:/ivy/hello-ivy]$ ant 
Buildfile: /ivy/hello-ivy/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: url = jar:file:///home/ivy/ivy.jar!/org/apache/ivy/core/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#hello-ivy;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in public
[ivy:retrieve] 	found commons-cli#commons-cli;1.0 in public
[ivy:retrieve] 	found commons-logging#commons-logging;1.0 in public
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/2.0/commons-lang-2.0-javadoc.jar ...
[ivy:retrieve] ................................... (467kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-lang#commons-lang;2.0!commons-lang.jar(javadoc) (1154ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/2.0/commons-lang-2.0-sources.jar ...
[ivy:retrieve] .................. (245kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-lang#commons-lang;2.0!commons-lang.jar(source) (764ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/2.0/commons-lang-2.0.jar ...
[ivy:retrieve] ............... (165kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-lang#commons-lang;2.0!commons-lang.jar (484ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-cli/commons-cli/1.0/commons-cli-1.0-javadoc.jar ...
[ivy:retrieve] ....... (92kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-cli#commons-cli;1.0!commons-cli.jar(javadoc) (375ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-cli/commons-cli/1.0/commons-cli-1.0.jar ...
[ivy:retrieve] ..... (29kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-cli#commons-cli;1.0!commons-cli.jar (171ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-cli/commons-cli/1.0/commons-cli-1.0-sources.jar ...
[ivy:retrieve] ...... (48kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-cli#commons-cli;1.0!commons-cli.jar(source) (281ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-logging/commons-logging/1.0/commons-logging-1.0.jar ...
[ivy:retrieve] .... (21kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-logging#commons-logging;1.0!commons-logging.jar (249ms)
[ivy:retrieve] :: resolution report :: resolve 1326ms :: artifacts dl 3541ms
[ivy:retrieve] 	:: evicted modules:
[ivy:retrieve] 	commons-lang#commons-lang;1.0 by [commons-lang#commons-lang;2.0] in [default]
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   4   |   3   |   3   |   1   ||   7   |   7   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#hello-ivy
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	7 artifacts copied, 0 already retrieved (1069kB/78ms)

run:
    [mkdir] Created dir: /ivy/hello-ivy/build
    [javac] Compiling 1 source file to /ivy/hello-ivy/build
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !

BUILD SUCCESSFUL
Total time: 6 seconds

</pre></div>
<h1>What happened ?</h1>
Without any settings, Ivy retrieves files from the maven 2 repository. That's what happened here. <br class="xooki-br"/>The resolve task has found the commons-lang and commons-cli modules in the maven 2 repository, identified that commons-cli depends on commons-logging and so resolved it as a transitive dependency. Then Ivy has downloaded all corresponding artifacts in its cache (by default in your user home, in a .ivy2/cache directory). Finally, the retrieve task copies the resolved jars from the ivy cache to the default library directory of the project: the lib dir (you can change this easily by setting the pattern attribute on the <a href="use/retrieve.html">retrieve</a> task).<br class="xooki-br"/><br class="xooki-br"/>You might say that the task took a long time just to write out a "Hello Ivy!" message. But remember that a lot of time was spent downloading the required files from the web. Let's try to run it again:
<div class="shell"><pre>
[ivy@apache:/ivy/hello-ivy]$ ant 
Buildfile: /ivy/hello-ivy/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: url = jar:file:///home/ivy/ivy.jar!/org/apache/ivy/core/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#hello-ivy;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in public
[ivy:retrieve] 	found commons-cli#commons-cli;1.0 in public
[ivy:retrieve] 	found commons-logging#commons-logging;1.0 in public
[ivy:retrieve] :: resolution report :: resolve 171ms :: artifacts dl 0ms
[ivy:retrieve] 	:: evicted modules:
[ivy:retrieve] 	commons-lang#commons-lang;1.0 by [commons-lang#commons-lang;2.0] in [default]
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   4   |   0   |   0   |   1   ||   7   |   0   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#hello-ivy
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	0 artifacts copied, 7 already retrieved (0kB/16ms)

run:
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !

BUILD SUCCESSFUL
Total time: 1 second

</pre></div>
Great! The cache was used, so no download was needed and the build was instantaneous.<br class="xooki-br"/><br class="xooki-br"/>And now, if you want to generate a report detailing all the dependencies of your module, you can call the report target, and check the generated file in the build directory. You should obtain something looking like <a href="../samples/apache-hello-ivy-default.html">this</a>.<br class="xooki-br"/><br class="xooki-br"/>As you can see, using Ivy to resolve dependencies stored in the maven 2 repository is extremely easy. Now you can go on with the next tutorials to learn more about <a href="tutorial/conf.html">how to use module configurations</a> which is a very powerful Ivy specific feature. Other tutorials are also available where you will learn how to use Ivy settings to leverage a possibly complex enterprise repository. It may also be a good time to start reading the <a href="reference.html">reference documentation</a>, and especially the introduction material which gives a good overview of Ivy. The <a href="bestpractices.html">best practices</a> page is also a must read to start thinking about how to use Ant+Ivy to build a clean and robust build system.<hr/><div class='toc-title toc-title-3'>Adjusting default settings</div><br class="xooki-br"/>Ivy comes bundled with some default settings which makes it pretty simple to use in a typical environment. This tutorial, which is close to a reference document, explains what those default settings are and how they can be adjusted to your needs. <br class="xooki-br"/><br class="xooki-br"/>To fully understand the concept of settings and what you can do with them, we suggest reading other tutorials related to settings (like <a href="tutorial/multiple.html">Multiple Resolvers</a> and <a href="tutorial/dual.html">Dual Resolver</a>) or the <a href="settings.html">Settings Files</a> reference documentation.<br class="xooki-br"/><br class="xooki-br"/><h1>Concept</h1>
The default settings include 3 types of repositories:
<ul>
<li>local</li> a repository which is private to the user. 
<li>shared</li> a repository which is shared between all the members of a team
<li>public</li> a public repository on which most modules, and especially third party modules, can be found
</ul>

Note that if you work alone, the distinction between a local and shared repository is not very important, but there are some things you should know to distinguish them.<br class="xooki-br"/><br class="xooki-br"/>Now let's describe each of these repository concepts in more detail. We will describe how they are set up physically later.<br class="xooki-br"/><h2>Local</h2>
The local repository is particularly useful when you want to do something without being disturbed by anything else happening in the environment. This means that whenever Ivy is able to locate a module in this repository it will be used, no matter what is available in others.<br class="xooki-br"/><br class="xooki-br"/>For instance, if you have a module declaring a dependency on the module <i>foo</i> with a revision of <i>latest.integration</i>, then if a revision of <i>foo</i> is found in the local repository, it will be used, <em>even if a more recent revision is available in other repositories</em>. <br class="xooki-br"/><br class="xooki-br"/>This may be disturbing for some of you, but imagine you have to implement a new feature on a project, and in order to achieve that you need to modify two modules: you add a new method in module <i>foo</i> and exploit this new method in module <i>bar</i>. Then if you publish the module <i>foo</i> to your local repository, you will be sure to get it in your <i>bar</i> module, even if someone else publishes a new revision of <i>foo</i> in the shared repository (this revision not having the new method you are currently adding).<br class="xooki-br"/><br class="xooki-br"/>But be careful, when you have finished your development and publish it on the shared repository, you will have to clean your local repository to benefit from new versions published in the shared repository.<br class="xooki-br"/><br class="xooki-br"/>Note also that modules found in the local repository must be complete, i.e. they must provide both a module descriptor and the published artifacts. <br class="xooki-br"/><h2>Shared</h2>
As its name suggest, the shared repository is aimed to be shared among a whole development team. It is a place where you can publish your team's private modules, and it's also a place where you can put modules not available in the public repository (sun jars, for instance). You can also put modules here that are simply inaccurate in a public repository (bad or incomplete module descriptors for instance).<br class="xooki-br"/><br class="xooki-br"/>Note that modules can be split across the shared repository and the public one: For example, you can have the module descriptor in the shared repository and the artifacts in the public one.<br class="xooki-br"/><h2>Public</h2>
The public repository is the place where most modules can be found, but which sometimes lack the information you need. It's usually a repository available through an internet connection only, even if this is not mandatory.<br class="xooki-br"/><h1>Setting up the repositories</h1>
Now that we have seen the objective of each of the three repositories, let's see how they are setup and how to configure them to fit your needs.<br class="xooki-br"/><br class="xooki-br"/>First, several repositories use the same root in your filesystem. Referenced as <tt>${ivy.default.ivy.user.dir}</tt>, this is by default the directory <tt>.ivy2</tt> in your user home.<br class="xooki-br"/><br class="xooki-br"/>Note that several things can be done by setting Ivy variables. To set them without defining your own <tt>ivysettings.xml</tt> file, you can:<ul>
<li>set an Ant property before any call to Ivy in your build file if you use Ivy from Ant</li>
<li>set an environment variable if you use Ivy from the command line</li>
</ul>
For example:
<pre>
&lt;target name="resolve"&gt;<br class="xooki-br"/>  &lt;property name="ivy.default.ivy.user.dir" value="/path/to/ivy/user/dir"/&gt;<br class="xooki-br"/>  &lt;ivy:resolve /&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>

Next we will show you how to override default values for the different kinds of repositories. Note that you can find what the default values are below in the details of the default settings.<br class="xooki-br"/><h2>Local</h2>
By default, the local repository lies in <tt>${ivy.default.ivy.user.dir}/local</tt>. This is usually a good place, but you may want to modify it. No problem, you just have to set the following Ivy variable to the directory you want to use: <pre>ivy.local.default.root</pre>. For instance:
<pre>ivy.local.default.root=/opt/ivy/repository/local</pre>.<br class="xooki-br"/><br class="xooki-br"/>If you already have something you would like to use as your local repository, you may also want to modify the layout of this repository. Once again, two variables are available for that:
<pre>ivy.local.default.ivy.pattern</pre> gives the pattern to find ivy files
<pre>ivy.local.default.artifact.pattern</pre> gives the pattern to find artifacts<br class="xooki-br"/>For example:
<pre>
ivy.local.default.root=/opt/ivy/repository/local<br class="xooki-br"/>ivy.local.default.ivy.pattern=[module]/[revision]/ivy.xml<br class="xooki-br"/>ivy.local.default.artifact.pattern=[module]/[revision]/[artifact].[ext]
</pre>
<h2>Shared</h2>
By default, the shared repository lies in <tt>${ivy.default.ivy.user.dir}/shared</tt>. This is fine if you work alone, but the shared repository is supposed to be, mmm, shared! So changing this directory is often required, and it is usually modified to point to a network shared directory. You can use the <pre>ivy.shared.default.root</pre> variable to specify a different directory. Moreover, you can also configure the layout with variables similar to the ones used for the local repository:
<pre>ivy.shared.default.ivy.pattern</pre> gives the pattern to find ivy files
<pre>ivy.shared.default.artifact.pattern</pre> gives the pattern to find artifacts<br class="xooki-br"/>For example:
<pre>
ivy.shared.default.root=/opt/ivy/repository/shared<br class="xooki-br"/>ivy.shared.default.ivy.pattern=[organisation]/[module]/[revision]/ivy.xml<br class="xooki-br"/>ivy.shared.default.artifact.pattern=[organisation]/[module]/[revision]/[artifact].[ext]
</pre>

<h2>Public</h2>
By default, the public repository is ibiblio in m2 compatible mode (in other words, the maven 2 public repository).<br class="xooki-br"/><br class="xooki-br"/>This repository has the advantage of providing a lot of modules, with metadata for most of them. The quality of metadata is not always perfect, but it's a very good start to use a tool like Ivy and benefit from the power of transitive dependency management. <br class="xooki-br"/><br class="xooki-br"/>Despite its ease of use, we suggest reading the <a href="bestpractices.html">Best practices</a> to have a good understanding of the pros and cons of using a public unmanaged repository before depending on such a repository for your enterprise build system.<br class="xooki-br"/><br class="xooki-br"/><em>In 1.4 version Ivy was using ivyrep as the default resolver, if you want to restore this, set<br class="xooki-br"/>ivy.14.compatible=true as an ant property</em><br class="xooki-br"/><br class="xooki-br"/><h1>Going further</h1>
OK, so we have seen how to easily change the settings of the three main repositories. But what if my shared repository is on a web server? What if you don't want to use maven 2 repository as the public repository? What if ... <br class="xooki-br"/><br class="xooki-br"/>No problem, Ivy is very flexible and can be configured with specific settings to match your needs and environment. But before considering writing your own settings from scratch, we suggest reading the following where you will learn how to leverage a part of the default settings and adjust the rest.<br class="xooki-br"/><br class="xooki-br"/>But before explaining how, you will need to have a quick overview of how Ivy is configured by default.<br class="xooki-br"/><br class="xooki-br"/>By default, Ivy is configured using an <tt>ivysettings.xml</tt> which is packaged in the Ivy jar. Here is this settings file:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;settings defaultResolver="default"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-public.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-shared.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-local.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-main-chain.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-default-chain.xml"/&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
OK, so not much info here, except a lot of inclusions. These inclusions have been done on purpose so that you can easily change only one part of the ivysettings and easily benefit from the rest. For example, if you want to define your own public resolver, you will just have to configure Ivy with an ivysettings like the following:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;settings defaultResolver="default"/&gt;<br class="xooki-br"/>  &lt;include url="<a href="http://myserver/ivy/myivysettings-public.xml">http://myserver/ivy/myivysettings-public.xml</a>"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-shared.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-local.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-main-chain.xml"/&gt;<br class="xooki-br"/>  &lt;include url="${ivy.default.settings.dir}/ivysettings-default-chain.xml"/&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
Note that only the <tt>ivysettings-public.xml</tt> inclusion has changed to include a homemade public resolver. Note also that this can be used like that thanks to the fact that <tt>${ivy.default.settings.dir}</tt> is a variable which is always set to the place where Ivy's default settings files are (i.e. packaged in the jar).<br class="xooki-br"/>To finish this example, you have to write your own ivysettings file (that you will make available at <a href="http://myserver/ivy/myivysettings-public.xml">http://myserver/ivy/myivysettings-public.xml</a> in this example) for defining your own public resolver. For instance:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;filesystem name="public"&gt;<br class="xooki-br"/>      &lt;ivy pattern="/path/to/my/public/rep/[organisation]/[module]/ivy-[revision].xml" /&gt;<br class="xooki-br"/>      &lt;artifact pattern="/path/to/my/public/rep/[organisation]/[module]/[artifact]-[revision].[ext]" /&gt;<br class="xooki-br"/>    &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
Now the last thing you will need in order to properly take advantage of the default settings is the content of each included ivysettings file:<br class="xooki-br"/><strong>ivysettings-public.xml</strong>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;ibiblio name="public" m2compatible="true"/&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
<strong>ivysettings-shared.xml</strong>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;property name="ivy.shared.default.root"             value="${ivy.default.ivy.user.dir}/shared" override="false"/&gt;<br class="xooki-br"/>  &lt;property name="ivy.shared.default.ivy.pattern"      value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/&gt;<br class="xooki-br"/>  &lt;property name="ivy.shared.default.artifact.pattern" value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;filesystem name="shared"&gt;<br class="xooki-br"/>      &lt;ivy pattern="${ivy.shared.default.root}/${ivy.shared.default.ivy.pattern}" /&gt;<br class="xooki-br"/>      &lt;artifact pattern="${ivy.shared.default.root}/${ivy.shared.default.artifact.pattern}" /&gt;<br class="xooki-br"/>    &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
<strong>ivysettings-local.xml</strong>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;property name="ivy.local.default.root"             value="${ivy.default.ivy.user.dir}/local" override="false"/&gt;<br class="xooki-br"/>  &lt;property name="ivy.local.default.ivy.pattern"      value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/&gt;<br class="xooki-br"/>  &lt;property name="ivy.local.default.artifact.pattern" value="[organisation]/[module]/[revision]/[type]s/[artifact].[ext]" override="false"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;filesystem name="local"&gt;<br class="xooki-br"/>      &lt;ivy pattern="${ivy.local.default.root}/${ivy.local.default.ivy.pattern}" /&gt;<br class="xooki-br"/>      &lt;artifact pattern="${ivy.local.default.root}/${ivy.local.default.artifact.pattern}" /&gt;<br class="xooki-br"/>    &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
<strong>ivysettings-main-chain.xml</strong>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;chain name="main" dual="true"&gt;<br class="xooki-br"/>      &lt;resolver ref="shared"/&gt;<br class="xooki-br"/>      &lt;resolver ref="public"/&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
<strong>ivysettings-default-chain.xml</strong>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;chain name="default" returnFirst="true"&gt;<br class="xooki-br"/>      &lt;resolver ref="local"/&gt;<br class="xooki-br"/>      &lt;resolver ref="main"/&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

There you go, you should have enough clues to configure Ivy the way you want. Check the <a href="settings.html">settings documentation</a> to see if what you want to do is possible, and go ahead!<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-3'>Multiple Resolvers</div><br class="xooki-br"/>This tutorial is an example of how modules can be retrieved by multiple resolvers. Using multiple resolvers can be useful in many contexts. For example:
<ul>
<li>separating integration builds from releases</li>
<li>using a public repository for third party modules and a private one for internal modules</li>
<li>use a repository for storing modules which are not accurate in an unmanaged public repository</li>
<li>use a local repository to expose builds made on one developer's station</li>
</ul>

In Ivy, the use of multiple resolvers is supported by a compound resolver called the chain resolver.<br class="xooki-br"/><br class="xooki-br"/>In our example, we will simply show you how to use two resolvers, one on a local repository and one using the maven2 repository.<br class="xooki-br"/><br class="xooki-br"/><h1>project description</h1>
<h2>the project: chained-resolvers</h2>
The project is very simple and contains only one simple class: example.Hello.<br class="xooki-br"/><br class="xooki-br"/>It depends on two libraries: Apache's commons-lang and a custom library named test (sources are included in test-1.0jar file). The test library is used by the project to uppercase a string, and commons-lang is used to capitalize the same string.<br class="xooki-br"/><br class="xooki-br"/>Here is the content of the project:
<ul>
  <li>build.xml: the ant build file for the project</li>
  <li>ivy.xml: the Ivy project file</li>
  <li>src\example\Hello.java: the only class of the project</li>
</ul>
Let's have a look at the <b>ivy.xml</b> file:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="chained-resolvers"/&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="commons-lang" name="commons-lang" rev="2.0"/&gt;<br class="xooki-br"/>        &lt;dependency name="test" rev="1.0"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
As we'd expect, the ivy file declares this module to be dependent on the two libraries it uses: 'commons-lang' and 'test'. Note that we didn't specify the org for the dependency 'test'. When we exclude org, Ivy assumes it is in the same org as the declaring module. (i.e. 'org.apache').<br class="xooki-br"/><br class="xooki-br"/><h2>the <b>ivy settings</b></h2>
The settings are defined in the ivysettings.xml file located in the settings directory of the project. Below are its contents, followed by an explanation of what it's doing.<br class="xooki-br"/>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;settings defaultResolver="chain-example"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;chain name="chain-example"&gt;<br class="xooki-br"/>      &lt;filesystem name="libraries"&gt;<br class="xooki-br"/>        &lt;artifact pattern="${ivy.settings.dir}/repository/[artifact]-[revision].[ext]" /&gt;<br class="xooki-br"/>      &lt;/filesystem&gt;<br class="xooki-br"/>      &lt;ibiblio name="ibiblio" m2compatible="true" /&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
<h2>the <b>settings</b> tag</h2>
This tag initializes Ivy with some parameters. Here only one parameter is set, the name of the resolver to use by default.<br class="xooki-br"/><br class="xooki-br"/><h2>the <b>resolvers</b> tag</h2>
The resolvers section defines the list of resolvers that Ivy will use to locate artifacts. In our example, we have only one resolver named "chain-example", which is unique in that it defines a list (hence a chain) of resolvers.<br class="xooki-br"/>The resolvers in this chain are:
<ul>
  <li>libraries : It is a filesystem resolver, so looks at a directory structure to retrieve the artifacts. This one is configured to look in the <tt>repository</tt> sub directory of the directory that contains the <tt>ivysettings.xml</tt> file.</li>
  <li>ibiblio : It looks in the ibiblio maven repository to retrieve the artifacts.</li>
</ul>

That's it, we have just configured a chain of resolvers!<br class="xooki-br"/><br class="xooki-br"/><h1>walkthrough</h1>
<div class="step">
<h2>step 1: preparation</h2>
Open a DOS or shell window, and go to the "chained-resolvers" directory.
</div>
<div class="step">
<h2>step 2: clean directory tree</h2>
On the prompt type: ant<br>
This will clean up the entire project directory tree and Ivy cache. You can do this each time you want to clean up this example.<br class="xooki-br"/>
<div class="tip">
In almost all examples, we provide a clean target as default target. Since most examples use the same Ivy cache, you will clean the whole Ivy cache each time you call this target. <br class="xooki-br"/><br class="xooki-br"/>Cleaning the Ivy cache is something you can do without fear (except performance): it's only a cache, so everything can be (and should be) obtained again from repositories. This may sound strange to those coming from maven 2 land. But remember that in Ivy, the cache is not a local repository and the two are completely isolated.
</div>
</div>
<div class="step">
<h2>step 3: run the project</h2>
Go to <tt>chained-resolvers</tt> project directory. And simply run <tt>ant</tt>.<br class="xooki-br"/>
<div class="shell"><pre>
[ivy@apache:/ivy/chained-resolvers/chainedresolvers-project]$ ant 
Buildfile: /ivy/chained-resolvers/chainedresolvers-project/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: file = /ivy/chained-resolvers/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#chained-resolvers;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in ibiblio
[ivy:retrieve] 	found org.apache#test;1.0 in libraries
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/2.0/commons-lang-2.0.jar ...
[ivy:retrieve] ...................... (165kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-lang#commons-lang;2.0!commons-lang.jar (484ms)
[ivy:retrieve] downloading /ivy/chained-resolvers/settings/repository/test-1.0.jar ...
[ivy:retrieve] .. (1kB)
[ivy:retrieve] 	[SUCCESSFUL ] org.apache#test;1.0!test.jar (15ms)
[ivy:retrieve] :: resolution report :: resolve 749ms :: artifacts dl 499ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   2   |   2   |   1   |   0   ||   2   |   2   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#chained-resolvers
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	2 artifacts copied, 0 already retrieved (166kB/32ms)

run:
    [mkdir] Created dir: /ivy/chained-resolvers/chainedresolvers-project/build
    [javac] /ivy/chained-resolvers/chainedresolvers-project/build.xml:58: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds
    [javac] Compiling 1 source file to /ivy/chained-resolvers/chainedresolvers-project/build
     [java] standard message :example world !
     [java] capitalized by org.apache.commons.lang.WordUtils : Example World !
     [java] upperCased by test.StringUtils : EXAMPLE WORLD !

BUILD SUCCESSFUL
Total time: 3 seconds

</pre></div></div>

We can see in the log of the resolve task, that the two dependencies have been retrieved (2 artifacts) and copied to the Ivy cache directory (2 downloaded). <br class="xooki-br"/><br class="xooki-br"/>Also notice that the 'run' Ant target succeeded in using both commons-lang.jar coming from the ibiblio repository and test.jar coming from the local repository.<br class="xooki-br"/><br class="xooki-br"/><h1>Going further</h1>
This very simple example helps us see how to set up two resolvers in a chain. The <a href="resolver/chain.html">chain resolver's reference documentation</a> is available for those who would like to know all the features offered by this resolver.<br class="xooki-br"/><br class="xooki-br"/>Below are a few more interesting things worth knowing about chain resolvers. After reading them, go ahead and try tweaking this example using your new wealth of knowledge!
<ul>
<li>a chain is not limited to two nested resolvers, you can use as many as you want</li>
<li>by setting <tt>returnFirst="true"</tt>, you can have a chain which stops as soon as it has found a result for a given module</li>
<li>by setting <tt>dual="true"</tt>, the full chain will be used both for module descriptors and artifacts, while setting <tt>dual="false"</tt>, the resolver in the chain which found the module descriptor (if any) is also used for artifacts</li>
</ul>

	<hr/><div class='toc-title toc-title-3'>Dual Resolver</div><br class="xooki-br"/>In some cases, your module descriptions (i.e. Ivy files, maven poms) are located separately from the module artifacts (i.e. jars). So what can you do about it?<br class="xooki-br"/><br class="xooki-br"/>Use a Dual resolver! And this tutorial will show you how.<br class="xooki-br"/><br class="xooki-br"/><h1>project description</h1>
Let's have a look at the <tt>src/example/dual</tt> directory in your Ivy distribution.<br class="xooki-br"/>It contains a build file and 3 directories:
<ul>
<li>settings: contains the ivy settings file</li>
<li>repository: a sample repository of ivy files</li>
<li>project: the project making use of Ivy with dual resolver</li>
</ul>

<h2>the dual project</h2>
The project is very simple and contains only one simple class: <tt>example.Hello</tt>
It depends on two libraries: Apache commons-lang and Apache commons-httpclient.<br class="xooki-br"/><br class="xooki-br"/>Here is the content of the project:
<ul>
  <li>build.xml: the ant build file for the project</li>
  <li>ivy.xml: the ivy project file</li>
  <li>src\example\Hello.java: the only class of the project</li>
</ul>

Let's have a look at the <tt>ivy.xml</tt> file:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="hello-ivy"/&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="commons-httpclient" name="commons-httpclient" rev="2.0.2"/&gt;<br class="xooki-br"/>        &lt;dependency org="commons-lang" name="commons-lang" rev="2.0"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>

As you can see, nothing special here... Indeed, Ivy's philosophy is to keep ivy files independent of the way dependencies are resolved.<br class="xooki-br"/><br class="xooki-br"/><h2>the <b>ivy</b> settings</h2>
The ivy settings are defined in the <tt>ivysettings.xml</tt> file located in the <tt>settings</tt> directory. Here is what it contains, followed by an explanation.<br class="xooki-br"/>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;settings defaultResolver="dual-example"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;dual name="dual-example"&gt;<br class="xooki-br"/>      &lt;filesystem name="ivys"&gt;<br class="xooki-br"/>        &lt;ivy pattern="${ivy.settings.dir}/../repository/[module]-ivy-[revision].xml" /&gt;<br class="xooki-br"/>      &lt;/filesystem&gt;<br class="xooki-br"/>      &lt;ibiblio name="ibiblio" m2compatible="true" usepoms="false" /&gt;<br class="xooki-br"/>    &lt;/dual&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

Here we configured one resolver, the default one, which is a dual resolver. This dual resolver has two sub resolvers: the first is what is called the "ivy" or "metadata" resolver of the dual resolver, and the second one is what is called the "artifact" resolver. It is important that the dual resolver has exactly two sub resolvers in this given order.<br class="xooki-br"/><br class="xooki-br"/>The metadata resolver, here a filesystem one, is used only to find module descriptors, in this case Ivy files. The setting shown here tells Ivy that all ivy files are in the <tt>repository</tt> directory, named with the pattern: <tt>[module]-ivy-[revision].xml</tt>. If we check the <tt>repository</tt> directory, we can confirm that it contains a file named <tt>commons-httpclient-ivy-2.0.2.xml</tt>. This file matches the pattern, so it will be found by the resolver.<br class="xooki-br"/><br class="xooki-br"/>The artifact resolver is simply an ibiblio one, configured in m2compatible mode to use the maven 2 repository, with <tt>usepoms="false"</tt> to make sure it won't use maven 2 metadata. Note that this isn't necessary, since the second resolver in a dual resolver (the artifact resolver) is never asked to find module metadata.<br class="xooki-br"/><br class="xooki-br"/><h1>walkthrough</h1>
<div class="step">
<h2>step 1 : preparation</h2>
Open a DOS or shell window, and go to the <tt>dual</tt> directory.
</div>
<div class="step">
<h2>step 2 : clean up</h2>
On the prompt type : <tt>ant</tt><br>
This will clean up the entire project directory tree (compiled classes and retrieved libs) and the Ivy cache. You can run this each time you want to clean up this example.
</div>
<div class="step">
<h2>step 3 : run the project</h2>
Go to the project directory. And simply run <tt>ant</tt>.
<div class="shell"><pre>
[ivy@apache:/ivy/dual/project]$ ant 
Buildfile: /ivy/dual/project/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: file = /ivy/dual/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#hello-ivy;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found commons-httpclient#commons-httpclient;2.0.2 in ivys
[ivy:retrieve] 	found commons-logging#commons-logging;1.0.4 in ibiblio
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in ibiblio
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-httpclient/commons-httpclient/2.0.2/commons-httpclient-2.0.2.jar ...
[ivy:retrieve] ........................... (220kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-httpclient#commons-httpclient;2.0.2!commons-httpclient.jar (655ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/2.0/commons-lang-2.0.jar ...
[ivy:retrieve] .............. (165kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-lang#commons-lang;2.0!commons-lang.jar (452ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-logging/commons-logging/1.0.4/commons-logging-1.0.4.jar ...
[ivy:retrieve] ...... (37kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-logging#commons-logging;1.0.4!commons-logging.jar (187ms)
[ivy:retrieve] :: resolution report :: resolve 203ms :: artifacts dl 1310ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   3   |   3   |   1   |   0   ||   3   |   3   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#hello-ivy
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	3 artifacts copied, 0 already retrieved (423kB/31ms)

run:
    [mkdir] Created dir: /ivy/dual/project/build
    [javac] Compiling 1 source file to /ivy/dual/project/build
     [java] standard message : hello ivy !
     [java] capitalized by org.apache.commons.lang.WordUtils : Hello Ivy !
     [java] head status code with httpclient: 200
     [java] now check if httpclient dependency on commons-logging has been realized
     [java] found logging class in classpath: interface org.apache.commons.logging.Log

BUILD SUCCESSFUL
Total time: 3 seconds

</pre></div></div>
<br/>
As you can see, Ivy not only downloaded commons-lang and commons-httpclient, but also commons-logging. Indeed, commons-logging is a dependency of httpclient, as we can see in the httpclient ivy file found in the <tt>repository</tt> directory:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info <br class="xooki-br"/>        organisation="commons-httpclient"<br class="xooki-br"/>        module="commons-httpclient"<br class="xooki-br"/>        revision="2.0.2"<br class="xooki-br"/>        status="release"<br class="xooki-br"/>        publication="20041010174300"/&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="commons-logging" name="commons-logging" rev="1.0.4" conf="default"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
<br/>
So everything seemed to work. The ivy file was found in the <tt>repository</tt> directory and the artifacts have been downloaded from ibiblio. <br class="xooki-br"/><br class="xooki-br"/>This kind of setup can be useful if you don't want to rely on the maven 2 repository for metadata, or if you want to take full advantage of Ivy files for some or all modules. Combining chain and dual resolvers should give you enough flexibility to meet almost any requirement.<br class="xooki-br"/><br class="xooki-br"/>For full details about the dual resolver, have a look at the corresponding <a href="resolver/dual.html">reference documentation</a>.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-3'>Project dependencies</div><br class="xooki-br"/>This tutorial will show you how to use Ivy when one of your projects depends on another.<br class="xooki-br"/><br class="xooki-br"/>For our example, we will have two projects, depender and dependee, where the depender project uses/requires the dependee project. This example will help illustrate two things about Ivy: 
<ul>
  <li>that dependencies defined by parent projects (dependee) will automatically be retrieved for use by child projects (depender)</li>
  <li>that child projects can retrieve the "latest" version of the dependee project</li>
</ul>
<h1>projects used</h1>
<h2>dependee</h2>
The dependee project is very simple. It depends on the apache library commons-lang and contains only one class: <tt>standalone.Main</tt> which provides two services:
<ul>
  <li>return the version of the project</li>
  <li>capitalize a string using <tt>org.apache.commons.lang.WordUtils.capitalizeFully</tt></li>
</ul>
Here is the content of the project:
<ul>
  <li>build.xml: the ant build file for the project</li>
  <li>ivy.xml: the project ivy file</li>
  <li>src\standalone\Main.java: the only class of the project</li>
</ul>
Take a look at the <b>ivy.xml</b> file:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="dependee"/&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="commons-lang" name="commons-lang" rev="2.0"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>

The ivy file declares only one dependency, that being the apache commons-lang library.<br class="xooki-br"/><h2>depender</h2>
The depender project is very simple as well. It declares only one dependency on the latest version of the dependee project, and it contains only one class, <tt>depending.Main</tt>, which does 2 things:
<ul>
  <li>gets the version of the standalone project by calling <tt>standalone.Main.getVersion()</tt></li>
  <li>transforms a string by calling <tt>standalone.Main.capitalizeWords(str)</tt></li>
</ul>
Take a look at the <tt>ivy.xml</tt> file:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="depender"/&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency name="dependee" rev="latest.integration" /&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>

<h1>settings</h1>
The Ivy settings are defined in two files located in the settings directory:
<ul>
  <li><tt>ivysettings.properties</tt>: a property file</li>
  <li><tt>ivysettings.xml</tt>: the file containing the settings</li>
</ul>

Let's have a look at the <tt>ivysettings.xml</tt> file:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>	&lt;properties file="${ivy.settings.dir}/ivysettings.properties"/&gt;<br class="xooki-br"/>	&lt;settings defaultResolver="libraries" /&gt;<br class="xooki-br"/>	&lt;caches defaultCacheDir="${ivy.settings.dir}/ivy-cache" /&gt;<br class="xooki-br"/>	&lt;resolvers&gt;<br class="xooki-br"/>		&lt;filesystem name="projects"&gt;<br class="xooki-br"/>			&lt;artifact pattern="${repository.dir}/[artifact]-[revision].[ext]" /&gt;<br class="xooki-br"/>			&lt;ivy pattern="${repository.dir}/[module]-[revision].xml" /&gt;<br class="xooki-br"/>		&lt;/filesystem&gt;<br class="xooki-br"/>		&lt;ibiblio name="libraries" m2compatible="true" usepoms="false" /&gt;<br class="xooki-br"/>	&lt;/resolvers&gt;<br class="xooki-br"/>	&lt;modules&gt;<br class="xooki-br"/>		&lt;module organisation="org.apache" name="dependee" resolver="projects"/&gt;<br class="xooki-br"/>	&lt;/modules&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
The file contains four main tags: properties, settings, resolvers and modules.<br class="xooki-br"/><h2>properties</h2>
This tag loads some properties for the Ivy process, just like Ant does.<br class="xooki-br"/><h2>settings</h2>
This tag initializes some parameters for the Ivy process. In this case, the directory that Ivy will use to cache artifacts will be in a sub directory called ivy-cache of the directory containing the <tt>ivysettings.xml</tt> file itself. <br class="xooki-br"/>The second parameter, tells Ivy to use a resolver named "libraries" as its default resolver. More information can be found in the <a href="settings.html">settings reference documentation</a>.<br class="xooki-br"/><h2>resolvers</h2>
This tag defines the resolvers to use. Here we have two resolvers defined: "projects" and "libraries".<br class="xooki-br"/>The filesystem resolver called "projects" is able to resolve the internal dependencies by locating them on the local filesystem. <br class="xooki-br"/>The ibiblio resolver called "libraries" is able to find dependencies on the maven 2 repository, but doesn't use maven poms.<br class="xooki-br"/><h2>modules</h2>
The modules tag allows you to configure which resolver should be used for which module. Here the setting tells Ivy to use the "projects" resolver for all modules having an organisation of <tt>org.apache</tt> and module name of <tt>dependee</tt>. This actually corresponds to only one module, but a regular expression could be used, or many other types of expressions (like glob expressions).<br class="xooki-br"/><br class="xooki-br"/>All other modules (i.e. all modules but org.apache#dependee), will use the default resolver ("libraries").<br class="xooki-br"/><h1>walkthrough</h1>
<div class="step">
<h2>step 1: preparation</h2>
Open a DOS or shell window, and go to the <tt>src/example/dependence</tt> directory.
</div>
<div class="step">
<h2>step 2: clean directory tree</h2>
On the prompt type: <tt>ant</tt>
This will clean up the entire project directory tree. You can do this each time you want to clean up this example.
</div>
<div class="step">
<h2>step 3: publication of dependee project</h2>
Go to <tt>dependee</tt> directory  and publish the project
<div class="shell"><pre>
[ivy@apache:/ivy/dependence/dependee]$ ant publish
Buildfile: /ivy/dependence/dependee/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: file = /ivy/dependence/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#dependee;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in libraries
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/2.0/commons-lang-2.0.jar ...
[ivy:retrieve] ...................... (165kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-lang#commons-lang;2.0!commons-lang.jar (468ms)
[ivy:retrieve] :: resolution report :: resolve 234ms :: artifacts dl 468ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   1   |   1   |   0   |   0   ||   1   |   1   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#dependee
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	1 artifacts copied, 0 already retrieved (165kB/16ms)

compile:
    [mkdir] Created dir: /ivy/dependence/dependee/build/classes
    [javac] Compiling 1 source file to /ivy/dependence/dependee/build/classes

jar:
[propertyfile] Creating new property file: /ivy/dependence/dependee/build/classes/version.properties
      [jar] Building jar: /ivy/dependence/dependee/build/dependee.jar

publish:
[ivy:publish] :: delivering :: org.apache#dependee;working@apache :: 1 :: release :: Thu Jan 10 14:34:36 CET 2013
[ivy:publish] 	delivering ivy file to /ivy/dependence/dependee/build/ivy.xml
[ivy:publish] :: publishing :: org.apache#dependee
[ivy:publish] 	published dependee to /ivy/dependence/settings/repository/dependee-1.jar
[ivy:publish] 	published ivy to /ivy/dependence/settings/repository/dependee-1.xml
     [echo] project dependee released with version 1

BUILD SUCCESSFUL
Total time: 2 seconds

</pre></div>
What we see here:
<ul>
  <li>the project depends on 1 library (1 artifact)</li>
  <li>the library was not in the Ivy cache and so was downloaded (1 downloaded)</li>
  <li>the project has been released under version number 1</li>
</ul>
</div>
As you can see, the call to the publish task has resulted in two main things:
<ul>
<li>the delivery of a resolved ivy file to <tt>build/ivy.xml</tt>.</li>
This has been done because by default, the publish task not only publishes artifacts, but also its ivy file. So it has looked to the path where the ivy file to publish should be, using the artifactspattern: <tt>${build.dir}/[artifact].[ext]</tt>. For an ivy file, this resolves to <tt>build/ivy.xml</tt>. Because this file does not exist, it automatically makes a call to the deliver task which delivers a resolved ivy file to this destination.<br class="xooki-br"/>
<li>the publication of artifact 'dependee' and its resolved ivy file to the repository.</li>
Both are just copies of the files found in the current project, or more precisely, those in the <tt>build</tt> directory. This is because the artifactspattern has been set to <tt>${build.dir}/[artifact].[ext]</tt>, so the dependee artifact is found at <tt>build/dependee.jar</tt> and the ivy file in <tt>build/ivy.xml</tt>. And because we have asked the publish task to publish them using the "projects" resolver, these files are copied to <tt>repository\dependee-1.jar</tt> and to <tt>repository\dependee-1.xml</tt>, respecting the artifact and ivy patterns of our settings (see above).
</ul>

<div class="step">
<h2>step 4: running the depender project</h2>
Go to directory depender and run <tt>ant</tt>
<div class="shell"><pre>
[ivy@apache:/ivy/dependence/depender]$ ant 
Buildfile: /ivy/dependence/depender/build.xml

clean:

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: file = /ivy/dependence/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#depender;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found org.apache#dependee;1 in projects
[ivy:retrieve] 	[1] org.apache#dependee;latest.integration
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in libraries
[ivy:retrieve] downloading /ivy/dependence/settings/repository/dependee-1.jar ...
[ivy:retrieve] .. (1kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] org.apache#dependee;1!dependee.jar (0ms)
[ivy:retrieve] :: resolution report :: resolve 140ms :: artifacts dl 16ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   2   |   1   |   1   |   0   ||   2   |   1   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#depender
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	2 artifacts copied, 0 already retrieved (167kB/16ms)

compile:
    [mkdir] Created dir: /ivy/dependence/depender/build/classes
    [javac] Compiling 1 source file to /ivy/dependence/depender/build/classes

run:
     [java] you are using version 1 of class standalone.Main
     [java] standard message : i am depending.Main and standalone.Main will do the job for me
     [java]     [standalone.Main] capitalizing string "i am depending.Main and standalone.Main will do the job for me" using org.apache.commons.lang.WordUtils
     [java] capitalized message : I Am Depending.main And Standalone.main Will Do The Job For Me

BUILD SUCCESSFUL
Total time: 1 second

</pre></div>
What we see here:
<ul>
  <li>the project depends on 2 libraries (2 artifacts)</li>
  <li>one of the libraries was in the cache because there was only 1 download (1 downloaded)</li>
  <li>Ivy retrieved version 1 of the project "dependee". The call to <tt>standalone.Main.getVersion()</tt> has returned 1. If you look in the <tt>depender/lib</tt> directory, you should see <tt>dependee-1.jar</tt> which is the version 1 artifact of the project "dependee"</li>
  <li>the call to <tt>standalone.Main.capitalizeWords(str)</tt> succeed, which means that the required library was in the classpath. If you look at the <tt>lib</tt> directory, you will see that the library <tt>commons-lang-2.0.jar</tt> was also retrieved. This library was declared as a dependency of the "dependee" project, so Ivy retrieves it (transitively) along with the dependee artifact.</li>
</ul>
</div>
<div class="step">
<h2>step 5: new version of dependee project</h2>
Like we did before in step 3, publish the dependee project again. This will result in a new version of the project being published.
<div class="shell"><pre>
[ivy@apache:/ivy/dependence/dependee]$ ant publish
Buildfile: /ivy/dependence/dependee/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: file = /ivy/dependence/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#dependee;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in libraries
[ivy:retrieve] :: resolution report :: resolve 62ms :: artifacts dl 16ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   1   |   0   |   0   |   0   ||   1   |   0   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#dependee
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	0 artifacts copied, 1 already retrieved (0kB/0ms)

compile:

jar:
[propertyfile] Updating property file: /ivy/dependence/dependee/build/classes/version.properties
      [jar] Building jar: /ivy/dependence/dependee/build/dependee.jar

publish:
   [delete] Deleting: /ivy/dependence/dependee/build/ivy.xml
[ivy:publish] :: delivering :: org.apache#dependee;working@apache :: 2 :: release :: Thu Jan 10 14:34:40 CET 2013
[ivy:publish] 	delivering ivy file to /ivy/dependence/dependee/build/ivy.xml
[ivy:publish] :: publishing :: org.apache#dependee
[ivy:publish] 	published dependee to /ivy/dependence/settings/repository/dependee-2.jar
[ivy:publish] 	published ivy to /ivy/dependence/settings/repository/dependee-2.xml
     [echo] project dependee released with version 2

BUILD SUCCESSFUL
Total time: 1 second

</pre></div>
Now if you look in your repository folder, you will find 2 versions of the dependee project.<br class="xooki-br"/>Let's look at it:
<div class="shell"><pre>I:\dependee>dir ..\settings\repository /w<br class="xooki-br"/><br class="xooki-br"/>[.]                [..]               dependee-1.jar   dependee-1.xml   dependee-2.jar   dependee-2.xml<br class="xooki-br"/><br class="xooki-br"/>I:\dependee></pre></div>
</div>
OK, now our repository contains two versions of the project <b>dependee</b>, so other projects can refer to either version.
<div class="step">
<h2>step 6: get the new version in <em>depender</em> project</h2>
What should we expect if we run the depender project again? It should: 
<ul>
  <li>retrieve version 2 as the latest.integration version of the dependee project</li>
  <li>display version 2 of dependee project</li>
</ul>
Let's try it!!
<div class="shell"><pre>
[ivy@apache:/ivy/dependence/depender]$ ant 
Buildfile: /ivy/dependence/depender/build.xml

clean:

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: file = /ivy/dependence/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#depender;working@apache
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	found org.apache#dependee;2 in projects
[ivy:retrieve] 	[2] org.apache#dependee;latest.integration
[ivy:retrieve] 	found commons-lang#commons-lang;2.0 in libraries
[ivy:retrieve] downloading /ivy/dependence/settings/repository/dependee-2.jar ...
[ivy:retrieve] .. (1kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] org.apache#dependee;2!dependee.jar (0ms)
[ivy:retrieve] :: resolution report :: resolve 140ms :: artifacts dl 0ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   2   |   1   |   1   |   0   ||   2   |   1   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#depender
[ivy:retrieve] 	confs: [default]
[ivy:retrieve] 	2 artifacts copied, 0 already retrieved (167kB/16ms)

compile:
    [mkdir] Created dir: /ivy/dependence/depender/build/classes
    [javac] Compiling 1 source file to /ivy/dependence/depender/build/classes

run:
     [java] you are using version 2 of class standalone.Main
     [java] standard message : i am depending.Main and standalone.Main will do the job for me
     [java]     [standalone.Main] capitalizing string "i am depending.Main and standalone.Main will do the job for me" using org.apache.commons.lang.WordUtils
     [java] capitalized message : I Am Depending.main And Standalone.main Will Do The Job For Me

BUILD SUCCESSFUL
Total time: 1 second

</pre></div>
OK, we got what we expected as the <tt>run</tt> target shows that we are using version 2 of the main class of the dependee project. If we take a look at the resolve target results, we see that one artifact has been downloaded to the ivy cache. In fact, this file is the same version 2 of the dependee project that is in the repository, but now all future retrievals will pull it from your ivy-cache directory.
</div>

	<hr/><div class='toc-title toc-title-3'>Using Ivy in multiple projects environment</div><br class="xooki-br"/>In the previous tutorial, you saw how to deal with dependencies between two simple projects.<br class="xooki-br"/><br class="xooki-br"/>This tutorial will guide you through the use of Ivy in a more complete environment. All of the code for this tutorial is available in the <tt>src/example/multi-project</tt> directory of the Ivy distribution.<br class="xooki-br"/><br class="xooki-br"/><h1>Context</h1>
Here is a 10000ft overview of the projects involved in this tutorial:
<ul>
<li>version</li> helps to identify module by a version
<li>list</li> gives a list of files in a directory (recursively)
<li>size</li> gives the total size of all files in a directory, or of a collection of files
<li>find</li> find files in a given dir or among a list of files which match a given name
<li>sizewhere</li> gives the total size of files matching a name in a directory
<li>console</li> give access to all other modules features through a simple console app
</ul>
For sure this is not aimed to demonstrate how to develop a complex app or give indication of advanced algorithm :-)<br class="xooki-br"/><br class="xooki-br"/>But this gives a simple understanding of how Ant+Ivy can be used to develop an application divided in multiple modules.<br class="xooki-br"/><br class="xooki-br"/>Now, here is how these modules relate to each other:<br class="xooki-br"/><center><a href="../samples/projects-dependencies-graph.jpg"><img src="samples/projects-dependencies-graph-small.jpg" alt="dependencies graph"/><br/><i>click to enlarge</i></a></center>

Modules in yellow are the modules described in this tutorial, and modules in blue are external dependencies (we will see how to generate this graph later in this tutorial).<br class="xooki-br"/><br class="xooki-br"/>As you can see, we have here a pretty interesting set of modules with dependencies between each other, each depending on the latest version of the others.<br class="xooki-br"/><br class="xooki-br"/><h1>The example files</h1>
The sources for this tutorial can be found in <tt>src/example/multi-project</tt> in the Ivy distribution. In this directory, you will find the following files:
<ul>
<li><a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/example/multi-project/build.xml">build.xml</a></li>This is a root build file which can be used to call targets on all modules, in the order of their dependencies (ensuring that a module is always built before any module depending on it, for instance)
<li>common
<ul>
<li><a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/example/multi-project/common/common.xml">common.xml</a></li> the common build file imported by all build.xml files for each project. This build defines the targets which can be used in all projects.
<li><a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/example/multi-project/common/build.properties">build.properties</a></li>some properties common to all projects
</ul>
</li>
<li>projects</li>
contains a directory per module, with each containing:
<ul>
<li>ivy.xml</li>Ivy file of the module, describing its dependencies upon other modules and/or external modules.<br class="xooki-br"/>Example:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info <br class="xooki-br"/>        organisation="org.apache.ivy.example"<br class="xooki-br"/>        module="find"<br class="xooki-br"/>        status="integration"/&gt;<br class="xooki-br"/>    &lt;configurations&gt;<br class="xooki-br"/>      &lt;conf name="core"/&gt;<br class="xooki-br"/>      &lt;conf name="standalone" extends="core"/&gt;<br class="xooki-br"/>    &lt;/configurations&gt;<br class="xooki-br"/>    &lt;publications&gt;<br class="xooki-br"/>      &lt;artifact name="find" type="jar" conf="core" /&gt;<br class="xooki-br"/>    &lt;/publications&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>      &lt;dependency name="version" rev="latest.integration" conf="core-&gt;default" /&gt;<br class="xooki-br"/>      &lt;dependency name="list" rev="latest.integration" conf="core" /&gt;<br class="xooki-br"/>      &lt;dependency org="commons-collections" name="commons-collections" rev="3.1" conf="core-&gt;default" /&gt;<br class="xooki-br"/>      &lt;dependency org="commons-cli" name="commons-cli" rev="1.0" conf="standalone-&gt;default" /&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
<li>build.xml</li>The build file of the project, which consists mainly of an import of the common build file and of a module specific properties file:
<pre>
&lt;project name="find" default="compile"&gt;<br class="xooki-br"/>	&lt;property file="build.properties"/&gt;<br class="xooki-br"/>	<br class="xooki-br"/>	&lt;import file="${common.dir}/common.xml"/&gt;<br class="xooki-br"/>&lt;/project&gt;
</pre>
<li>build.properties</li>Module specific properties + properties to find the common build file
<pre>
projects.dir = ${basedir}/..<br class="xooki-br"/>wkspace.dir = ${projects.dir}/..<br class="xooki-br"/>common.dir = ${wkspace.dir}/common
</pre>
<li>src</li> the source directory with all java sources
</ul>
</ul>

Note that this example doesn't demonstrate many good practices for software development in general, in particular you won't find any unit test in these samples, even if we think unit testing is very important. But this isn't the aim of this tutorial.<br class="xooki-br"/><br class="xooki-br"/>Now that you are a bit more familiar with the structure, let's have a look at the most important part of this example: the common build file. Indeed, as you have seen, all the module's build files only import the common build file, and define their dependencies in their ivy files (which you should begin to be familiar with).<br class="xooki-br"/><br class="xooki-br"/>So, here are some aspects of this common build file:<br class="xooki-br"/><h2>ivy settings</h2>
<pre>
&lt;!-- setup ivy default configuration with some custom info --&gt;<br class="xooki-br"/>&lt;property name="ivy.local.default.root" value="${repository.dir}/local"/&gt;<br class="xooki-br"/>&lt;property name="ivy.shared.default.root" value="${repository.dir}/shared"/&gt;<br class="xooki-br"/><br class="xooki-br"/>&lt;!-- here is how we would have configured ivy if we had our own ivysettings file<br class="xooki-br"/>&lt;ivy:settings file="${common.dir}/ivysettings.xml" id="ivy.instance" /&gt;<br class="xooki-br"/>--&gt;
</pre>

This declaration configures Ivy by only setting two properties: the location for the local repository and the location for the shared repository. It's the only settings done here, since Ivy is configured by default to work in a team environment (see <a href="tutorial/defaultconf.html">default settings tutorial</a> for details about this). For sure in a real environment, the shared repository location would rather be in a team shared directory (or in a more complex repository, again see the default settings tutorial to see how to use something really different).<br class="xooki-br"/>Commented out you can see how the settings would have been done if the default setting wasn't OK for our purpose.<br class="xooki-br"/><br class="xooki-br"/><h2>resolve dependencies</h2>
<pre>
&lt;target name="resolve" depends="clean-lib, load-ivy" description="--&gt; resolve and retrieve dependencies with ivy"&gt;<br class="xooki-br"/>    &lt;mkdir dir="${lib.dir}"/&gt; &lt;!-- not usually necessary, ivy creates the directory IF there are dependencies --&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;!-- the call to resolve is not mandatory, retrieve makes an implicit call if we don't --&gt;<br class="xooki-br"/>    &lt;ivy:resolve file="${ivy.file}"/&gt;<br class="xooki-br"/>    &lt;ivy:retrieve pattern="${lib.dir}/[artifact].[ext]" /&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
You should begin to be familiar with using Ivy this way. We call <i>resolve</i> explicitly to use the ivy file configured (the default would have been fine), and then call <i>retrieve</i> to copy resolved dependencies artifacts from the cache to a local lib directory. The pattern is also used to name the artifacts in the lib dir with their name and extension only (without revision), this is easier to use with an IDE, as the IDE configuration won't change when the artifacts version change.<br class="xooki-br"/><br class="xooki-br"/><h2>ivy-new-version</h2>
<pre>
&lt;target name="ivy-new-version" depends="load-ivy" unless="ivy.new.revision"&gt;<br class="xooki-br"/>    &lt;!-- default module version prefix value --&gt;<br class="xooki-br"/>    &lt;property name="module.version.prefix" value="${module.version.target}-dev-b" /&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;!-- asks Ivy for an available version number --&gt;<br class="xooki-br"/>    &lt;ivy:info file="${ivy.file}" /&gt;<br class="xooki-br"/>    &lt;ivy:buildnumber <br class="xooki-br"/>        organisation="${ivy.organisation}" module="${ivy.module}" <br class="xooki-br"/>        revision="${module.version.prefix}" defaultBuildNumber="1" revSep=""/&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
This target is used to ask Ivy to find a new version for a module. To get details about the module we are dealing with, we pull information out of the ivy file by using the ivy:info task. Then the <a href="use/buildnumber.html">buildnumber</a> task is used to get a new revision, based on a prefix we set with a property, by default it will be 1.0-dev-b (have a look at the default value for <tt>module.version.target</tt> in the <tt>common/build.properties</tt> file). Each module built by this common build file could easily override this by either setting a different <tt>module.version.target</tt> in its module specific <tt>build.properties</tt>, or even overriding <tt>module.version.prefix</tt>. To get the new revision, Ivy scans the repository to find the latest available version with the given prefix, and then increments this version by 1.<br class="xooki-br"/><br class="xooki-br"/><h2>publish</h2>
<pre>
&lt;target name="publish" depends="clean-build, jar" description="--&gt; publish this project in the ivy repository"&gt;<br class="xooki-br"/>    &lt;ivy:publish artifactspattern="${build.dir}/[artifact].[ext]" <br class="xooki-br"/>                       resolver="shared"<br class="xooki-br"/>                       pubrevision="${version}" <br class="xooki-br"/>                       status="release"<br class="xooki-br"/>    /&gt;<br class="xooki-br"/>    &lt;echo message="project ${ant.project.name} released with version ${version}" /&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
This target publishes the module to the shared repository, with the revision found in the version property, which is set by other targets (based on ivy-new-version we have seen above). It can be used when a module reaches a specific milestone, or whenever you want the team to benefit from a new version of the module.<br class="xooki-br"/><h2>publish-local</h2>
<pre>
&lt;target name="publish-local" depends="local-version, jar" description="--&gt; publish this project in the local ivy repository"&gt;<br class="xooki-br"/>    &lt;ivy:publish artifactspattern="${build.dir}/[artifact].[ext]" <br class="xooki-br"/>                    resolver="local"<br class="xooki-br"/>                    pubrevision="${version}"<br class="xooki-br"/>                    pubdate="${now}"<br class="xooki-br"/>                    status="integration"<br class="xooki-br"/>                    forcedeliver="true"<br class="xooki-br"/>    /&gt;<br class="xooki-br"/>    &lt;echo message="project ${ant.project.name} published locally with version ${version}" /&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
This is very similar to the publish task, except that this publishes the revision to the local repository, which is used only in your environment and doesn't disturb the team. When you change something in a module and want to benefit from the change in another one, you can simply call <tt>publish-local</tt> in this module, and then your next build of the other module will automatically get this local version.<br class="xooki-br"/><h2>clean-local</h2>
<pre>
&lt;target name="clean-local" description="--&gt; cleans the local repository for the current module"&gt;<br class="xooki-br"/>   &lt;delete dir="${ivy.local.default.root}/${ant.project.name}"/&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
This target is used when you don't want to use your local version of a module anymore. For example, when you release a new version to the whole team, or discard your local changes and want to take advantage of a new version from the team.<br class="xooki-br"/><h2>report</h2>
<pre>
&lt;target name="report" depends="resolve" description="--&gt; generates a report of dependencies"&gt;<br class="xooki-br"/>    &lt;ivy:report todir="${build.dir}"/&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
Generates both an html report and a graphml report.<br class="xooki-br"/><br class="xooki-br"/>For example, to generate a graph like the one shown at the beginning of this tutorial, you just have to follow the instructions given <a href="yed.html">here</a> with the graphml file you will find in <pre>projects/console/build/</pre> after having called report in the console project, and that's it, you have a clear overview of all your app dependencies!<br class="xooki-br"/><br class="xooki-br"/><h1>Playing with the projects</h1>
You can play with this tutorial by using regular Ant commands. Begin in the base directory of the tutorial (src/example/multi-project), and run ant -p:
<div class="shell"><pre>
[ivy@apache:/ivy/multi-project]$ ant -p
Buildfile: /ivy/multi-project/build.xml

Main targets:

 clean        clean tutorial: delete repository, ivy cache, and all projects
 clean-all    clean all projects
 publish-all  compile, jar and publish all projects in the right order

</pre></div>

This gives you an idea of what you can do here. To make sure you have at least one version of all your modules published in your repository (required to build modules having dependencies on the others), you can run <tt>ant publish-all</tt> (example log <a href="log/multi-project-general-publishall.txt">here</a>).<br class="xooki-br"/><br class="xooki-br"/>You will see that Ivy calls the publish target on all the modules, following the order of the dependencies, so that a dependee is always built and published before its depender. Feel free to make changes in the source code of a module (changing a method name for instance) and in the module using the method, then call publish-all to see how the change in the dependee is compiled first, published, and then available to the depender which can compile successfully.<br class="xooki-br"/><br class="xooki-br"/>Then you can go in one of the example project directories (like projects/find for instance), and run <tt>ant -p</tt>:
<div class="shell"><pre>
[ivy@apache:/ivy/multi-project/projects/find]$ ant -p
Buildfile: /ivy/multi-project/projects/find/build.xml

Main targets:

 clean          --> clean the project
 clean-build    --> clean the project built files
 clean-lib      --> clean the project libraries directory (dependencies)
 clean-local    --> cleans the local repository for the current module
 compile        --> compile the project
 jar            --> make a jar file for this project
 publish        --> publish this project in the ivy repository
 publish-local  --> publish this project in the local ivy repository
 report         --> generates a report of dependencies
 resolve        --> resolve and retrieve dependencies with ivy
 run            --> compile and run the project
Default target: compile

</pre></div>

You can see the targets available, thanks to the import of the <tt>common.xml</tt> build file. Play with the project by calling resolve, and publish, and see what happens when you do the same in other projects. An interesting thing to do for instance, is to change the dependencies of a project. If the module version now depends on a new commons library, you will see that all other projects depending on that version will get this library as part of their transitive dependencies once the new revision of the version project is published. Very easy! And if a project introduces a change with which the depender isn't compatible with yet, you can easily change the dependency in the depender to move from <tt>latest.integration</tt> to a fixed version with which the depender is compatible (probably the latest before the change). Keeping your modules under control is now very easy!<br class="xooki-br"/><br class="xooki-br"/>By now, you should be pretty familiar with multi-project development with Ivy. We hope you will appreciate its power and flexibility! And these tutorials are only the beginning of your journey with Ivy, browse the <a href="reference.html">reference documentation</a> to learn more about the features, subscribe to the mailing lists to share your experience and ask questions with the community, browse the source code, open jira issues, submit patches, join in and help make Ivy the best of dependency management tools!<hr/><div class='toc-title toc-title-3'>Using Ivy Module Configurations</div><br class="xooki-br"/>This tutorial introduces the use of module configurations in ivy files. Ivy module configurations are indeed a very important concept. Someone even told me one day that using Ivy without using configurations is like eating a good cheese without touching the glass of Chateau Margaux 1976 you have just poured :-)<br class="xooki-br"/><br class="xooki-br"/>More seriously, configurations in Ivy can be better understood as views on your module, and you will see how they can be used effectively here.<br class="xooki-br"/><br class="xooki-br"/>Reference documentation on configurations can be found <a href="../terminology.html">here</a> and <a href="../ivyfile/configurations.html">here</a>.<br class="xooki-br"/><h1>Introduction</h1>
Source code is available in <tt>src/example/configurations/multi-projects</tt>.<br class="xooki-br"/>We have two projects :<br class="xooki-br"/>  - filter-framework is a library that defines an api to filter String arrays and two implementations of this api.<br class="xooki-br"/>  - myapp is a very small app that uses filter-framework.<br class="xooki-br"/>  <br class="xooki-br"/>The filter-framework library project produces 3 artifacts:<br class="xooki-br"/>  - the api jar,<br class="xooki-br"/>  - an implementation jar with no external dependencies,<br class="xooki-br"/>  - a second implementation jar that needs commons-collections to perform.<br class="xooki-br"/><br class="xooki-br"/>The application only needs the api jar to compile and can use either of the two implementations at runtime.<br class="xooki-br"/><br class="xooki-br"/><h1>The library project</h1>
The first project we'll look at in this tutorial is filter-framework. In order to have a fine-grained artifacts publication definition, we defined several configurations, each which maps to a set of artifacts that other projects can make use of.<br class="xooki-br"/><h2>The ivy.xml file</h2>

<div class="ivy-file">
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="filter-framework"/&gt;<br class="xooki-br"/>    &lt;configurations&gt;<br class="xooki-br"/>    	&lt;conf name="api"  description="only provide filter framework API"/&gt;<br class="xooki-br"/>    	&lt;conf name="homemade-impl" extends="api" description="provide a home made implementation of our api"/&gt;<br class="xooki-br"/>    	&lt;conf name="cc-impl" extends="api" description="provide an implementation that use apache common collection framework"/&gt;<br class="xooki-br"/>    	&lt;conf name="test" extends="cc-impl" visibility="private" description="for testing our framework"/&gt;<br class="xooki-br"/>    &lt;/configurations&gt;<br class="xooki-br"/>    &lt;publications&gt;<br class="xooki-br"/>    	&lt;artifact name="filter-api" type="jar"  conf="api" ext="jar"/&gt;<br class="xooki-br"/>    	&lt;artifact name="filter-hmimpl" type="jar"  conf="homemade-impl" ext="jar"/&gt;<br class="xooki-br"/>    	&lt;artifact name="filter-ccimpl" type="jar"  conf="cc-impl" ext="jar"/&gt;    	<br class="xooki-br"/>    &lt;/publications&gt;<br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="commons-collections" name="commons-collections" rev="3.1" conf="cc-impl-&gt;default"/&gt;<br class="xooki-br"/>        &lt;dependency org="junit" name="junit" rev="3.8" conf="test-&gt;default"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre> 
</div>
<h2>Explanation</h2>
As you can see, we defined 4 configurations, with 3 being public and 1 private. (the  junit dependency for testing).<br class="xooki-br"/>The 2 implementation configurations, <b>homemade-impl</b> and <b>cc-impl</b> extend the <b>api</b> configuration so that all artifacts defined in <b>api</b> will also be part of the extending configuration.<br class="xooki-br"/><br class="xooki-br"/>In the publications tag, we defined the artifacts we produce (jars in this case) and we assign them to a configuration. When others use our library they will have a flexible way to ask for what they need.<br class="xooki-br"/><br class="xooki-br"/><h2>See it in action</h2>
The filter-framework project is built using Ant. Open a shell in the root directory of the project and type <tt>ant</tt>.
<div class="shell"><pre>
[ivy@apache:/ivy/configurations/multi-projects/filter-framework]$ ant 
Buildfile: /ivy/configurations/multi-projects/filter-framework/build.xml

clean:

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: url = jar:file:///home/ivy/ivy.jar!/org/apache/ivy/core/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#filter-framework;working@apache
[ivy:retrieve] 	confs: [api, homemade-impl, cc-impl, test]
[ivy:retrieve] 	found commons-collections#commons-collections;3.1 in public
[ivy:retrieve] 	found junit#junit;3.8 in public
[ivy:retrieve] downloading http://repo1.maven.org/maven2/commons-collections/commons-collections/3.1/commons-collections-3.1.jar ...
[ivy:retrieve] ..................................... (546kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] commons-collections#commons-collections;3.1!commons-collections.jar (1341ms)
[ivy:retrieve] downloading http://repo1.maven.org/maven2/junit/junit/3.8/junit-3.8.jar ...
[ivy:retrieve] .......... (118kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] junit#junit;3.8!junit.jar (406ms)
[ivy:retrieve] :: resolution report :: resolve 842ms :: artifacts dl 1779ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|        api       |   0   |   0   |   0   |   0   ||   0   |   0   |
	|   homemade-impl  |   0   |   0   |   0   |   0   ||   0   |   0   |
	|      cc-impl     |   1   |   1   |   1   |   0   ||   1   |   1   |
	|       test       |   2   |   2   |   2   |   0   ||   2   |   2   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#filter-framework
[ivy:retrieve] 	confs: [api, homemade-impl, cc-impl, test]
[ivy:retrieve] 	3 artifacts copied, 0 already retrieved (1211kB/62ms)

build:
    [mkdir] Created dir: /ivy/configurations/multi-projects/filter-framework/build
    [mkdir] Created dir: /ivy/configurations/multi-projects/filter-framework/distrib
    [javac] Compiling 4 source files to /ivy/configurations/multi-projects/filter-framework/build
    [javac] Note: Some input files use unchecked or unsafe operations.
    [javac] Note: Recompile with -Xlint:unchecked for details.
      [jar] Building jar: /ivy/configurations/multi-projects/filter-framework/distrib/filter-api.jar
      [jar] Building jar: /ivy/configurations/multi-projects/filter-framework/distrib/filter-hmimpl.jar
      [jar] Building jar: /ivy/configurations/multi-projects/filter-framework/distrib/filter-ccimpl.jar

test:
    [mkdir] Created dir: /ivy/configurations/multi-projects/filter-framework/build/test-report
    [mkdir] Created dir: /ivy/configurations/multi-projects/filter-framework/build/test-classes
    [javac] /ivy/configurations/multi-projects/filter-framework/build.xml:82: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds
    [javac] Compiling 3 source files to /ivy/configurations/multi-projects/filter-framework/build/test-classes
    [junit] Running filter.ccimpl.CCFilterTest
    [junit] Tests run: 5, Failures: 0, Errors: 0, Time elapsed: 0,063 sec
    [junit] Running filter.hmimpl.HMFilterTest
    [junit] Tests run: 5, Failures: 0, Errors: 0, Time elapsed: 0,063 sec

publish:
[ivy:publish] :: delivering :: org.apache#filter-framework;working@apache :: 1.3 :: release :: Thu Jan 10 14:34:51 CET 2013
[ivy:publish] 	delivering ivy file to /ivy/configurations/multi-projects/filter-framework/distrib/ivy.xml
[ivy:publish] :: publishing :: org.apache#filter-framework
[ivy:publish] 	published filter-api to /home/ivy/.ivy2/local/org.apache/filter-framework/1.3.part/jars/filter-api.jar
[ivy:publish] 	published filter-hmimpl to /home/ivy/.ivy2/local/org.apache/filter-framework/1.3.part/jars/filter-hmimpl.jar
[ivy:publish] 	published filter-ccimpl to /home/ivy/.ivy2/local/org.apache/filter-framework/1.3.part/jars/filter-ccimpl.jar
[ivy:publish] 	published ivy to /home/ivy/.ivy2/local/org.apache/filter-framework/1.3.part/ivys/ivy.xml
[ivy:publish] 	publish commited: moved /home/ivy/.ivy2/local/org.apache/filter-framework/1.3.part 
[ivy:publish] 		to /home/ivy/.ivy2/local/org.apache/filter-framework/1.3
     [echo] project filter-framework released with version 1.3

BUILD SUCCESSFUL
Total time: 8 seconds

</pre></div>
The Ant default target is publish. This target uses Ivy to publish our library binaries to a local repository. Since we do not specify any repository path, the default one is used. (<tt>${home.dir}/.ivy2/local/org.apache/filter-framework/</tt>) At this point, we are ready to use our library.<br class="xooki-br"/><br class="xooki-br"/><h1>The application project</h1>

Now that we have shipped (published) our fantastic filter library, we want to use it! The tutorial comes with a sample application called myapp.<br class="xooki-br"/><h2>The <tt>ivy.xml</tt> file</h2>

<div class="ivy-file">
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>    &lt;info organisation="org.apache" module="myapp"/&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;configurations&gt;<br class="xooki-br"/>       	&lt;conf name="build" visibility="private" description="compilation only need api jar" /&gt;<br class="xooki-br"/>    	&lt;conf name="noexternaljar" description="use only company jar" /&gt;<br class="xooki-br"/>    	&lt;conf name="withexternaljar" description="use company jar and third party jars" /&gt;    <br class="xooki-br"/>    &lt;/configurations&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;dependencies&gt;<br class="xooki-br"/>        &lt;dependency org="org.apache" name="filter-framework" rev="latest.integration" conf="build-&gt;api; noexternaljar-&gt;homemade-impl; withexternaljar-&gt;cc-impl"/&gt;<br class="xooki-br"/>    &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre> 
</div>
<h2>Explanation</h2>
We create 3 configurations that define the different ways we want to use the application. The <b>build</b> configuration defines the compile-time dependencies, and thus only needs the api conf from the filter-framework project. The other two configurations define runtime dependencies. One will only use our "home-made" jar, and the other will use an external jar.<br class="xooki-br"/><br class="xooki-br"/>We also defined a dependency on our previously built library. In this dependency, we use configuration mappings to match ours with the dependency's configurations. You can find more information about configuration mapping <a href="../ivyfile/configurations.html">here</a><br class="xooki-br"/><ol>
  <li><b>build->api</b> : here we tell Ivy that our <b>build</b> configuration depends on the <b>api</b> configuration of the dependency</li>
  <li><b>noexternaljar->homemade-impl</b> : here we tell Ivy that our <b>noexternaljar</b> configuration depends on the <b>homemade-impl</b> configuration of the dependency.</li>
  <li><b>withexternaljar->cc-impl</b> : here we tell Ivy that our <b>withexternaljar</b> configuration depends on the <b>cc-impl</b> configuration of the dependency</li>
</ol>
Note that we never declare any of the dependency's artifacts we need in each configuration: it's the dependency module's ivy file which declares the published artifacts and which should be used in each configuration.<br class="xooki-br"/><br class="xooki-br"/>In the Ant <tt>build.xml</tt> file, we defined a 'resolve' target as follow:<br class="xooki-br"/>
<pre>
&lt;target name="resolve" description="--&gt; retreive dependencies with ivy"&gt;<br class="xooki-br"/>    &lt;ivy:retrieve pattern="${ivy.lib.dir}/[conf]/[artifact].[ext]"/&gt;<br class="xooki-br"/>&lt;/target&gt;    
</pre> 

When we call this target, Ivy will do a resolve using our <tt>ivy.xml</tt> file in the root folder and then retrieve all the artifacts. The artifacts retrieved are kept in separate folders according to the configurations they belong to. Here is how your lib directory should look after a call to this target:
<div class="shell"><pre>
 Repertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib<br class="xooki-br"/><br class="xooki-br"/>01/24/2006  11:19 AM    <REP>          build<br class="xooki-br"/>01/24/2006  11:19 AM    <REP>          noexternaljar<br class="xooki-br"/>01/24/2006  11:19 AM    <REP>          withexternaljar<br class="xooki-br"/>               0 fichier(s)                0 octets<br class="xooki-br"/><br class="xooki-br"/> Repertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib\build<br class="xooki-br"/><br class="xooki-br"/>01/24/2006  10:53 AM             1,174 filter-api.jar<br class="xooki-br"/>               1 fichier(s)            1,174 octets<br class="xooki-br"/><br class="xooki-br"/> Repertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib\noexternaljar<br class="xooki-br"/><br class="xooki-br"/>01/24/2006  10:53 AM             1,174 filter-api.jar<br class="xooki-br"/>01/24/2006  10:53 AM             1,030 filter-hmimpl.jar<br class="xooki-br"/>               2 fichier(s)            2,204 octets<br class="xooki-br"/><br class="xooki-br"/> Repertoire de D:\ivy\src\example\configurations\multi-projects\myapp\lib\withexternaljar<br class="xooki-br"/>01/24/2006  10:53 AM           559,366 commons-collections.jar<br class="xooki-br"/>01/24/2006  10:53 AM             1,174 filter-api.jar<br class="xooki-br"/>01/24/2006  10:53 AM             1,626 filter-ccimpl.jar<br class="xooki-br"/>               3 fichier(s)          562,166 octets
</pre></div>
As you can see, for each configuration we have now a set of jars.<br class="xooki-br"/><br class="xooki-br"/>Let's try to launch our app.<br class="xooki-br"/><br class="xooki-br"/><h2>See it in action</h2>
Use Ant to run the application. The default Ant target is <i>run-cc</i> and will launch the application using the Apache commons-collections implementation.
<div class="shell"><pre>
[ivy@apache:/ivy/configurations/multi-projects/myapp]$ ant 
Buildfile: /ivy/configurations/multi-projects/myapp/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: url = jar:file:///home/ivy/ivy.jar!/org/apache/ivy/core/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#myapp;working@apache
[ivy:retrieve] 	confs: [build, noexternaljar, withexternaljar]
[ivy:retrieve] 	found org.apache#filter-framework;1.3 in local
[ivy:retrieve] 	[1.3] org.apache#filter-framework;latest.integration
[ivy:retrieve] 	found commons-collections#commons-collections;3.1 in public
[ivy:retrieve] downloading /home/ivy/.ivy2/local/org.apache/filter-framework/1.3/jars/filter-ccimpl.jar ...
[ivy:retrieve] .. (1kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] org.apache#filter-framework;1.3!filter-ccimpl.jar (0ms)
[ivy:retrieve] downloading /home/ivy/.ivy2/local/org.apache/filter-framework/1.3/jars/filter-hmimpl.jar ...
[ivy:retrieve] .. (1kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] org.apache#filter-framework;1.3!filter-hmimpl.jar (62ms)
[ivy:retrieve] downloading /home/ivy/.ivy2/local/org.apache/filter-framework/1.3/jars/filter-api.jar ...
[ivy:retrieve] .. (1kB)
[ivy:retrieve] .. (0kB)
[ivy:retrieve] 	[SUCCESSFUL ] org.apache#filter-framework;1.3!filter-api.jar (16ms)
[ivy:retrieve] :: resolution report :: resolve 172ms :: artifacts dl 78ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|       build      |   1   |   1   |   1   |   0   ||   1   |   1   |
	|   noexternaljar  |   1   |   1   |   1   |   0   ||   2   |   2   |
	|  withexternaljar |   2   |   1   |   1   |   0   ||   3   |   2   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#myapp
[ivy:retrieve] 	confs: [build, noexternaljar, withexternaljar]
[ivy:retrieve] 	6 artifacts copied, 0 already retrieved (552kB/140ms)

build:
    [mkdir] Created dir: /ivy/configurations/multi-projects/myapp/build
    [javac] Compiling 1 source file to /ivy/configurations/multi-projects/myapp/build

run-cc:
     [java] Filtering with:class filter.ccimpl.CCFilter
     [java] Result :[two, tree]

BUILD SUCCESSFUL
Total time: 2 seconds

</pre></div>
Launching the application using the homemade implementation is also straightforward.<br class="xooki-br"/>type <tt>ant run-hm</tt>

<div class="shell"><pre>
[ivy@apache:/ivy/configurations/multi-projects/myapp]$ ant run-hm
Buildfile: /ivy/configurations/multi-projects/myapp/build.xml

resolve:
[ivy:retrieve] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:retrieve] :: loading settings :: url = jar:file:///home/ivy/ivy.jar!/org/apache/ivy/core/settings/ivysettings.xml
[ivy:retrieve] :: resolving dependencies :: org.apache#myapp;working@apache
[ivy:retrieve] 	confs: [build, noexternaljar, withexternaljar]
[ivy:retrieve] 	found org.apache#filter-framework;1.3 in local
[ivy:retrieve] 	[1.3] org.apache#filter-framework;latest.integration
[ivy:retrieve] 	found commons-collections#commons-collections;3.1 in public
[ivy:retrieve] :: resolution report :: resolve 109ms :: artifacts dl 16ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|       build      |   1   |   1   |   0   |   0   ||   1   |   0   |
	|   noexternaljar  |   1   |   1   |   0   |   0   ||   2   |   0   |
	|  withexternaljar |   2   |   1   |   0   |   0   ||   3   |   0   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: org.apache#myapp
[ivy:retrieve] 	confs: [build, noexternaljar, withexternaljar]
[ivy:retrieve] 	0 artifacts copied, 6 already retrieved (0kB/15ms)

build:

run-hm:
     [java] Filtering with:class filter.hmimpl.HMFilter
     [java] Result :[two, tree]

BUILD SUCCESSFUL
Total time: 1 second
</pre></div>
Nice! We got the same result, but we can see that the implementation classes are different.<br class="xooki-br"/><br class="xooki-br"/><h1>Conclusion</h1>
<b>You should use configurations as often as possible.</b> Configurations are a very important concept in Ivy. They allow you to group artifacts and give the group a meaning. When you write ivy files for projects that are intended for use by others, use configurations to allow people to get only what they need, without having to specify them one by one in their own dependency list. <br class="xooki-br"/><hr/><div class='toc-title toc-title-3'>Building a repository</div><br class="xooki-br"/>The <a href="use/install.html">install</a> Ant task lets you copy a module or a set of modules from one repository to another. This is very useful to build and maintain an enterprise or team repository. If you don't want to give access to the public maven 2 repository to the developers on your team (to keep control over which modules are in use in your company or your team for instance), it can sometimes become tiresome to answer the developers request to add new modules or new versions by hand.<br class="xooki-br"/><br class="xooki-br"/>Fortunately the <a href="use/install.html">install</a> task is here to help: you can use specific settings for your repository maintenance build which will be used to maintain your target enterprise repository. These settings will point to another repository (for instance the maven 2 public repository) so that you will just have to ask Ivy to install the modules you want with a simple command line.<br class="xooki-br"/><br class="xooki-br"/>To demonstrate this, we will first use a basic ivy settings file to show how it works, and then we will use the advanced <a href="settings/namespaces.html">namespaces</a> features to demonstrate how to deal with naming mismatches between the source and target repository.<br class="xooki-br"/><br class="xooki-br"/><h1>The project used</h1>
The project that we will use is pretty simple. It is composed of an Ant build file, and two ivy settings files.<br class="xooki-br"/><br class="xooki-br"/>Here are the public targets that we will use: 
<div class="shell"><pre>
Z:\ivy-repository>ant -p<br class="xooki-br"/>Buildfile: build.xml<br class="xooki-br"/><br class="xooki-br"/>Main targets:<br class="xooki-br"/><br class="xooki-br"/> clean-cache            --> clean the cache<br class="xooki-br"/> clean-repo             --> clean the destination repository<br class="xooki-br"/> maven2                 --> install module from maven 2 repository<br class="xooki-br"/> maven2-deps            --> install module from maven 2 repository with dependencies<br class="xooki-br"/> maven2-namespace       --> install module from maven 2 using namespaces<br class="xooki-br"/> maven2-namespace-deps  --> install module with dependencies from maven2 repo using namespaces<br class="xooki-br"/>Default target: basic
</pre></div>
<br/><br/>
This project is accessible in the <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/example/build-a-ivy-repository">src/example/build-a-ivy-repository</a><br class="xooki-br"/><br class="xooki-br"/>Next steps:<br class="xooki-br"/><a href="tutorial/build-repository/basic.html">Basic repository copy</a><br class="xooki-br"/><a href="tutorial/build-repository/advanced.html">Using namespaces</a><br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>Basic repository copy</div><br class="xooki-br"/>In this first step, we use the <a href="use/install.html">install</a> Ant task to install modules from the maven 2 repository to a file system based repository. We first install a module by itself, excluding dependencies, then again with its dependencies.<br class="xooki-br"/><br class="xooki-br"/><h1>Basic: ivysettings.xml file used</h1>
The ivy settings file that we will use is very simple here. It defines two resolvers, <i>libraries</i> and <i>my-repository</i>. The first one is used as the source, the second one as the destination. In a typical setup, the second one would be configured using an <a href="settings/include.html">include</a> that included an existing settings file used by the development team.<br class="xooki-br"/>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>	&lt;settings	defaultResolver="libraries"<br class="xooki-br"/>			defaultConflictManager="all" /&gt;		&lt;!-- in order to get all revisions without any eviction --&gt;<br class="xooki-br"/>	&lt;caches defaultCacheDir="${ivy.cache.dir}/no-namespace" /&gt;<br class="xooki-br"/>	&lt;resolvers&gt;<br class="xooki-br"/>		&lt;ibiblio name="libraries" m2compatible="true" /&gt;<br class="xooki-br"/>  		&lt;filesystem name="my-repository"&gt;<br class="xooki-br"/>  			&lt;ivy pattern="${dest.repo.dir}/no-namespace/[organisation]/[module]/ivys/ivy-[revision].xml"/&gt;<br class="xooki-br"/>  			&lt;artifact pattern="${dest.repo.dir}/no-namespace/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>  		&lt;/filesystem&gt;<br class="xooki-br"/>	&lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

<h1>install a simple module with no dependencies</h1>
Let's have a look at the <em>maven2</em> target.
<pre>
    &lt;target name="maven2" depends="init-ivy"<br class="xooki-br"/>    	description="--&gt; install module from maven 2 repository"&gt;<br class="xooki-br"/>    	&lt;ivy:install settingsRef="basic.settings" <br class="xooki-br"/>    		organisation="commons-lang" module="commons-lang" revision="1.0" <br class="xooki-br"/>    		from="${from.resolver}" to="${to.resolver}" /&gt;<br class="xooki-br"/>    &lt;/target&gt;
</pre>
Pretty simple, we call the [[ant:install] task with the settings we have loaded using <a href="use/settings.html">ivy:settings</a> as usual. We then set the source and destination repositories using the <i>from</i> and <i>to</i> attributes. We used Ant properties for these values here, which helps ease the maintenance of the script, but it's basically the name of our resolvers: 'libraries' for the source and 'my-repository' for the destination.<br class="xooki-br"/><br class="xooki-br"/>Here is the Ant call output :
<div class="shell"><pre>
[ivy@apache:/ivy/build-a-ivy-repository]$ ant maven2
Buildfile: /ivy/build-a-ivy-repository/build.xml

load-ivy:

init-ivy:

maven2:
[ivy:install] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:install] :: loading settings :: file = /ivy/build-a-ivy-repository/settings/ivysettings-basic.xml
[ivy:install] :: installing commons-lang#commons-lang;1.0 ::
[ivy:install] :: resolving dependencies ::
[ivy:install] 	found commons-lang#commons-lang;1.0 in libraries
[ivy:install] :: downloading artifacts to cache ::
[ivy:install] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/1.0/commons-lang-1.0-javadoc.jar ...
[ivy:install] ...................... (170kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] commons-lang#commons-lang;1.0!commons-lang.jar(javadoc) (624ms)
[ivy:install] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/1.0/commons-lang-1.0.jar ...
[ivy:install] ....... (62kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] commons-lang#commons-lang;1.0!commons-lang.jar (328ms)
[ivy:install] :: installing in my-repository ::
[ivy:install] 	published commons-lang to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/javadocs/commons-lang-1.0.jar
[ivy:install] 	published commons-lang to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/jars/commons-lang-1.0.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/ivys/ivy-1.0.xml
[ivy:install] :: install resolution report ::
[ivy:install] :: resolution report :: resolve 0ms :: artifacts dl 952ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   1   |   1   |   1   |   0   ||   2   |   2   |
	---------------------------------------------------------------------

BUILD SUCCESSFUL
Total time: 2 seconds

</pre></div>
The trace tells us that the module definition was found using the "libraries" resolver and that the corresponding artifact was downloaded from the maven 2 repository. Then both were published to the filesystem repository (my-repository).<br class="xooki-br"/><br class="xooki-br"/>Let's have a look at our repository :
<div class="shell"><pre>
[ivy@apache:/]$ find /ivy/build-a-ivy-repository/myrepository/no-namespace -type f -print
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/ivys/ivy-1.0.xml
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/ivys/ivy-1.0.xml.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/ivys/ivy-1.0.xml.sha1
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/jars/commons-lang-1.0.jar
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/jars/commons-lang-1.0.jar.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/jars/commons-lang-1.0.jar.sha1
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/javadocs/commons-lang-1.0.jar
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/javadocs/commons-lang-1.0.jar.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/commons-lang/commons-lang/javadocs/commons-lang-1.0.jar.sha1

</div>
We can see that we now have the commons-lang module version 1.0 in our repository, with a generated ivy.xml file, its jar, and all the md5 and sha1 checksums for future consistency checks when developers use this repository to resolve modules.<br class="xooki-br"/><br class="xooki-br"/><h1>install a module with dependencies</h1>
Now let's say that we want to be sure all the dependencies of the module we install are available in our repository after the installation. We could either install without dependencies on a staging repository and check the missing dependencies (more control), or use transitive dependency management and ask Ivy to install everything for us (much simpler).<br class="xooki-br"/><br class="xooki-br"/>The <tt>maven2-deps</tt> target is very similar to the one described above, except that we explicitly ask for transitive installation.
<pre>
    &lt;target name="maven2-deps" depends="init-ivy" <br class="xooki-br"/>    	description="--&gt; install module from maven 2 repository with dependencies"&gt;<br class="xooki-br"/>    	&lt;ivy:install settingsRef="basic.settings" <br class="xooki-br"/>    		organisation="org.hibernate" module="hibernate" revision="3.2.5.ga" <br class="xooki-br"/>    		from="${from.resolver}" to="${to.resolver}" transitive="true" /&gt;<br class="xooki-br"/>    &lt;/target&gt;
</pre>

If you call this target, you will see that Ivy installs not only the hibernate module but also its dependencies:
<div class="shell"><pre>
[ivy@apache:/ivy/build-a-ivy-repository]$ ant maven2-deps
Buildfile: /ivy/build-a-ivy-repository/build.xml

load-ivy:

init-ivy:

maven2-deps:
[ivy:install] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:install] :: loading settings :: file = /ivy/build-a-ivy-repository/settings/ivysettings-basic.xml
[ivy:install] :: installing org.hibernate#hibernate;3.2.5.ga ::
[ivy:install] :: resolving dependencies ::
[ivy:install] 	found org.hibernate#hibernate;3.2.5.ga in libraries
[ivy:install] 	found net.sf.ehcache#ehcache;1.2.3 in libraries
[ivy:install] 	found commons-logging#commons-logging;1.0.4 in libraries
[ivy:install] 	found commons-collections#commons-collections;2.1 in libraries
[ivy:install] 	found javax.transaction#jta;1.0.1B in libraries
[ivy:install] 	found asm#asm-attrs;1.5.3 in libraries
[ivy:install] 	found dom4j#dom4j;1.6.1 in libraries
[ivy:install] 	found antlr#antlr;2.7.6 in libraries
[ivy:install] 	found cglib#cglib;2.1_3 in libraries
[ivy:install] 	found asm#asm;1.5.3 in libraries
[ivy:install] 	found commons-collections#commons-collections;2.1.1 in libraries
[ivy:install] 	found ant#ant;1.6.5 in libraries
[ivy:install] 	found swarmcache#swarmcache;1.0RC2 in libraries
[ivy:install] 	found commons-logging#commons-logging;1.0.2 in libraries
[ivy:install] 	found jgroups#jgroups-all;2.2.8 in libraries
[ivy:install] 	found jboss#jboss-cache;1.2.2 in libraries
[ivy:install] 	found jboss#jboss-system;4.0.2 in libraries
[ivy:install] 	found jboss#jboss-common;4.0.2 in libraries
[ivy:install] 	found slide#webdavlib;2.0 in libraries
[ivy:install] 	found xerces#xercesImpl;2.6.2 in libraries
[ivy:install] 	found jboss#jboss-minimal;4.0.2 in libraries
[ivy:install] 	found jboss#jboss-j2se;200504122039 in libraries
[ivy:install] 	found concurrent#concurrent;1.3.4 in libraries
[ivy:install] 	found jgroups#jgroups-all;2.2.7 in libraries
[ivy:install] 	found c3p0#c3p0;0.9.1 in libraries
[ivy:install] 	found javax.security#jacc;1.0 in libraries
[ivy:install] 	found opensymphony#oscache;2.1 in libraries
[ivy:install] 	found proxool#proxool;0.8.3 in libraries
[ivy:install] :: downloading artifacts to cache ::
[ivy:install] downloading http://repo1.maven.org/maven2/org/hibernate/hibernate/3.2.5.ga/hibernate-3.2.5.ga-sources.jar ...
[ivy:install] ...........................................
[ivy:install] ...............................
[ivy:install] .. (1470kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] org.hibernate#hibernate;3.2.5.ga!hibernate.jar(source) (3323ms)
[ivy:install] downloading http://repo1.maven.org/maven2/org/hibernate/hibernate/3.2.5.ga/hibernate-3.2.5.ga-javadoc.jar ...
[ivy:install] ...................................
[ivy:install] .............................
[ivy:install] ............................
[ivy:install] ...................................
[ivy:install] ...............................
[ivy:install] .........................
[ivy:install] ......................
[ivy:install] ...............................
[ivy:install] ................................
[ivy:install] ..........................................
[ivy:install] ............... (7352kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] org.hibernate#hibernate;3.2.5.ga!hibernate.jar(javadoc) (16380ms)
[ivy:install] downloading http://repo1.maven.org/maven2/org/hibernate/hibernate/3.2.5.ga/hibernate-3.2.5.ga.jar ...
[ivy:install] .......................................
[ivy:install] ........................................
[ivy:install] ..............................
[ivy:install] ... (2202kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] org.hibernate#hibernate;3.2.5.ga!hibernate.jar (4867ms)
[ivy:install] downloading http://repo1.maven.org/maven2/net/sf/ehcache/ehcache/1.2.3/ehcache-1.2.3.jar ...
[ivy:install] .................. (203kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] net.sf.ehcache#ehcache;1.2.3!ehcache.jar (546ms)
[ivy:install] downloading http://repo1.maven.org/maven2/commons-logging/commons-logging/1.0.4/commons-logging-1.0.4.jar ...
[ivy:install] ...... (37kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] commons-logging#commons-logging;1.0.4!commons-logging.jar (187ms)
[ivy:install] downloading http://repo1.maven.org/maven2/asm/asm-attrs/1.5.3/asm-attrs-1.5.3.jar ...
[ivy:install] ..... (16kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] asm#asm-attrs;1.5.3!asm-attrs.jar (156ms)
[ivy:install] downloading http://repo1.maven.org/maven2/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar ...
[ivy:install] ........................ (306kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] dom4j#dom4j;1.6.1!dom4j.jar (765ms)
[ivy:install] downloading http://repo1.maven.org/maven2/antlr/antlr/2.7.6/antlr-2.7.6.jar ...
[ivy:install] .......................... (433kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] antlr#antlr;2.7.6!antlr.jar (1060ms)
[ivy:install] downloading http://repo1.maven.org/maven2/cglib/cglib/2.1_3/cglib-2.1_3.jar ...
[ivy:install] ...................... (275kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] cglib#cglib;2.1_3!cglib.jar (702ms)
[ivy:install] downloading http://repo1.maven.org/maven2/asm/asm/1.5.3/asm-1.5.3.jar ...
[ivy:install] ..... (25kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] asm#asm;1.5.3!asm.jar (156ms)
[ivy:install] downloading http://repo1.maven.org/maven2/commons-collections/commons-collections/2.1.1/commons-collections-2.1.1.jar ...
[ivy:install] .................. (171kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] commons-collections#commons-collections;2.1.1!commons-collections.jar (687ms)
[ivy:install] downloading http://repo1.maven.org/maven2/commons-collections/commons-collections/2.1/commons-collections-2.1.jar ...
[ivy:install] ................. (161kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] commons-collections#commons-collections;2.1!commons-collections.jar (452ms)
[ivy:install] downloading http://repo1.maven.org/maven2/ant/ant/1.6.5/ant-1.6.5.jar ...
[ivy:install] .....................................
[ivy:install] ............. (1009kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] ant#ant;1.6.5!ant.jar (2247ms)
[ivy:install] downloading http://repo1.maven.org/maven2/swarmcache/swarmcache/1.0RC2/swarmcache-1.0RC2.jar ...
[ivy:install] ..... (29kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] swarmcache#swarmcache;1.0RC2!swarmcache.jar (327ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jboss/jboss-cache/1.2.2/jboss-cache-1.2.2.jar ...
[ivy:install] ........................... (365kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jboss#jboss-cache;1.2.2!jboss-cache.jar (983ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jgroups/jgroups-all/2.2.8/jgroups-all-2.2.8.jar ...
[ivy:install] .................................
[ivy:install] ............................
[ivy:install] ................ (1573kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jgroups#jgroups-all;2.2.8!jgroups-all.jar (4976ms)
[ivy:install] downloading http://repo1.maven.org/maven2/c3p0/c3p0/0.9.1/c3p0-0.9.1.jar ...
[ivy:install] ............................................. (594kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] c3p0#c3p0;0.9.1!c3p0.jar (1373ms)
[ivy:install] downloading http://repo1.maven.org/maven2/opensymphony/oscache/2.1/oscache-2.1.jar ...
[ivy:install] ......... (111kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] opensymphony#oscache;2.1!oscache.jar (546ms)
[ivy:install] downloading http://repo1.maven.org/maven2/proxool/proxool/0.8.3/proxool-0.8.3.jar ...
[ivy:install] ............................. (464kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] proxool#proxool;0.8.3!proxool.jar (1154ms)
[ivy:install] downloading http://repo1.maven.org/maven2/commons-logging/commons-logging/1.0.2/commons-logging-1.0.2.jar ...
[ivy:install] ..... (25kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] commons-logging#commons-logging;1.0.2!commons-logging.jar (218ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jboss/jboss-system/4.0.2/jboss-system-4.0.2.jar ...
[ivy:install] ...................... (227kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jboss#jboss-system;4.0.2!jboss-system.jar (687ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jboss/jboss-common/4.0.2/jboss-common-4.0.2.jar ...
[ivy:install] ........................... (457kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jboss#jboss-common;4.0.2!jboss-common.jar (1123ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jboss/jboss-minimal/4.0.2/jboss-minimal-4.0.2.jar ...
[ivy:install] ................. (163kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jboss#jboss-minimal;4.0.2!jboss-minimal.jar (468ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jboss/jboss-j2se/200504122039/jboss-j2se-200504122039.jar ...
[ivy:install] ........................ (350kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jboss#jboss-j2se;200504122039!jboss-j2se.jar (1107ms)
[ivy:install] downloading http://repo1.maven.org/maven2/concurrent/concurrent/1.3.4/concurrent-1.3.4.jar ...
[ivy:install] ....................... (184kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] concurrent#concurrent;1.3.4!concurrent.jar (500ms)
[ivy:install] downloading http://repo1.maven.org/maven2/jgroups/jgroups-all/2.2.7/jgroups-all-2.2.7.jar ...
[ivy:install] .......................................
[ivy:install] ..................................
[ivy:install] ............ (1613kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] jgroups#jgroups-all;2.2.7!jgroups-all.jar (3619ms)
[ivy:install] downloading http://repo1.maven.org/maven2/slide/webdavlib/2.0/webdavlib-2.0.jar ...
[ivy:install] ............ (128kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] slide#webdavlib;2.0!webdavlib.jar (390ms)
[ivy:install] downloading http://repo1.maven.org/maven2/xerces/xercesImpl/2.6.2/xercesImpl-2.6.2.jar ...
[ivy:install] .................................
[ivy:install] .............. (986kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] xerces#xercesImpl;2.6.2!xercesImpl.jar (2340ms)
[ivy:install] :: installing in my-repository ::
[ivy:install] 	published hibernate to /ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/sources/hibernate-3.2.5.ga.jar
[ivy:install] 	published hibernate to /ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/javadocs/hibernate-3.2.5.ga.jar
[ivy:install] 	published hibernate to /ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/jars/hibernate-3.2.5.ga.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/ivys/ivy-3.2.5.ga.xml
[ivy:install] 	published ehcache to /ivy/build-a-ivy-repository/myrepository/no-namespace/net.sf.ehcache/ehcache/jars/ehcache-1.2.3.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/net.sf.ehcache/ehcache/ivys/ivy-1.2.3.xml
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/javax.transaction/jta/ivys/ivy-1.0.1B.xml
[ivy:install] 	published commons-logging to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-logging/commons-logging/jars/commons-logging-1.0.4.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-logging/commons-logging/ivys/ivy-1.0.4.xml
[ivy:install] 	published asm-attrs to /ivy/build-a-ivy-repository/myrepository/no-namespace/asm/asm-attrs/jars/asm-attrs-1.5.3.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/asm/asm-attrs/ivys/ivy-1.5.3.xml
[ivy:install] 	published dom4j to /ivy/build-a-ivy-repository/myrepository/no-namespace/dom4j/dom4j/jars/dom4j-1.6.1.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/dom4j/dom4j/ivys/ivy-1.6.1.xml
[ivy:install] 	published antlr to /ivy/build-a-ivy-repository/myrepository/no-namespace/antlr/antlr/jars/antlr-2.7.6.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/antlr/antlr/ivys/ivy-2.7.6.xml
[ivy:install] 	published cglib to /ivy/build-a-ivy-repository/myrepository/no-namespace/cglib/cglib/jars/cglib-2.1_3.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/cglib/cglib/ivys/ivy-2.1_3.xml
[ivy:install] 	published asm to /ivy/build-a-ivy-repository/myrepository/no-namespace/asm/asm/jars/asm-1.5.3.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/asm/asm/ivys/ivy-1.5.3.xml
[ivy:install] 	published commons-collections to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-collections/commons-collections/jars/commons-collections-2.1.1.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-collections/commons-collections/ivys/ivy-2.1.1.xml
[ivy:install] 	published commons-collections to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-collections/commons-collections/jars/commons-collections-2.1.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-collections/commons-collections/ivys/ivy-2.1.xml
[ivy:install] 	published ant to /ivy/build-a-ivy-repository/myrepository/no-namespace/ant/ant/jars/ant-1.6.5.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/ant/ant/ivys/ivy-1.6.5.xml
[ivy:install] 	published swarmcache to /ivy/build-a-ivy-repository/myrepository/no-namespace/swarmcache/swarmcache/jars/swarmcache-1.0RC2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/swarmcache/swarmcache/ivys/ivy-1.0RC2.xml
[ivy:install] 	published jboss-cache to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-cache/jars/jboss-cache-1.2.2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-cache/ivys/ivy-1.2.2.xml
[ivy:install] 	published jgroups-all to /ivy/build-a-ivy-repository/myrepository/no-namespace/jgroups/jgroups-all/jars/jgroups-all-2.2.8.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jgroups/jgroups-all/ivys/ivy-2.2.8.xml
[ivy:install] 	published c3p0 to /ivy/build-a-ivy-repository/myrepository/no-namespace/c3p0/c3p0/jars/c3p0-0.9.1.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/c3p0/c3p0/ivys/ivy-0.9.1.xml
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/javax.security/jacc/ivys/ivy-1.0.xml
[ivy:install] 	published oscache to /ivy/build-a-ivy-repository/myrepository/no-namespace/opensymphony/oscache/jars/oscache-2.1.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/opensymphony/oscache/ivys/ivy-2.1.xml
[ivy:install] 	published proxool to /ivy/build-a-ivy-repository/myrepository/no-namespace/proxool/proxool/jars/proxool-0.8.3.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/proxool/proxool/ivys/ivy-0.8.3.xml
[ivy:install] 	published commons-logging to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-logging/commons-logging/jars/commons-logging-1.0.2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/commons-logging/commons-logging/ivys/ivy-1.0.2.xml
[ivy:install] 	published jboss-system to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-system/jars/jboss-system-4.0.2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-system/ivys/ivy-4.0.2.xml
[ivy:install] 	published jboss-common to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-common/jars/jboss-common-4.0.2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-common/ivys/ivy-4.0.2.xml
[ivy:install] 	published jboss-minimal to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-minimal/jars/jboss-minimal-4.0.2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-minimal/ivys/ivy-4.0.2.xml
[ivy:install] 	published jboss-j2se to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-j2se/jars/jboss-j2se-200504122039.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jboss/jboss-j2se/ivys/ivy-200504122039.xml
[ivy:install] 	published concurrent to /ivy/build-a-ivy-repository/myrepository/no-namespace/concurrent/concurrent/jars/concurrent-1.3.4.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/concurrent/concurrent/ivys/ivy-1.3.4.xml
[ivy:install] 	published jgroups-all to /ivy/build-a-ivy-repository/myrepository/no-namespace/jgroups/jgroups-all/jars/jgroups-all-2.2.7.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/jgroups/jgroups-all/ivys/ivy-2.2.7.xml
[ivy:install] 	published webdavlib to /ivy/build-a-ivy-repository/myrepository/no-namespace/slide/webdavlib/jars/webdavlib-2.0.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/slide/webdavlib/ivys/ivy-2.0.xml
[ivy:install] 	published xercesImpl to /ivy/build-a-ivy-repository/myrepository/no-namespace/xerces/xercesImpl/jars/xercesImpl-2.6.2.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/no-namespace/xerces/xercesImpl/ivys/ivy-2.6.2.xml
[ivy:install] :: install resolution report ::
[ivy:install] :: resolution report :: resolve 0ms :: artifacts dl 51402ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   28  |   28  |   28  |   0   ||   30  |   28  |
	---------------------------------------------------------------------
[ivy:install] 
[ivy:install] :: problems summary ::
[ivy:install] :::: WARNINGS
[ivy:install] 		[NOT FOUND  ] javax.transaction#jta;1.0.1B!jta.jar (0ms)
[ivy:install] 	==== libraries: tried
[ivy:install] 	  http://repo1.maven.org/maven2/javax/transaction/jta/1.0.1B/jta-1.0.1B.jar
[ivy:install] 		[NOT FOUND  ] javax.security#jacc;1.0!jacc.jar (0ms)
[ivy:install] 	==== libraries: tried
[ivy:install] 	  http://repo1.maven.org/maven2/javax/security/jacc/1.0/jacc-1.0.jar
[ivy:install] 		::::::::::::::::::::::::::::::::::::::::::::::
[ivy:install] 		::              FAILED DOWNLOADS            ::
[ivy:install] 		:: ^ see resolution messages for details  ^ ::
[ivy:install] 		::::::::::::::::::::::::::::::::::::::::::::::
[ivy:install] 		:: javax.transaction#jta;1.0.1B!jta.jar
[ivy:install] 		:: javax.security#jacc;1.0!jacc.jar
[ivy:install] 		::::::::::::::::::::::::::::::::::::::::::::::
[ivy:install] 
[ivy:install] 
[ivy:install] :: USE VERBOSE OR DEBUG MESSAGE LEVEL FOR MORE DETAILS

</pre>
</div>

As you can see the installation has failed, if you look at the log you will see that there are missing artifacts on the source repository. This means that you will need to download those artifacts manually, and copy them to your destination repository to complete the installation. Fortunately Ivy uses a best effort algorithm during install, so that everything gets installed except the missing artifacts. (Note: these missing artifacts are not in the public maven repository due to licensing issues)<br class="xooki-br"/><br class="xooki-br"/>You may also have noticed that Ivy installed 2 different revisions of commons-logging (1.0.2, 1.0.4). This is due to the fact that we used the "no conflict" <a href="settings/conflict-managers.html">conflict manager</a> in the ivysettings file.<br class="xooki-br"/><br class="xooki-br"/>We do not want to evict any modules because we are building our own repository. Indeed if we get both commons-logging 1.0.2 and 1.0.4 it's because some modules among the transitive dependencies of hibernate depend on 1.0.2 and others on 1.0.4. If we got only 1.0.4, the module depending on 1.0.2 would be inconsistent in your own repository (depending on a version you don't have installed). Thus developers using this module directly would run into a problem.<br class="xooki-br"/><br class="xooki-br"/>If you now have a closer look at your repository, you will probably notice that it isn't an exact replication of the original one. Let's have a look at the directory of one module:
<div class="shell"><pre>
[ivy@apache:/]$ find /ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate -type f -print
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/ivys/ivy-3.2.5.ga.xml
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/ivys/ivy-3.2.5.ga.xml.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/ivys/ivy-3.2.5.ga.xml.sha1
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/jars/hibernate-3.2.5.ga.jar
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/jars/hibernate-3.2.5.ga.jar.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/jars/hibernate-3.2.5.ga.jar.sha1
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/javadocs/hibernate-3.2.5.ga.jar
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/javadocs/hibernate-3.2.5.ga.jar.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/javadocs/hibernate-3.2.5.ga.jar.sha1
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/sources/hibernate-3.2.5.ga.jar
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/sources/hibernate-3.2.5.ga.jar.md5
/ivy/build-a-ivy-repository/myrepository/no-namespace/org.hibernate/hibernate/sources/hibernate-3.2.5.ga.jar.sha1

</pre>
</div>

As you can see there is no pom here (pom is the module metadata format used by maven 2, available on the maven 2 repository). Instead you can see there's an ivy file, which is actually the original hibernate pom converted into an ivy file. So now you have a true Ivy repository with ivy files, where you can use the full power of Ivy if you want to adjust the module metadata (module configurations, fine grain exclusions and transitivity control, per module conflict manager, ...).<br class="xooki-br"/><br class="xooki-br"/>OK, enough for this simple repository installation, the <a href="tutorial/build-repository/advanced.html">next tutorial</a> will show how you can deal with more complex cases where your source and destination repositories do not follow the same naming conventions.<hr/><div class='toc-title toc-title-4'>Using namespaces</div><br class="xooki-br"/>Now that you have seen how simple it is to create your own repository from an existing one, you may wonder how you can handle more complex cases, like when the source and destination repositories don't follow the same naming conventions. <br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/><h1>On the road to a professional repository</h1>
In this section, you will learn how to build a <strong>professional</strong> repository. What is a <strong>professional</strong> repository? Our vision is to say that a good quality repository must follow clear rules about projects naming and must offer correct, useable, configurations and verified project descriptors. In order to achieve those goals, we think that you have to build your own repository.<br class="xooki-br"/>We have seen in the previous example, that we could use some public repositories to begin to build our own repository. Nevertheless, the result is not always the expected one, especially concerning the naming rules used.<br class="xooki-br"/><br class="xooki-br"/>This problem is pretty normal when you have an existing repository, and want to benefit from large public repositories which do not follow the same naming conventions. It also shows up because many public repositories do not use a  consistent naming scheme. For example, why don't all the apache commons modules use the org.apache.commons organization? Well.. for historical reasons. But if you setup your own repository, you may not want to suffer from the mistakes of history.<br class="xooki-br"/><br class="xooki-br"/>Fortunately, Ivy has a very powerful answer to this problem: <a href="settings/namespaces.html">namespaces</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>Using namespaces</h1>
If you look at the repository built with the <a href="tutorial/build-repository/basic.html">previous tutorial</a>, you will see exactly what we were talking about: all apache commons modules use their own name as their organization.<br class="xooki-br"/><br class="xooki-br"/>So let's see what Ivy can do using namespaces (we will dig into details later):
<div class="shell"><pre>
[ivy@apache:/ivy/build-a-ivy-repository]$ ant maven2-namespace
Buildfile: /ivy/build-a-ivy-repository/build.xml

load-ivy:

init-ivy:

maven2-namespace:
[ivy:install] :: Apache Ivy 2.3.0 - 20130110142753 :: http://ant.apache.org/ivy/ ::
[ivy:install] :: loading settings :: file = /ivy/build-a-ivy-repository/settings/ivysettings-advanced.xml
[ivy:install] :: installing apache#commons-lang;1.0 ::
[ivy:install] :: resolving dependencies ::
[ivy:install] 	found apache#commons-lang;1.0 in libraries
[ivy:install] :: downloading artifacts to cache ::
[ivy:install] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/1.0/commons-lang-1.0.jar ...
[ivy:install] .................. (62kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] apache#commons-lang;1.0!commons-lang.jar (234ms)
[ivy:install] downloading http://repo1.maven.org/maven2/commons-lang/commons-lang/1.0/commons-lang-1.0-javadoc.jar ...
[ivy:install] ......... (170kB)
[ivy:install] .. (0kB)
[ivy:install] 	[SUCCESSFUL ] apache#commons-lang;1.0!commons-lang.jar(javadoc) (468ms)
[ivy:install] :: installing in my-repository ::
[ivy:install] 	published commons-lang to /ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/jars/commons-lang-1.0.jar
[ivy:install] 	published commons-lang to /ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/javadocs/commons-lang-1.0.jar
[ivy:install] 	published ivy to /ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/ivys/ivy-1.0.xml
[ivy:install] :: install resolution report ::
[ivy:install] :: resolution report :: resolve 0ms :: artifacts dl 702ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      default     |   1   |   1   |   1   |   0   ||   2   |   2   |
	---------------------------------------------------------------------

BUILD SUCCESSFUL
Total time: 2 seconds

</pre></div>

Now if we look at our repository, it seems to look fine.
<div class="shell"><pre>
$ find /ivy/build-a-ivy-repository/myrepository/advanced -type f -print
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/ivys/ivy-1.0.xml
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/ivys/ivy-1.0.xml.md5
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/ivys/ivy-1.0.xml.sha1
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/jars/commons-lang-1.0.jar
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/jars/commons-lang-1.0.jar.md5
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/jars/commons-lang-1.0.jar.sha1
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/javadocs/commons-lang-1.0.jar
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/javadocs/commons-lang-1.0.jar.md5
/ivy/build-a-ivy-repository/myrepository/advanced/apache/commons-lang/javadocs/commons-lang-1.0.jar.sha1

</pre></div>
We can even have a look at the commons-lang ivy file in our repository:
<div><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="xooki-br"/>&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>	&lt;info organisation="apache"<br class="xooki-br"/>		module="commons-lang"<br class="xooki-br"/>		revision="1.0"<br class="xooki-br"/>		status="integration"<br class="xooki-br"/>		publication="20051124062021"<br class="xooki-br"/>		namespace="ibiblio-maven2"<br class="xooki-br"/>	/&gt;<br class="xooki-br"/><br class="xooki-br"/>...
</pre></div>
Alright, we see that the organisation is now 'apache'. But where did Ivy pick this up?<br class="xooki-br"/><h2>How does this work ?</h2>
Actually, Ivy uses the same repository as before for the source repository, with only one difference: the namespace parameter:
<pre>
&lt;ibiblio name="libraries" <br class="xooki-br"/>    root="${ibiblio-maven2-root}" <br class="xooki-br"/>    m2compatible="true"<br class="xooki-br"/>    namespace="maven2"<br class="xooki-br"/>/&gt;
</pre>

A namespace is defined by a set of rules. These rules are based on regular expressions and tell Ivy how to convert data from the repository namespace  to what is called the system namespace, i.e. the namespace in which Ivy runs most of the time (Note: the Ivy cache always uses the system namespace).<br class="xooki-br"/><br class="xooki-br"/>For the namespace we call <i>maven2</i>, we have declared several rules. Below is one of the rules:<br class="xooki-br"/><h3>rule handling the imported apache maven1 projects</h3>
<pre>&lt;rule&gt;	&lt;!-- imported apache maven1 projects --&gt;<br class="xooki-br"/>	&lt;fromsystem&gt;<br class="xooki-br"/>	    &lt;src org="apache" module=".+"/&gt;<br class="xooki-br"/>	    <br class="xooki-br"/>	    &lt;dest org="$m0" module="$m0"/&gt;<br class="xooki-br"/>	&lt;/fromsystem&gt;<br class="xooki-br"/>	&lt;tosystem&gt;<br class="xooki-br"/>	    &lt;src org="commons-.+" module="commons-.+" /&gt;<br class="xooki-br"/>	    &lt;src org="ant.*" module="ant.*" /&gt;<br class="xooki-br"/>	    ...<br class="xooki-br"/>	    &lt;src org="xmlrpc" module="xmlrpc" /&gt;<br class="xooki-br"/><br class="xooki-br"/>	    &lt;dest org="apache" module="$m0"/&gt;<br class="xooki-br"/>	&lt;/tosystem&gt;<br class="xooki-br"/>&lt;/rule&gt;</pre>
<div class="postit"><u>Note about regular expressions usage :</u>
In order to distinguish matching regular expressions found in organization, module, and revision, the notation Ivy uses prefixes the matching regular expression with the letters 'o', 'm' and 'r'.<br class="xooki-br"/>$o0 : the whole matching value in the organization attribute<br class="xooki-br"/>$o1 : the first matching expression group that was marked in the organization attribute<br class="xooki-br"/>...<br class="xooki-br"/>The same applies for modules : $m0, $m1, ...<br class="xooki-br"/>and for revisions : $r0, $r1, ...
</div>
To understand namespaces, 
<ul>
<li><b>fromsystem :</b> we define here that the projects defined in the system namespace under the organization called "apache" are transformed into the destination namespace into projects whose organization is named with the module name, whatever the revision is. For example, the project apache#commons-lang;1.0  in the system namespace will be translated into commons-lang#commons-lang;1.0 in the maven2 resolver namespace.</li>
<li><b>tosystem :</b> we define here the reverse mapping, i.e. how to translate <em>apache</em> projects from maven 2 repo into apache projects in the system namespace. The rule used here tells Ivy that all projects matching <tt>commons-.+</tt> (see it as java regular expression) for their organization name and module name are transformed into projects whose organisation is <tt>apache</tt> with the module name as it was found. The same kind of rule is defined for others apache projects like ant, etc.</li>
</ul>

OK, you should now get the idea behind namespaces, so go ahead and look at the <tt>ivysettings-advanced.xml</tt> file in this example. You can test the installation of a module and its dependencies using namespaces.<br class="xooki-br"/><br class="xooki-br"/>Run 
<pre>ant maven2-namespace-deps</pre> 
and you will see the resulting repository is cleaner than the first one we built.<br class="xooki-br"/><br class="xooki-br"/>From our experience, investing in creating a namespace is worth the time it costs if you often need to add new modules or revisions of third party libraries in your own repository, where naming rules already exist or are rather strict. <hr/><div class='toc-title toc-title-3'>More examples</div><br class="xooki-br"/>If you have successfully followed and understood all the tutorials, you still might need to get a better picture of how to use Ivy in the real world.<br class="xooki-br"/><br class="xooki-br"/>Here are some links which might be interesting:<br class="xooki-br"/><br class="xooki-br"/><h3><a href="http://wiki.hippo.nl/display/OS/SAnt+build+system">SAnt</a></h3>
SAnt is an experimental build system based on Ant and Ivy. It can be interesting to use "as is", or to get insight on an interesting approach to manage your builds.<br class="xooki-br"/><br class="xooki-br"/><h3><a href="https://springmodules.dev.java.net/">Spring Modules</a></h3>
The spring modules project build system is based on Ant and Ivy, and it's really interesting to have a look at how a modularized project can take advantage of advanced Ant and Ivy features to make the build simpler.<br class="xooki-br"/><br class="xooki-br"/><h3><a href="http://www.opensymphony.com/webwork/">Webwork</a></h3>
The webwork project (which should become struts action framework) uses ant+ivy for their build, and thus makes their framework very easy to use in an ant+ivy build system. They have a <a href="http://wiki.opensymphony.com/display/WW/Dependencies">page documenting how to use Ivy with their framework</a>, which can be an interesting reading, even if you don't plan to use webwork.<br class="xooki-br"/><br class="xooki-br"/><h3><a href="http://www.jaya.free.fr/ivy/doc/articles/ease-multi-module.html">Easing multi-module development</a></h3>
Johan stuyts, the author of SAnt, also contributed a nice article on his view of how to use Ivy on a multi-module environment.<br class="xooki-br"/><br class="xooki-br"/><h3><a href="http://olmex.blogspot.in/2012/04/ivy-beginners-guide.html">Beginners Guide</a></h3>

Apache Ivy - Beginners Guide is a step by step guide to assist beginners in understanding basic concepts/tasks and use them straight away in their projects either through Ant build or in Eclipse IDE.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-2'>Reference</div><br class="xooki-br"/>Welcome to the Ivy reference documentation!<br class="xooki-br"/><br class="xooki-br"/>If you don't know Ivy at all, take a look at its features, the faq and the <a href="tutorial.html">tutorials</a> before digging into this reference documentation.<br class="xooki-br"/><br class="xooki-br"/><h1>Reference Overview</h1>
This documentation is broken into several parts:
<ul>
<li>Introduction</li>
<ul>
<li><a href="terminology.html">Terminology</a></li>
This part gives you the meaning of some words used all over the Ivy documentation, such as organization, module, configurations, settings, ...
<li><a href="concept.html">Main Concepts</a></li>
This part introduces the main concepts used in Ivy: dependency resolvers, variables, patterns, and also a good introduction to a central ivy concept: module configurations.
<li><a href="principle.html">How does it work ?</a></li>
As the title suggests, here you will find an explanation of how Ivy does work internally, which can help to better understand and customize its use.
<li><a href="install.html">Installation</a></li>
This part describes how to install Ivy.
</ul>
<li><a href="settings.html">Settings Files</a></li>
This part is dedicated to the specification of the settings file of Ivy (usually called ivysettings.xml). It also gives the list of built-in dependency resolvers available in Ivy.
<li><a href="ivyfile.html">Ivy Files</a></li>
This part is the reference for the module descriptors, the Ivy files in which you describe your dependencies. If you have any questions about what can be done or not in an ivy file, you will find the answer here.
<li><a href="ant.html">Ant Tasks</a></li>
This part describes how to use Ivy from ant. It's in this section that all ant tasks provided by Ivy are specified.
<li><a href="standalone.html">Using standalone</a></li>
Even though Ivy is most often used from ant, it can also be used from the command line. This page describes how you can do this.
</ul><hr/><div class='toc-title toc-title-3'>Introduction</div><hr/><div class='toc-title toc-title-4'>Terminology</div><br class="xooki-br"/>Here are some terms used in Ivy, with their definitions in Ivy:
<ul>
<li><a href="#organisation">Organisation</a></li>
<li><a href="#module">Module</a></li>
<li><a href="#descriptor">Module Descriptor</a></li>
<li><a href="#artifact">Artifact</a></li>
<li><a href="#type">Type of an artifact</a></li>
<li><a href="#extension">Artifact file name extension</a></li>
<li><a href="#revision">Module Revision</a></li>
<li><a href="#branch">Branch</a></li>
<li><a href="#status">Status of a revision</a></li>
<li><a href="#configurations">Configurations of a module</a></li>
<li><a href="#settings">Ivy Settings</a></li>
<li><a href="#repository">Repository</a></li>
</ul>

<h1>Overview</h1>
The following <a name="illustration">illustration</a> shows all the key terminology in one diagram:<br class="xooki-br"/><br class="xooki-br"/><p><img alt="terminology illustration" src="images/ivy-terminology.png" width="587" height="1040" vspace="16"/></p>

<h1><a name="organisation">Organisation</a></h1>
An organisation is either a company, an individual, or simply any group of people that produces software. In principle, Ivy handles only a single level of organisation, meaning that they have a flat namespace in Ivy module descriptors. So, with Ivy descriptors, you can only describe a tree-like organisation structure, if you use a hierarchical naming convention. The organisation name is used for keeping together software produced by the same team, just to help locate their published works.<br class="xooki-br"/><br class="xooki-br"/>Often organisations will use their inverted domain name as their organisation name in Ivy, since domain names by definition are unique. A company whose domain name is www.example.com might want to use com.example, or if they had multiple teams, all their organisation names could begin with com.example (e.g. com.example.rd, com.example.infra, com.example.services). The organisation name does neither really have to be an inverted domain name, nor even globally unique, but unique naming is highly recommended. Widely recognized trademark or trade name owners may choose to use their brand name instead.<br class="xooki-br"/><br class="xooki-br"/><i>Examples: org.apache, ibm, jayasoft</i><br class="xooki-br"/><br class="xooki-br"/>Note that the Ivy "organisation" is very similar to Maven POM "groupId".<br class="xooki-br"/></dd>
<h1><a name="module">Module</a></h1>
A module is a self-contained, reusable unit of software that, as a whole unit, follows a revision control scheme.<br class="xooki-br"/><br class="xooki-br"/>Ivy is only concerned about the module deliverables known as <em>artifacts</em>, and the <em>module descriptor</em> that declares them. These deliverables, for each <em>revision</em> of the module, are managed in <em>repositories</em>. In other words, to Ivy, a module is a chain of revisions each comprising a descriptor and one or more artifacts.<br class="xooki-br"/><br class="xooki-br"/><i>Examples: hibernate-entitymanager, ant</i><br class="xooki-br"/><h2><a name="descriptor">Module Descriptor</a></h2>
A <em>module descriptor</em> is a generic way of identifying what describes a module: the identifier (organisation, module name, branch and revision), the published artifacts, possible configurations and their dependencies.<br class="xooki-br"/><br class="xooki-br"/>The most common module descriptors in Ivy are <a href="ivyfile.html">Ivy Files</a>, xml files with an Ivy specific syntax, and usually called ivy.xml.<br class="xooki-br"/><br class="xooki-br"/>But since Ivy is also compatible with maven 2 metadata format (called pom, for Project Object Model), pom files fall into the category of module descriptors.<br class="xooki-br"/><br class="xooki-br"/>And because Ivy accepts pluggable module descriptor parsers, you can use almost whatever you want as module descriptors.<br class="xooki-br"/><h1><a name="artifact">Artifact</a></h1>
An artifact is <em>a single file</em> ready for delivery with the publication of a module revision, as a product of development.<br class="xooki-br"/><br class="xooki-br"/>Compressed package formats are often preferred because they are easier to manage, transfer and store. For the same reasons, only one or a few artifacts per module are commonly used. However, artifacts can be of any file type and any number of them can be declared in a single module.<br class="xooki-br"/><br class="xooki-br"/>In the Java world, common artifacts are Java archives or JAR files. In many cases, each revision of a module publishes only one artifact (like jakarta-log4j-1.2.6.tar.gz, for instance), but some of them publish many artifacts dependending on the use of the module (like apache-ant binary and source distributions in zip, gz and bz2 package formats, for instance).<br class="xooki-br"/><br class="xooki-br"/><i>Examples: ant-1.7.0-bin.zip, apache-ant-1.7.0-src.tar.gz </i><br class="xooki-br"/><h2><a name="type">Type</a> of an artifact</h2>
The artifact type is a category of a particular kind of artifact specimen. It is a classification based on the intended purpose of an artifact or <em>why</em> it is provided, not a category of packaging format or <em>how</em> the artifact is delivered.<br class="xooki-br"/><br class="xooki-br"/>Although the type of an artifact may (rather accidentally) imply its file format, they are two different concepts. The artifact file name extension is more closely associated with its format. For example, in the case of Java archives the artifact type "jar" indicates that it is indeed a Java archive as per the JAR File specification. The file name extension happens to be "jar" as well. On the other hand, with source code distributions, the artifact type may be "source" while the file name extensions vary from "tar.gz", "zip", "java", "c", or "xml" to pretty much anything. So, the type of an artifact is basically an abstract functional category to explain its purpose, while the artifact file name extension is a more concrete technical indication of its format and, of course, naming.<br class="xooki-br"/><br class="xooki-br"/>Defining appropriate artifact types for a module is up to its development organisation. Common choices may include: "jar", "binary", "bin", "rc", "exe", "dll", "source", "src", "config", "conf", "cfg", "doc", "api", "spec", "manual", "man", "data", "var", "resource", "res", "sql", "schema", "deploy", "install", "setup", "distrib", "distro", "distr", "dist", "bundle", etc.<br class="xooki-br"/><br class="xooki-br"/>Module descriptors are not really artifacts, but they are comparable to an artifact type, i.e. "descriptor" (an ivy file or a Maven POM).<br class="xooki-br"/><br class="xooki-br"/>Electronic signatures or digests are not really artifacts themselves, but can be found with them in repositories. They also are comparable to an artifact type, i.e. "digest" (md5 or sha1).<br class="xooki-br"/><h2><a name="extension">Artifact file name extension</a></h2>
In some cases the artifact type already implies its file name extension, but not always. More generic types may include several different file formats, e.g. documentation can contain tarballs, zip packages or any common document formats.<br class="xooki-br"/><br class="xooki-br"/><i>Examples: zip, tar, tar.gz, rar, jar, war, ear, txt, doc, xml, html</i><br class="xooki-br"/><h1>Module <a name="revision">Revision</a> and Status</h1>
<h2>Module revision</h2>
A unique revision number or version name is assigned to each delivered unique state of a module. Ivy can help in generating revision numbers for module delivery and publishing revisions to repositories, but other aspects of revision control, especially source revisioning, must be managed with a separate version control system.<br class="xooki-br"/><br class="xooki-br"/>Therefore, to Ivy, a <em>revision</em> always corresponds to <em>a delivered version of a module</em>. It can be a public, shared or local delivery, a release, a milestone, or an integration build, an alpha or a beta version, a nightly build, or even a continuous build. All of them are considered revisions by Ivy.<br class="xooki-br"/><h3><i>Source revision</i></h3>
Source files kept under a version control system (like Subversion, CVS, SourceSafe, Perforce, etc.) have a separate revisioning scheme that is independent of the <em>module revisions</em> visible to Ivy. Ivy is unaware of any revisions of a module's source files.<br class="xooki-br"/><br class="xooki-br"/>In some cases, the SCM's <em>source revision</em> number could be used also as the <em>module revision</em> number, but that usage is very rare. They are still two different concepts, even if the module revision number was wholly or partially copied from the respective source revision number.<br class="xooki-br"/><h2><a name="branch">Branch</a></h2>
A branch corresponds to the standard meaning of a branch (or sometimes stream) in source control management tools.<br class="xooki-br"/>The head, or trunk, or main stream, is also considered as a branch in Ivy.<br class="xooki-br"/><h2><a name="status">Status of a revision</a></h2>
A module's status indicates how stable a module revision can be considered. It can be used to consolidate the status of all the dependencies of a module, to prevent the use of an integration revision of a dependency in the release of your module.<br class="xooki-br"/><br class="xooki-br"/>Three statuses are defined by default in Ivy:
<ul>
<li><strong>integration</strong>: revisions builded by a continuous build, a nightly build, and so on, fall in this category</li>
<li><strong>milestone</strong>: revisions delivered to the public but not actually finished fall in this category</li>
<li><strong>release</strong>: a revision fully tested and labelled fall in this category</li>
</ul>
<span class="since">Since 1.4</span> This list is <a href="configuration/statuses.html">configurable</a> in your settings file.<br class="xooki-br"/><h1><a name="configurations">Configurations</a> of a module</h1>
A <em>module configuration</em> is a way to use or construct a module. If the same module has different dependencies based on how it's used, those distinct dependency-sets are called its configurations in Ivy.<br class="xooki-br"/><br class="xooki-br"/>Some modules may be used in different ways (think about hibernate which can be used inside or outside an application server), and this way may alter the artifacts you need (in the case of hibernate, jta.jar is needed only if it is used outside an application server).<br class="xooki-br"/>Moreover, a module may need some other modules and artifacts only at build time, and some others at runtime. All those different ways to use or build a module are called module configurations in ivy. <br class="xooki-br"/><br class="xooki-br"/>For more details on configurations and how they are used in ivy, please refer to the <a href="concept.html">main concepts page</a>.<br class="xooki-br"/><h1><a name="settings">Ivy Settings</a></h1>
Ivy settings files are xml files used to configure ivy to indicate where the modules can be found and how.<br class="xooki-br"/><h3><i>History of settings</i></h3>
<i>Prior to Ivy 2.0, the settings files were called configuration files and usually named ivyconf.xml. This resulted in confusion between module configurations and Ivy configuration files, so they were renamed to settings files. If you happen to fall on an ivyconf file or something called a configuration file, most of the time it's only unupdated information (documentation, tutorial or article). Feel free to report any problem like this if you find such an inconsistency.</i><br class="xooki-br"/><br class="xooki-br"/><h1><a name="repository">Repository</a></h1>
What is called a <em>repository</em> in Ivy is a distribution site location where Ivy is able to find your required modules' artifacts and descriptors (i.e. Ivy files in most cases).<br class="xooki-br"/>Ivy can be used with complex repositories configured very finely. You can use <a href="concept.html">Dependency Resolvers</a> to do so.<br class="xooki-br"/><hr/><div class='toc-title toc-title-4'>Main Concepts</div><br class="xooki-br"/><h1><a name="dependency-resolver"></a>Dependency Resolver</h1>
A dependency resolver is a pluggable class in ivy which is used to:
<ul>
<li>find dependencies' ivy files</li>
<li>download dependencies' artifacts</li>
</ul>
The notion of artifact "downloading" is large: an artifact can be on a web site, or on the local file system of your machine. The download is thus the act of bring a file from a repository to the ivy cache.<br class="xooki-br"/><br class="xooki-br"/>Moreover, the fact that it is the responsibility of the resolver to find ivy files and download artifacts helps to implement various resolving strategies.<br class="xooki-br"/><br class="xooki-br"/>As you see, a dependency resolver can be thought of as a class responsible for describing a repository.<br class="xooki-br"/><br class="xooki-br"/>If you want to see which resolvers are available in ivy, you can go to the <a href="settings/resolvers.html">resolvers configuration page</a>.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="configurations">Module configurations explained</a></h1>
Module configurations are described in the terminology page as <em>a way to use or construct a module</em>. Configurations being a central part of Ivy, they need more explanations as a concept.<br class="xooki-br"/><br/>
When you define a way to use or construct a module, you are able to define which artifacts are published by this module in this configuration, and you are also able to define which dependencies are needed in this configuration.<br class="xooki-br"/><br class="xooki-br"/>Moreover, because dependencies in ivy are expressed on modules and not on artifacts, it is important to be able to define which configurations of the dependency are required in the configuration you define of your module. That's what is called <strong>configuration mapping</strong>.<br class="xooki-br"/><br class="xooki-br"/>If you use only simple modules and do not want to worry about configurations, you don't have to worry about them. They're still there under the hood because ivy can't work without configurations. But most of the time if you declare nothing, ivy assumes that the artifacts of your module are published in all configurations, and that all the dependencies' configurations are required in all configurations. And it works in simple cases. But whenever you want to separate things within a module, or get more control over things published and get better dependencies resolution, configurations will meet most of your needs.<br class="xooki-br"/><br class="xooki-br"/>For details on how to declare your module configurations, how to declare in which configuration your artifacts are published, and how to declare configuration mapping, please refer to <a href="ivyfile.html">ivy file documentation</a>. The <a href="tutorial/conf.html">configurations tutorial</a> is also a good place to go to learn more about this concept.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="variables"></a>Variables</h1>
During configuration, ivy allows you to define what are called ivy variables. Ivy variables can be seen as ant properties, and are used in a very similar way. In particular, you use a properties tag in the configuration file to load a properties file containing ivy variables and their values.<br class="xooki-br"/><br class="xooki-br"/>But the main differences between ant properties and ivy variables are that ivy variables can be overridden, whereas ant <br class="xooki-br"/>properties can't, and that they are defined in separate environments.<br class="xooki-br"/><br class="xooki-br"/>Actually all ant properties are imported into ivy variables when the configuration is done (if you call ivy from ant). <br class="xooki-br"/>This means that if you define an ant property after the call to configure, it will not be available as an ivy variable.<br class="xooki-br"/>On the other hand, ivy variables are NOT exported to ant, thus if you define ivy variables in ivy, do not try to use them as ant properties.<br class="xooki-br"/><br class="xooki-br"/>To use ivy variables, you just have to follow the same syntax as for ant properties:<br class="xooki-br"/>${<i>variablename</i>}<br class="xooki-br"/>where <i>variablename</i> is the name of the variable.<br class="xooki-br"/><br class="xooki-br"/>Finally, it's also important to be aware of the time of substitution of variables. This substitution is done as soon as possible. This means that when ivy encounters a reference to a variable, it tries to substitute it if such a variable is defined. Consequently, <strong>any later modification of the variable will not alter the value already substituted</strong>.<br class="xooki-br"/><br class="xooki-br"/>Moreover, in an ant environment, a bunch of variables are going to be set by default via the ant property file loading mechanism (actually they are first loaded as ant properties and then imported as ivy variables, see <a href="ant.html">Ant Tasks</a>), and even in the ant properties themselves there is going to be eager substitution on loading, effectively making it impossible to override some variable purely via the ivysettings.properties file. Some variables will really only be able to be overridden via ant properties because of this.<br class="xooki-br"/><br class="xooki-br"/>Moreover, it's also important to understand the difference between ivy variables and ivy pattern tokens. <br class="xooki-br"/>See the Patterns chapter below for what pattern tokens are.<br class="xooki-br"/><h1><a name="patterns"></a>Patterns</h1>

Ivy patterns are used in many dependency resolvers and ivy tasks, and are a simple way to structure the way ivy works.<br class="xooki-br"/><br class="xooki-br"/>First let's give an example. You can for instance configure the file system dependency resolver by giving it<br class="xooki-br"/>a pattern to find artifacts. This pattern can be like this:<br class="xooki-br"/>myrepository/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]<br class="xooki-br"/><br class="xooki-br"/>This pattern indicates that the repository we use is in a directory called myrepository. <br class="xooki-br"/><br class="xooki-br"/>In this directory we have directories having for name the name of the organisation of the module we look for. <br class="xooki-br"/>Then we have a directory per module, each having for name the name of the module.<br class="xooki-br"/>Then in module directories we find a directory per artifact type (jars, wars, ivys, ...), in which we find artifacts named by the artifact id, followed by a hyphen, then the revision, a dot, and the artifact extension.<br class="xooki-br"/>Not too difficult to understand is it? That's it, you have understood the pattern concept!<br class="xooki-br"/><br class="xooki-br"/>To give a bit more explanation, a pattern is composed of tokens, which are replaced by actual values when evaluated for a particular artifact or module. Those tokens are different from variables because they are replaced differently for each artifact, whereas variables are usually given the same value.<br class="xooki-br"/><br class="xooki-br"/>You can mix variables and tokens in a pattern:<br class="xooki-br"/>${repository.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]<br/><br/>

The tokens available depends on where the pattern is used (will it be evaluated with artifacts or modules, for instance).<br class="xooki-br"/>But here are all the tokens currently available:
<ul>
<li>[organisation]</li> the organisation name
<li>[orgPath] <span class="since">(since 2.3)</span></li> the organisation name where '.' has been replaced by '/'. This can be used to configure maven2-like repositories. 
<li>[module]</li> the module name
<li>[branch]</li> the branch name
<li>[revision]</li> the revision name
<li>[artifact]</li> the artifact name (or id)
<li>[type]</li> the artifact type
<li>[ext]</li> the artifact file extension
<li>[conf]</li> the configuration name
<li>[originalname] <span class="since">(since 1.4)</span></li> the original artifact name (including the extension)
</ul>

The difference between type and extension is explained in the ivy file documentation.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.2</span> [organization] can be used instead of [organisation].<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> Optional parts can be used in patterns.<br class="xooki-br"/>This provides the possibility to avoid some input when a token is not defined, instead of having only the token as blank. Parenthesis are used to delimit the optional part, and only one token can be found inside the parenthesis.<br class="xooki-br"/>So if you surround a token with '(' and ')', any other text which is between the parenthesis will be ignored if the token has no value.<br class="xooki-br"/><br class="xooki-br"/>For instance, suppose the pattern: "abc(def[type]ghi)"<br class="xooki-br"/>type = "jar" -> the substituted pattern: abcdefjarghi<br class="xooki-br"/>type = null or "" -> the substitued pattern: abc<br class="xooki-br"/><br class="xooki-br"/>A more real life example:<br class="xooki-br"/>The pattern <pre>[artifact](-[revision]).[ext]</pre> lets you accept both myartifact-1.0.jar when a revision is set, and myartifact.jar (instead of myartifact-.jar) when no revision is set.<br class="xooki-br"/>This is particularly useful when you need to keep control of artifact names.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> Extra attributes can be used as any other token in a pattern.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="latest">Latest Strategy</a></h1>
Ivy often needs to know which revision between two is considered the "latest". To know that, it uses the concept of latest strategy. Indeed, there are several ways to consider a revision to be the latest. You can choose an existing one or plug in your own.<br class="xooki-br"/><br class="xooki-br"/>But before knowing which revision is the latest, ivy needs to be able to consider several revisions of a module. Thus ivy has to get a list of files in a directory, and it uses the dependency resolver for that. So check if the dependency resolver you use is compatible with latest revisions before wondering why ivy does not manage to get your latest revision.<br class="xooki-br"/><br class="xooki-br"/>Finally, in order to get several revisions of a module, most of the time you need to use the [revision] token in your pattern so that ivy gets all the files which match the pattern, whatever the revision is. It's only then that the latest strategy is used to determine which of the revisions is the latest one.<br class="xooki-br"/><br class="xooki-br"/>Ivy has three built-in latest strategies:
<ul>
<li>latest-time</li> This compares the revisions date to know which is the latest. While this is often a good strategy in terms of pertinence, it has the drawback of being costly to compute for distant repositories. If you use ivyrep, for example, ivy has to ask the http server what is the date of each ivy file before knowing which is the latest.
<li>latest-revision</li> This compares the revisions as strings, using an algorithm close to the one used in the php version_compare function.<br class="xooki-br"/>This algorithm takes into account special meanings of some text. For instance, with this strategy, 1.0-dev1 is considered before 1.0-alpha1, which in turn is before 1.0-rc1, which is before 1.0, which is before 1.0.1.
<li>latest-lexico</li> This compares the revisions as strings, using lexicographic order (the one used by the Java string comparison).
</ul>

See also how to configure new latest strategies <a href="settings/latest-strategies.html">here</a>.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="conflict">Conflict Manager</a></h1>
A conflict manager is able to select, among a list of module revisions in conflict, a list of revisions to keep.<br class="xooki-br"/>Yes, it can select a list of revisions, even if most conflict managers select only one revision.<br class="xooki-br"/>But in some cases you will need to keep several revisions, and load in separate class loaders, for example.<br class="xooki-br"/><br class="xooki-br"/>A list of revisions is said to be in conflict if they correspond to the same module, i.e. the same organisation/module name couple.<br class="xooki-br"/><br class="xooki-br"/>The list of available conflict managers is available on the <a href="settings/conflict-managers.html">conflict manager configuration page</a>.<br class="xooki-br"/><br class="xooki-br"/>For more details on how to setup your conflict managers by module, see the <a href="ivyfile/conflicts.html">conflicts</a> section in the ivy file reference.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="matcher">Pattern matcher</a></h1>
<span class="since">since 1.3</span>
In several places Ivy uses a pattern to match a set of objects. For instance, you can exclude several modules at once when declaring a dependency by using a pattern matching all the modules to exclude.<br class="xooki-br"/><br class="xooki-br"/>Ivy uses a pluggable pattern matcher to match those object names. 3 are defined by default:
<ul>
<li>exact</li>This matcher matches only using strings
<li>regexp</li>This matcher lets you use a regular expression as supported by the Pattern class of java 1.4 or greater
<li>glob</li>This matcher lets you use a Unix-like glob matcher, i.e. where the only meta characters are * which matches any sequence of characters and ? which matches exactly one character. Note that this matcher is available only with jakarta oro 2.0.8 in your classpath.
</ul>
Note also that with any matcher, the character '*' has the special meaning of matching anything. This is particularly useful with default values which do not depend on the matcher.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="extra">Extra attributes</a></h1>
<span class="since">since 1.4</span>
Several tags in ivy xml files are extensible with what is called extra attributes. <br class="xooki-br"/>The idea is very simple: if you need some more information to define your modules, you can add the attribute you want and you will then be able to access it as any other attribute in your patterns.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span>
It's possible and recommended to use xml namespaces for your extra attributes. Using an Ivy extra namespace is the easiest way to add your own extra attributes.<br class="xooki-br"/><br class="xooki-br"/>Example:<br class="xooki-br"/>Here is an ivy file with the attribute 'color' set to blue:
<pre>
&lt;ivy-module version="2.0" xmlns:e="<a href="http://ant.apache.org/ivy/extra">http://ant.apache.org/ivy/extra</a>"&gt;<br class="xooki-br"/>	&lt;info organisation="apache"<br class="xooki-br"/>	       module="foo"<br class="xooki-br"/>	       e:color="blue"<br class="xooki-br"/>	       status="integration"<br class="xooki-br"/>	       revision="1.59"<br class="xooki-br"/>	/&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
Then you must use the extra attribute when you declare a dependency on foo.  Those extra attributes <br class="xooki-br"/>will indeed be used as identifiers for the module like the org the name and the revision:
<pre>
&lt;dependency org="apache" name="foo" e:color="blue" rev="1.5+" /&gt;
</pre>
And you can define your repository pattern as:
<pre>
${repository.dir}/[organisation]/[module]/[color]/[revision]/[artifact].[ext]
</pre>

Note that in patterns you must use the unqualified attribute name (no namespace prefix).<br class="xooki-br"/><br class="xooki-br"/>If you don't want to use xml namespaces, it's possible but you will need to disable ivy file validation, since your files won't fulffill anymore the official ivy xsd. See the <a href="settings/settings.html">settings documentation</a> to see how to disable validation.<br class="xooki-br"/><h1><a name="checksum">Checksums</a></h1>
<span class="since">since 1.4</span>
Ivy allows the use of checksums, also known as digests, to verify the correctness of a downloaded file.<br class="xooki-br"/><br class="xooki-br"/>For the moment Ivy supports the md5 and sha1 algorithms.<br class="xooki-br"/><br class="xooki-br"/>The configuration of using md5 and/or sha1 can be done globally or by dependency resolver.<br class="xooki-br"/>Globally, use the ivy.checksums variable to list the check to be done (only md5 and sha1 are supported).<br class="xooki-br"/>On each resolver you can use the checksums attribute to override the global setting.<br class="xooki-br"/><br class="xooki-br"/>The setting is a comma separated list of checksum algorithms to use.<br class="xooki-br"/>During checking (at download time), the first checksum found is checked, and that's all. This means that if you have a "sha1, md5" setting, then if ivy finds a sha1 file, it will compare the downloaded file sha1 against this sha1, and if the comparison is ok, it will assume the file is ok. If no sha1 file is found, it will look for an md5 file. If none is found no checking is done.<br class="xooki-br"/>During publish, all listed checksum algorithms are computed and uploaded.<br class="xooki-br"/><br class="xooki-br"/>By default checksum algorithms are "sha1, md5".<br class="xooki-br"/><br class="xooki-br"/>If you want to change this default, you can set the variable ivy.checksums. Hence, to disable checksum validation you just have to set ivy.checksums to "".<br class="xooki-br"/><br class="xooki-br"/><h1><a name="event">Events and Triggers</a></h1>
<span class="since">since 1.4</span>
When Ivy performs the dependency resolution and some other tasks, it fires events before and after the most important steps. You can listen to these events using Ivy API, or you can even register a trigger to perform a particular action when a particular event occur.<br class="xooki-br"/><br class="xooki-br"/>This is a particularly powerful and flexible feature which allows, for example, you to perform a build of a dependency just before it is resolved, or follow what's happening during the dependency resolution process accuratly, and so on.<br class="xooki-br"/><br class="xooki-br"/>For more details about events and triggers, see the <a href="settings/triggers.html">triggers</a> documentation page in the configuration section of this documentation.<br class="xooki-br"/><br class="xooki-br"/><h1><a name="circular">Circular Dependencies</a></h1>
<span class="since">since 1.4</span>
Circular dependencies can be either direct or indirect. For instance, if A depends on A, it's a circular dependency, and if A depends on B which itself depends on A, this is also a circular dependency.<br class="xooki-br"/><br class="xooki-br"/>Prior to Ivy 1.4 circular dependencies where causing a failure in Ivy. As of Ivy 1.4, the behaviour of Ivy when it finds a circular dependency is configurable through a circular dependency strategy.<br class="xooki-br"/><br class="xooki-br"/>3 built-in strategies are available:
<ul>
<li>ignore</li> circular dependencies are only signaled in verbose messages
<li>warn</li> same as ignore, except that they are signaled as a warning (default)
<li>error</li> halt the dependency resolution when a circular dependency is found
</ul>

See the <a href="settings/settings.html">configuration page</a> to see how to configure the circular dependency strategy you want to use.<br class="xooki-br"/><br class="xooki-br"/><h1>Cache and Change Management</h1>
Ivy heavily relies on local caching to avoid accessing remote repositories too often, thus saving a lot of network bandwidth and time. <br class="xooki-br"/><br class="xooki-br"/><h2><a name="cache">Cache types</a></h2>
An Ivy cache is composed of two different parts:
<ul>
<li>the repository cache</li>
The repository cache is where Ivy stores data downloaded from module repositories, along with some meta information concerning these artifacts, like their original location.<br class="xooki-br"/>This part of the cache can be shared if you use a well suited <a href="settings/lock-strategies.html">lock strategy</a>. 
<li>the resolution cache</li>
This part of the cache is used to store resolution data, which is used by Ivy to reuse the results of a resolve process.<br class="xooki-br"/>This part of the cache is overwritten each time a new resolve is performed, and should never be used by multiple processes at the same time.
</ul>

While there is always only one resolution cache, you can <a href="settings/caches.html">define multiple repository caches</a>, each <a href="settings/resolvers.html">resolver</a> being able to use a separate cache.<br class="xooki-br"/><br class="xooki-br"/><h2><a name="change">Change management</a></h2>
To optimize the dependency resolution and the way the cache is used, Ivy assumes by default that a revision never changes. So once Ivy has a module in its cache (metadata and artifacts), it trusts the cache and does not even query the repository. This optimization is very useful in most cases, and causes no problem as long as you respect this paradigm: a revision never changes. Besides performance, there are several <a href="bestpractices.html">good reasons</a> to follow this principle.	<br class="xooki-br"/><br class="xooki-br"/>However, depending on your current build system and your dependency management strategy, you may prefer to update your modules sometimes. There are two kinds of changes to consider:<br class="xooki-br"/><h3>Changes in module metadata</h3>
Since pretty often module metadata are not considered by module providers with as much attention as their API or behavior (if they even provide module metadata), it happens more than we would like that we have to update module metadata: a dependency has been forgotten, or another one is missing, ...<br class="xooki-br"/><br class="xooki-br"/>In this case, setting checkModified="true" on your dependency resolver will be the solution. This flag tells Ivy to check if module metadata has been modified compared to the cache. Ivy first checks the metadata last modified timestamp on the repository to download it only if necessary, and then updates it when needed.<br class="xooki-br"/><h3>Changes in artifacts</h3>
Some people, especially those coming from maven 2 land, like to use one special revision to handle often updated modules. In maven 2 this is called a SNAPSHOT version, and some argue that it helps save disk space to keep only one version for the high number of intermediary builds you can make whilst developing.<br class="xooki-br"/><br class="xooki-br"/>Ivy supports this kind of approach with the notion of "changing revision". A changing revision is just that: a revision for which Ivy should consider that the artifacts may change over time. To handle this, you can either specify a dependency as changing on the <a href="ivyfile/dependency.html">dependency</a> tag, or use the changingPattern and changingMatcher attributes on your <a href="settings/resolvers.html">resolvers</a> to indicate which revision or group of revisions should be considered as changing.<br class="xooki-br"/><br class="xooki-br"/>Once Ivy knows that a revision is changing, it will follow this principle to avoid checking your repository too often: if the module metadata has not changed, it will considered the whole module (including artifacts) as not changed. Even if the module descriptor file has changed, it will check the publication data of the module to see if this is a new publication of the same revision or not. Then if the publication date has changed, it will check the artifacts' last modified timestamps, and download them accordingly.<br class="xooki-br"/><br class="xooki-br"/>So if you want to use changing revisions, use the <a href="use/publish.html">publish</a> task to publish your modules, it will take care of updating the publication date, and everything will work fine. And remember to set checkModified=true" on your resolver too!<br class="xooki-br"/><h1><a name="paths">Paths handling</a></h1>
As a dependency manager, Ivy has a lot of file related operations, which most of the time use paths or path patterns to locate the file on the filesystem.<br class="xooki-br"/><br class="xooki-br"/>These paths can obviously be relative or absolute. We recommend to always use absolute paths, so that you don't have to worry about what is the base of your relative paths. Ivy provides some variables which can be used as the base of your absolute paths. For instance, Ivy has a concept of base directory, which is basically the same as for Ant. You have access to this base directory with the ivy.basedir variable. So if you have a path like <pre>${ivy.basedir}/ivy.xml</pre>, you have an absolute path. In <a href="settings.html">settings files</a>, you also have a variable called ivy.settings.dir which points to the directory in which your settings file is located, which makes defining paths relative to this directory very easy.<br class="xooki-br"/><br class="xooki-br"/>If you really want to use relative paths, the base directory used to actually locate the file depends on where the relative path is defined:
<ul>
<li>In an Ivy file, paths are relative to the Ivy file itself (the only possible path in an Ivy file is for configurations declaration inclusion)</li>
<li>In settings files, paths for file inclusion (namely properties file loading and settings inclusion) are relative to the directory in which the settings file is located. All other paths must be absolute unless explicitly noted.</li>
<li>In Ivy Ant tasks and Ivy parameters or options, paths are relative to Ivy base directory, which when called from Ant is the same as your Ant basedir.</li>
</ul><hr/><div class='toc-title toc-title-4'>Text Conventions</div><br class="xooki-br"/>Very often some concepts discussed in Ivy here, and especially those involving modules and dependencies, require to be discussed by text (e-mail, textual doc, console, ...), and so benefit from convention in this area.<br class="xooki-br"/><br class="xooki-br"/>The conventions have been adopted with Ivy 2.0 are the following:
<table>
<thead style="font-weight:700;">
<tr>
<td>
what<br class="xooki-br"/></td><td>
pattern<br class="xooki-br"/></td><td>
example<br class="xooki-br"/></td>
</tr>
</thead>
<tbody>
<tr>
<td>
a module without revision<br class="xooki-br"/></td><td>
<i>[organisation]</i>#<i>[module]</i><br class="xooki-br"/></td><td>
org.apache.ant#ant<br class="xooki-br"/></td>
</tr>
<tr>
<td>
a module with revision<br class="xooki-br"/></td><td>
<i>[organisation]</i>#<i>[module]</i>;<i>[revision]</i><br class="xooki-br"/></td><td>
org.apache.ant#ant;1.7.0<br class="xooki-br"/></td>
</tr>
<tr>
<td>
a module with (some) configurations<br class="xooki-br"/></td><td>
<i>[organisation]</i>#<i>[module]</i>[ <i>[confs]</i> ]<br class="xooki-br"/></td><td>
org.apache.ant#ant[master,compile,build]<br class="xooki-br"/></td>
</tr>
<tr>
<td>
a module with revision and (some) configurations<br class="xooki-br"/></td><td>
<i>[organisation]</i>#<i>[module]</i>;<i>[revision]</i>[ <i>[confs]</i> ]<br class="xooki-br"/></td><td>
org.apache.ant#ant;1.7.0[master,compile,build]<br class="xooki-br"/></td>
</tr>
<tr>
<td>
a module's artifact<br class="xooki-br"/></td><td>
<i>[organisation]</i>#<i>[module]</i>!<i>[artifact]</i>.<i>[ext]</i>(<i>[type]</i>)<br class="xooki-br"/></td><td>
org.apache.ant#ant!ant.jar(source)<br class="xooki-br"/></td>
</tr>
<tr>
<td>
a module's artifact with revision<br class="xooki-br"/></td><td>
<i>[organisation]</i>#<i>[module]</i>;<i>[revision]</i>!<i>[artifact]</i>.<i>[ext]</i>(<i>[type]</i>)<br class="xooki-br"/></td><td>
org.apache.ant#ant;1.7.0!ant.jar(source)<br class="xooki-br"/></td>
</tr>
<tbody>
</table>
<br/>
Another usual text representation used is to represent dependencies using a dash followed by greater than sign: -><br class="xooki-br"/><br class="xooki-br"/>To group a set of set of modules, we recommend using curly braces { }<br class="xooki-br"/><br class="xooki-br"/>With these conventions, it's easy to give a concise and detailed overview of a set of modules and their dependencies.<br class="xooki-br"/><br class="xooki-br"/>For instance:
<pre>
#A;2-> { #B;[1.0,1.5] #C;[2.0,2.5] }<br class="xooki-br"/>#B;1.4->#D;1.5<br class="xooki-br"/>#B;1.5->#D;2.0<br class="xooki-br"/>#C;2.5->#D;[1.0,1.6]
</pre>
In full words here is how it could be written:
<pre>
module A revision 2 depends on module B with the version constraint [1.0,1.5], and on module C with the version constraint [2.0,2.5].<br class="xooki-br"/>module B revision 1.4 depends on module D revision 1.5.<br class="xooki-br"/>module B revision 1.5 depends on module D revision 2.0.<br class="xooki-br"/>module C revision 2.5 depends on module D with the version constraint [1.0,1.6].
</pre>

As you can see, using text conventions is much more concise. <br class="xooki-br"/><br class="xooki-br"/>Another benefit is that these conventions are usually used in Ivy console output, and can also be used in some cases to be parsed into Ivy objects (we use it for test cases for instance). To make sure text parsing works fine, we recommend using only a limited range of characters for each attributes of your module identifiers.<br class="xooki-br"/><br class="xooki-br"/>Here is the recommended characters set for each attribute:
<ul>
<li>organisation</li> a-z A-Z 0-9 - / . _ + =
<li>module</li> a-z A-Z 0-9 - / . _ + =
<li>branch</li> a-z A-Z 0-9 - / . _ + =
<li>revision</li> a-z A-Z 0-9 - / . _ + = , [ ] { } ( ) : @
<li>artifact</li> a-z A-Z 0-9 - / . _ + =
<li>extension</li> a-z A-Z 0-9 - / . _ + =
<li>type</li> a-z A-Z 0-9 - / . _ + =
</ul>
<hr/><div class='toc-title toc-title-4'>How does it work ?</div><br class="xooki-br"/>Now that you have been introduced to the main ivy terminology and concepts, it is time to give some explanation of how ivy works.<br class="xooki-br"/><br class="xooki-br"/><h1>Usual cycle of modules between different locations</h1>
<center><img src="images/main-tasks.png" /></center>
More details on ant tasks <a href="ant.html">here</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>Configure</h1>
Ivy needs to be configured to be able to resolve your dependencies. This configuration is usually done with a settings file, which defines a set of dependency resolvers. Each resolver is able to find ivy files and/or artifacts, given simple information such as organisation, module, revision, artifact name, artifact type and artifact extension. <br class="xooki-br"/><br class="xooki-br"/>The configuration is also responsible for indicating which resolver should be used to resolve which module. This configuration is dependent only on your environment, i.e. where the modules and artifacts can be found. <br class="xooki-br"/><br class="xooki-br"/>A default configuration is used by ivy when none is given. This configuration uses an <a href="resolver/ibiblio.html">ibiblio resolver</a> pointing to <a href="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</a> to resolve all modules.<br class="xooki-br"/><h1>Resolve</h1>
The resolve time is the moment when ivy actually resolves the dependencies of one module. It first needs to access the ivy file of the module for which it resolves the dependencies. <br class="xooki-br"/><br class="xooki-br"/>Then, for each dependency declared in this file, it asks the appropriate resolver (according to settings) to find the module (i.e. either an ivy file for it, or its artifacts if no ivy file can be found). It also uses a filesystem based cache to avoid asking for a dependency if it is already in cache (at least if possible, which is not the case with latest revisions).<br class="xooki-br"/><br class="xooki-br"/>If the resolver is a composite one (i.e. a chain or a dual resolver), several resolvers may actually be called to find the module.<br class="xooki-br"/><br class="xooki-br"/>When the dependency module has been found, its ivy file is downloaded to the ivy cache. Then ivy checks if the dependency module has dependencies, in which case it recursilvely traverses the graph of dependencies. <br class="xooki-br"/><br class="xooki-br"/>All over this traversal, conflict management is done to prevent access to a module as soon as possible.<br class="xooki-br"/><br class="xooki-br"/>When ivy has traversed the whole graph, it asks the resolvers to download the artifacts corresponding to each of the dependencies which are not already in the cache and which have not been evicted by conflict managers. All downloads are made to the ivy cache.<br class="xooki-br"/><br class="xooki-br"/>Finally, an xml report is generated in the cache, which allows ivy to easily know what are all the dependencies of a module, without traversing the graph again.<br class="xooki-br"/><br class="xooki-br"/>After this resolve step, two main steps are possible: either build a path with artifacts in the cache, or copy them to another directory structure.<br class="xooki-br"/><br class="xooki-br"/><h1>Retrieve</h1>
What is called retrieve in ivy is the act of copying artifacts from the cache to another directory structure. This is done using a pattern, which indicates to ivy where the files should be copied.<br class="xooki-br"/><br class="xooki-br"/>For this, ivy uses the xml report in the cache corresponding to the module it should retrieve to know which artifacts should be copied.<br class="xooki-br"/><br class="xooki-br"/>It also checks if the files are not already copied to maximize performances.<br class="xooki-br"/><h1>Building a path from the cache</h1>
In some cases, it is preferable to use artifacts directly from the cache. Ivy is able to use the xml report generated at resolve time to build a path of all artifacts required.<br class="xooki-br"/><br class="xooki-br"/>This can be particularly useful when building plug-ins for IDEs.<br class="xooki-br"/><br class="xooki-br"/><h1>Reports</h1>
Ivy is also able to generate readable reports describing the dependencies resolution.<br class="xooki-br"/><br class="xooki-br"/>This is done with a simple xsl transformation of the xml report generated at resolve time.<br class="xooki-br"/><br class="xooki-br"/><h1>Publish</h1>
Finally, Ivy can be used to publish a particular version of a module in your repository, so that it becomes available for future resolving. This task is usually called either manually or from a continuous integration server.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>Best practices</div><br class="xooki-br"/>Here are some recommendations and best practices we have gathered throughout our experience and consultancies with our customers.<br class="xooki-br"/><br class="xooki-br"/><h1>Add module descriptors for all your modules</h1>
In Ivy world, module descriptors are ivy files, which are basically simple xml files describing both what the module produces as artifacts and its dependencies.<br class="xooki-br"/><br class="xooki-br"/>It is a good practice to write or download module descriptors for all the modules involved in your development, even for your third party dependencies, and even if they don't provide such module descriptors themselves.<br class="xooki-br"/><br class="xooki-br"/>First, it will seem like extra work and require time. But when you have several modules using the same third party library, then you will only need to add one line to your ivy file to get this library and all its own dependencies that you really need (if you have good module descriptors in your repository, especially with the use of module <a href="concept.html#configurations">configurations</a>). It will also be very helpful when you want to upgrade a dependency. One single change in your module ivy file and you will get the updated version with its updated (or not) dependencies.<br class="xooki-br"/><br class="xooki-br"/>Therefore we recommend adding ivy files for all the modules in your repository. You can even enforce this rule by setting the descriptor attribute to required on your <a href="settings/resolvers.html">resolvers</a>. Hence you shouldn't need to use the dependency artifact inclusion/exclusion/specification feature of Ivy, which should only be used in very specific cases.<br class="xooki-br"/><br class="xooki-br"/><h1>Use your own enterprise repository</h1>
This is usually not a valid recommendation for open source projects, but for the enterprise world we strongly suggest to avoid relying on a public repository like maven ibiblio or ivyrep. Why? Well, there are a couple of reasons:
<ul>
<li>control</li> The main problem with these kinds of public repositories is that you don't have control over the repository. This means that if a module descriptor is broken you cannot easily fix it. Sure you can use a chain between a shared repository and the public one and put your fixed module descriptor in the shared repository so that it hides the one on the public repository, but this makes repository browsing and maintenance cumbersome. <br class="xooki-br"/>Even more problematic is the possible updates of the repository. We know that versions published in such repositories should be stable and not be updated, but we also frequently see that a module descriptor is buggy, or an artifact corrupted. We even see sometimes a new version published with the same name as the preceding one because the previous one was simply badly packaged. This can occur even to the best; it occurred to us with Ivy 1.2 :-) But then we decided to publish the new version with a different name, 1.2a. But if the repository manager allows such updates, this means that what worked before can break. It can thus break your build reproducibility.
<li>reliability</li> The Maven repository is not particularly well known for its reliability (we often experience major slow downs or even complete failures of the site), and ivyrep is only supported by a small company (yes we are only a small company!). So slow down and site hangs occur also. And if the repository you rely on is down, this can cause major slow downs in your development or release process.
<li>accuracy</li> A public repository usually contains much more than what you actually need. Is this a problem? We think so. We think that in an enterprise environment the libraries you use should step through some kind of validation process before being used in every projects of your company. And what better way to do so? Setup an enterprise repository with only the libraries you actually want to use. This will not only ensure better quality for your application dependencies, but help to have the same versions everywhere, and even help when declaring your module dependencies, if you use a tool like IvyDE, the code completion will only show relevant information about your repository, with only the libraries you actually want to see.
<li>security</li> The artifacts you download from a module repository are often executable, and are thus a security concern. Imagine a hacker replacing commons-lang by another version containing a virus? If you rely on a public repository to build your software, you expose it to a security risk. You can read more about that in this <a href="http://www.fortifysoftware.com/servlet/downloads/public/fortify_attacking_the_build.pdf">Forrester article</a>.
</ul>
Note that using an enterprise repository doesn't mean you have to build it entirely by hand. Ivy features an <a href="use/install.html">install</a> task which can be used to install modules from one repository to another one, so it can be used to selectively install modules from a public repository to your enterprise repository, where you will then be able to ensure control, reliability and accuracy.<br class="xooki-br"/><br class="xooki-br"/><h1>Always use patterns with at least organisation and module</h1>
Ivy is very flexible and can accomodate a lot of existing repositories, using the concept of <a href="concept.html#pattern">patterns</a>. But if your repository doesn't exist yet, we strongly recommend always using the organisation and the module name in your pattern, even for a private repository where you put only your own modules (which all have the same organisation). Why? Because the Ivy listing feature relies on the token it can find in the pattern. If you have no organisation token in your pattern, Ivy won't be able to list the (only?) organisation in your repository. And this can be a problem for code completion in IvyDE, for example, but also for repository wide tasks like <a href="use/install.html">install</a> or <a href="use/repreport.html">repreport</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>Public ivysettings.xml with public repositories</h1>
If you create a public repository, provide a URL to the <a href="settings.html">ivysettings.xml</a> file. It's pretty easy to do, and if someone wants to leverage your repository, he will just have to load it with <a href="use/settings.html">settings</a> with the URL of your ivysettings.xml file, or <a href="configuration/include.html">include</a> it in its own configuration file, which makes it really easy to combine several public repositories.<br class="xooki-br"/><br class="xooki-br"/><h1>Dealing with integration versions</h1>
Very often, especially when working in a team or with several modules, you will need to rely on intermediate, non-finalized versions of your modules. These versions are what we call integration versions, because their main objective is to be integrated with other modules to make and test an application or a framework. <br class="xooki-br"/><br class="xooki-br"/>If you follow the continuous integration paradigm across modules, these integration versions can be produced by a continuous integration server, very frequently.<br class="xooki-br"/><br class="xooki-br"/>So, how can you deal with these, possibly numerous, integration versions?<br class="xooki-br"/><br class="xooki-br"/>There are basically two ways to deal with them, both ways being supported by Ivy:
<ul>
<li>use a naming convention like a special suffix</li> the idea is pretty simple, each time you publish a new integration of your module you give the same name to the version (in maven world this is for example 1.0-SNAPSHOT). The dependency manager should then be aware that this version is special because it changes over time, so that it does not trust its local cache if it already has the version, but checks the date of the version on the repository and sees if it has changed. In Ivy this is supported using the <a href="ivyfile/dependency.html">changing attribute</a> on a dependency or by configuring the <a href="configuration/resolvers.html">changing pattern</a> to use for all your modules.
<li>automatically create a new version for each</li> in this case you use either a build number or a timestamp to publish each new integration version with a new version name. Then you can use one of the numerous ways in Ivy to <a href="ivyfile/dependency.html">express a version constraint</a>. Usually selecting the very latest one (using 'latest.integration' as version constraint) is enough.
</ul>

So, which way is the best? As often, it depends on your context, and if one of the two was really bad it wouldn't be supported in Ivy :-)<br class="xooki-br"/><br class="xooki-br"/>But usually we recommend using the second one, because using a new version each time you publish a new version better fits the version identity paradigm, and can make <b>all</b> your builds reproducible, even integration ones. And this is interesting because it enables, with some work in your build system, the ability to introduce a mechanism to promote an integration build to a more stable status, like a milestone or a release. <br class="xooki-br"/><br class="xooki-br"/>Imagine you have a customer who comes on a Monday morning and asks for the latest version of your software, for testing or demonstration purposes. Obviously he needs it for the afternoon :-) Now if you have a continuous integration process and good tracking of your changes and your artifacts, it may occur to you that you are actually able to fulfill his request without needing the use of a DeLorean to give you some more time :-) But it may also occur to you that your latest version is stable enough to be used for the purpose of the customer, but was actually built a few days ago, because the very latest just broke a feature or introduced a new one you don't want to deliver. You can deliver this 'stable' integration build if you want, but rest assured that a few days, or weeks, or even months later, the customer will ask for a bug fix on this demo only version. Why? Because it's a customer, and we all know how they are :-)<br class="xooki-br"/><br class="xooki-br"/>So, with a build promotion feature of any build in your repository, the solution would be pretty easy: when the customer asks for the version, you not only deliver the integration build, but you also promote it to a milestone status, for example. This promotion indicates that you should keep track of this version for a long period, to be able to come back to it and create a branch if needed.<br class="xooki-br"/><br class="xooki-br"/>Unfortunately Ivy does not by its own allow you to have such reproducible builds out of the box, simply because Ivy is a dependency manager, not a build tool. But if you publish only versions with a distinct name and use Ivy features like versions constraint replacement during the publication or recursive delivery of modules, it can really help.<br class="xooki-br"/><br class="xooki-br"/>On the other hand, the main drawback of this solution is that it can produce a lot of intermediate versions, and  you will have to run some cleaning scripts in your repository unless your company name starts with a G and ends with oogle :-)<br class="xooki-br"/><br class="xooki-br"/><h1>Inlining dependencies or not?</h1>
With Ivy 1.4 you can resolve a dependency without even writing an ivy file. This pratice is called inlining. But what is it good for, and when should it be avoided?<br class="xooki-br"/><br class="xooki-br"/>Putting ivy dependencies in a separate file has the following advantages:
<ul>
<li>separate revision cycle</li> if your dependencies may change more often than your build, it's a good idea to separate the two, to isolate the two concepts: describing how to build / describing your project dependencies
<li>possibility to publish</li> if you describe dependencies of a module which can itself be reused, you may want to use ant to publish it to a repository. In this case the publication is only possible if you have a separate ivy file
<li>more flexible</li> inline dependencies can only be used to express one dependency and only one. An ivy file can be used to express much more complex dependencies
</ul>
On the other hand, using inline dependencies is very useful when:
<ul>
<li>you want to use a custom task in your ant build</li> Without ivy you usually either copy the custom task jar in ant lib, which requires maintenance of your workstation installation, or use a manual copy or download and a taskdef with the appropriate classpath, which is better. But if you have several custom tasks, or if they have themselves dependencies, it can become cumbersome. Using Ivy with an inline dependency is an elegant way to solve this problem.
<li>you want to easily deploy an application</li> If you already build your application and its modules using Ivy, it is really easy to leverage your ivy repository to download your application and all its dependencies on the local filesystem, ready to be executed. If you also put your configuration files as artifacts in your repository (maybee packaged as a zip), the whole installation process can rely on ivy, easing the automatic installation of <b>any</b> version of your application available in your repository!
</ul>
<h1>Hire an expert</h1>
Build and dependency management is often given too low a priority in the software development world. We often see build management implemented by developers when they have time. Even if this may seem like a time and money savings in the short term, it often turns out to be a very bad choice in the long term. Building software is not a simple task, when you want to ensure automatic, tested, fully reproducible builds, releases and installations. On the other hand, once a good build system fitting your very specific needs is setup, it can then only rely on a few people with a good understanding of what is going on, with a constant quality ensured. <br class="xooki-br"/><br class="xooki-br"/>Therefore hiring a build and dependency expert to analyse and improve your build and release system is most of the time a very good choice.<br class="xooki-br"/><br class="xooki-br"/><h1>Feedback</h1>
These best practices reflect our own experience, but we do not pretend to own the unique truth about dependency management or even Ivy use.<br class="xooki-br"/><br class="xooki-br"/>So feel free to comment on this page to add your own experience feedback, suggestions or opinion.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>Installation</div><br class="xooki-br"/>There are basically two ways to install Ivy: either manually or automatically.<br class="xooki-br"/><h1>Manually</h1>
Download the version you want here, unpack the downloaded zip file wherever you want, and copy the ivy jar file into your ant lib directory (ANT_HOME/lib).<br class="xooki-br"/><br class="xooki-br"/>If you use ant 1.6.0 or superior, you can then simply go to the src/example/hello-ivy dir and run ant: if the build is successful, you have successfully installed Ivy!<br class="xooki-br"/><br class="xooki-br"/>If you use ant 1.5.1 or superior, you have to modify the build files in the examples:<br class="xooki-br"/>- remove the namespace section at their head: xmlns:ivy="antlib:org.apache.ivy.ant" <br class="xooki-br"/>- add taskdefs for ivy tasks:
<pre>
  &lt;taskdef name="ivy-configure" classname="org.apache.ivy.ant.IvyConfigure"/&gt;<br class="xooki-br"/>  &lt;taskdef name="ivy-resolve" classname="org.apache.ivy.ant.IvyResolve"/&gt;<br class="xooki-br"/>  &lt;taskdef name="ivy-retrieve" classname="org.apache.ivy.ant.IvyRetrieve"/&gt;<br class="xooki-br"/>  &lt;taskdef name="ivy-publish" classname="org.apache.ivy.ant.IvyPublish"/&gt; 
</pre>
- replace ivy:xxx tasks by ivy-xxx<br class="xooki-br"/>You can now run the build, if it is successful, you have successfully installed Ivy!<br class="xooki-br"/><br class="xooki-br"/>If the build is not successful, check the FAQ to see what might be the problem with the ivyrep resolver.<br class="xooki-br"/><br class="xooki-br"/><h2>Ivy dependendencies</h2>

One of the two binary versions of Ivy doesn't include the optional dependencies. To download them using Ivy, all you need is to run the Ant build file provided in the distribution. This will use Ivy itself to download the dependencies. Then you should see the Ivy optional dependencies in the lib directory, organized per configuration (see the ivy.xml for details about the configurations and their use).<br class="xooki-br"/><br class="xooki-br"/><h1>Automatically</h1>
If you want to use Ivy only in your ant build scripts, and have an internet connection when you build, you can download Ivy from this site and use the downloaded version automatically, using this simple build snippet:
<pre>
    &lt;property name="ivy.install.version" value="2.1.0-rc2" /&gt;<br class="xooki-br"/>    &lt;condition property="ivy.home" value="${env.IVY_HOME}"&gt;<br class="xooki-br"/>      &lt;isset property="env.IVY_HOME" /&gt;<br class="xooki-br"/>    &lt;/condition&gt;<br class="xooki-br"/>    &lt;property name="ivy.home" value="${user.home}/.ant" /&gt;<br class="xooki-br"/>    &lt;property name="ivy.jar.dir" value="${ivy.home}/lib" /&gt;<br class="xooki-br"/>    &lt;property name="ivy.jar.file" value="${ivy.jar.dir}/ivy.jar" /&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="download-ivy" unless="offline"&gt;<br class="xooki-br"/><br class="xooki-br"/>        &lt;mkdir dir="${ivy.jar.dir}"/&gt;<br class="xooki-br"/>        &lt;!-- download Ivy from web site so that it can be used even without any special installation --&gt;<br class="xooki-br"/>        &lt;get src="http://repo2.maven.org/maven2/org/apache/ivy/ivy/${ivy.install.version}/ivy-${ivy.install.version}.jar" <br class="xooki-br"/>             dest="${ivy.jar.file}" usetimestamp="true"/&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="init-ivy" depends="download-ivy"&gt;<br class="xooki-br"/>      &lt;!-- try to load ivy here from ivy home, in case the user has not already dropped<br class="xooki-br"/>              it into ant's lib dir (note that the latter copy will always take precedence).<br class="xooki-br"/>              We will not fail as long as local lib dir exists (it may be empty) and<br class="xooki-br"/>              ivy is in at least one of ant's lib dir or the local lib dir. --&gt;<br class="xooki-br"/>        &lt;path id="ivy.lib.path"&gt;<br class="xooki-br"/>            &lt;fileset dir="${ivy.jar.dir}" includes="*.jar"/&gt;<br class="xooki-br"/><br class="xooki-br"/>        &lt;/path&gt;<br class="xooki-br"/>        &lt;taskdef resource="org/apache/ivy/ant/antlib.xml"<br class="xooki-br"/>                 uri="antlib:org.apache.ivy.ant" classpathref="ivy.lib.path"/&gt;<br class="xooki-br"/>    &lt;/target&gt;
</pre>

Then the only thing to do is to add the init-ivy target in the depends attribute of your targets using Ivy, and add the ivy namespace to your build script. See the self contained <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/example/go-ivy/build.xml">go-ivy</a> example for details about this.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-3'>Settings Files</div><br class="xooki-br"/>In order to work as you want, ivy sometimes needs some settings. Actually, ivy can work with no specific settings at all, see the <a href="tutorial/defaultconf.html">default settings documentation</a> for details about that. But ivy is able to work in very different contexts. You just have to configure it properly.<br class="xooki-br"/><br class="xooki-br"/>Settings are specified through an xml file, usually called ivysettings.xml. To configure ivy from ant, you just have to use the <a href="use/settings.html">settings</a> datatype with the path of your settings file.<br class="xooki-br"/><br class="xooki-br"/>Here is an example of the settings file:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>        &lt;properties file="${ivy.settings.dir}/ivysettings-file.properties" /&gt;<br class="xooki-br"/>        &lt;settings defaultResolver="ibiblio" /&gt;<br class="xooki-br"/>        &lt;caches  defaultCacheDir="${cache.dir}" checkUpToDate="false" /&gt;<br class="xooki-br"/>        &lt;resolvers&gt;<br class="xooki-br"/>                &lt;ibiblio name="ibiblio" /&gt;<br class="xooki-br"/>                &lt;filesystem name="internal"&gt;<br class="xooki-br"/>                        &lt;ivy pattern="${repository.dir}/[module]/ivy-[revision].xml" /&gt;<br class="xooki-br"/>                        &lt;artifact pattern="${repository.dir}/[module]/[artifact]-[revision].[ext]" /&gt;<br class="xooki-br"/>                &lt;/filesystem&gt;<br class="xooki-br"/>        &lt;/resolvers&gt;<br class="xooki-br"/>        &lt;modules&gt;<br class="xooki-br"/>                &lt;module organisation="jayasoft" name=".*" resolver="internal" /&gt;<br class="xooki-br"/>        &lt;/modules&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

<br/>
Mainly, the settings enable you to configure the default cache directory used by ivy and the dependency resolvers that it will use to resolve dependencies.<br class="xooki-br"/><i>Note: To work, this settings file needs a property file named ivysettings-file.properties in the same directory as the settings file, with ivy variables you want in it.</i><br class="xooki-br"/><br class="xooki-br"/>Some useful variables are available in settings files:
<ul>
<li>ivy.settings.dir</li> this variable references the directory in which the ivysettings itself is. This is available if the settings has been loaded as a file. In case of a URL, it takes the part before the last slash of the URL, if any. If the URL has no slash, then this variable is not set.
<li>ivy.settings.file</li> the path of the settings file itself if it has been loaded as a file only. If it has been loaded as a URL, this variable is not set
<li>ivy.settings.url</li> the URL pointing to the settings file. This is set both when it has been loaded as a file or a URL
</ul>

<span class="since">since 1.4</span> Note that all <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/System.html#getProperties()">java system properties</a> are available as ivy variables in your settings file.<br class="xooki-br"/><br class="xooki-br"/><h1>Settings file structure</h1>

The settings file is structured in some parts and left open in others. Indeed, each resolver has its own structure, thus it's not the settings file itself which defines the structure for the resolvers.<br class="xooki-br"/>
<pre>
ivysettings<br class="xooki-br"/>    <a href="settings/property.html">property</a><br class="xooki-br"/>    <a href="settings/properties.html">properties</a><br class="xooki-br"/>    <a href="settings/settings.html">settings</a><br class="xooki-br"/>    <a href="settings/include.html">include</a><br class="xooki-br"/>    <a href="settings/classpath.html">classpath</a><br class="xooki-br"/>    <a href="settings/typedef.html">typedef</a><br class="xooki-br"/>    <a href="settings/credentials.html">credentials</a><br class="xooki-br"/>    <a href="settings/lock-strategies.html">lock-strategies</a><br class="xooki-br"/>    <a href="settings/caches.html">caches</a><br class="xooki-br"/>        <a href="settings/caches/cache.html">cache</a><br class="xooki-br"/>    <a href="settings/latest-strategies.html">latest-strategies</a><br class="xooki-br"/>    <a href="settings/version-matchers.html">version-matchers</a><br class="xooki-br"/>    <a href="settings/triggers.html">triggers</a><br class="xooki-br"/>    <a href="settings/parsers.html">parsers</a><br class="xooki-br"/>    <a href="settings/conflict-managers.html">conflict-managers</a><br class="xooki-br"/>    <a href="settings/outputters.html">outputters</a><br class="xooki-br"/>    <a href="settings/namespaces.html">namespaces</a><br class="xooki-br"/>        <a href="settings/namespace.html">namespace</a><br class="xooki-br"/>            <a href="settings/namespace/rule.html">rule</a><br class="xooki-br"/>                <a href="settings/namespace/fromtosystem.html">fromsystem</a><br class="xooki-br"/>                    <a href="settings/namespace/src.html">src</a><br class="xooki-br"/>                    <a href="settings/namespace/dest.html">dest</a><br class="xooki-br"/>                <a href="settings/namespace/fromtosystem.html">tosystem</a><br class="xooki-br"/>                    <a href="settings/namespace/src.html">src</a><br class="xooki-br"/>                    <a href="settings/namespace/dest.html">dest</a><br class="xooki-br"/>    <a href="settings/macrodef.html">macrodef</a><br class="xooki-br"/>        <a href="settings/macrodef/attribute.html">attribute</a><br class="xooki-br"/>        any resolver<br class="xooki-br"/>    <a href="settings/resolvers.html">resolvers</a><br class="xooki-br"/>        any resolver<br class="xooki-br"/>    <a href="settings/modules.html">modules</a><br class="xooki-br"/>        <a href="settings/module.html">module</a><br class="xooki-br"/>    <a href="settings/statuses.html">statuses</a><br class="xooki-br"/>        <a href="settings/status.html">status</a>
</pre>

<h1>ivysettings</h1>
<b>Tag:</b> ivysettings<br class="xooki-br"/><br class="xooki-br"/>Root tag of any ivysettings file.<br class="xooki-br"/><h2>Child elements</h2>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/property.html">property</a></td><td>set an ivy variable</td>
        <td>0..n</td></tr>
    <tr><td><a href="settings/properties.html">properties</a></td><td>loads a properties file as ivy variables</td>
        <td>0..n</td></tr>
    <tr><td><a href="settings/settings.html">settings</a></td><td>configures ivy with some defaults</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/include.html">include</a></td><td>includes another settings file</td>
        <td>0..n</td></tr>
    <tr><td><a href="settings/classpath.html">classpath</a></td><td>add a location in the classpath used to load plugins</td>
        <td>0..n</td></tr>
    <tr><td><a href="settings/typedef.html">typedef</a></td><td>defines new types in ivy</td>
        <td>0..n</td></tr>
    <tr><td><a href="settings/lock-strategies.html">lock-strategies</a></td><td>defines lock strategies</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/caches.html">caches</a></td><td>defines repository cache managers</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/latest-strategies.html">latest-strategies</a></td><td>defines latest strategies</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/parsers.html">parsers</a></td><td>defines module descriptor parsers</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/version-matchers.html">version-matchers</a></td><td>defines new version matchers</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/triggers.html">triggers</a></td><td>register triggers on ivy events</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/namespaces.html">namespaces</a></td><td>defines new namespaces</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/macrodef.html">macrodef</a></td><td>defines a new macro resolver</td>
        <td>0..n</td></tr>
    <tr><td><a href="settings/resolvers.html">resolvers</a></td><td>defines dependency resolvers</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/conflict-managers.html">conflict-managers</a></td><td>defines conflicts managers</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/modules.html">modules</a></td><td>defines rules between modules and dependency resolvers</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/outputters.html">outputters</a></td><td>defines the list of available report outputters</td>
        <td>0..1</td></tr>
    <tr><td><a href="settings/statuses.html">statuses</a></td><td>defines the list of available statuses</td>
        <td>0..1</td></tr>
</tbody>
</table><hr/><div class='toc-title toc-title-4'>property</div><br class="xooki-br"/><b>Tag:</b> property<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.property">Defines an ivy variable.</span> <span class="since">since 1.3</span>

The optional override attribute enables you to avoid overriding the previous value of the variable, which makes the definition behave like an ant property, which is particularly useful to define default values (values which are used only if they haven't been defined yet).<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the variable to define</td>
        <td>Yes</td></tr>
    <tr><td>value</td><td>the new value the variable must take</td>
        <td>Yes</td></tr>
    <tr><td>override</td><td>true if the previous value (if any) of the variable should overriden, false otherwise</td>
        <td>No, defaults to true</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;property name="myvar" value="myvalue"/&gt;
</pre>
Sets the variable myvar to the value myvalue.<br class="xooki-br"/><hr/>
<pre>
&lt;property name="myvar" value="myvalue" override="false"/&gt;
</pre>
Sets the variable myvar to the value myvalue only if myvar has not been set yet.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>properties</div><br class="xooki-br"/><b>Tag:</b> properties<br/>
<br/>
<span class="tagdoc" id="ivysettings.properties">Loads a properties file into ivy variables.</span> See the variables chapter above for details about ivy variables.<br class="xooki-br"/><br class="xooki-br"/><span class="since">Since 2.0</span>: it is possible to access environment variables. This can be done by specifying the environment attribute. This attribute specifies the prefix which can be used to access these environment variables. For instance, if you specify environment="env", you can access the PATH environment variable with the env.PATH property name.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>a path to a properties file to load</td>
        <td rowspan="2">One of these</td></tr>
    <tr><td>environment</td><td>the prefix to use when retrieving environment variables <span class="since">(since 2.0)</span></td></tr>
    <tr><td>override</td><td>indicates if the variable found in the properties file should override its previous value, if any <span class="since">(since 1.3)</span></td>
        <td>No, defaults to true</td></tr>
</tbody>
</table>


	<hr/><div class='toc-title toc-title-4'>settings</div><br class="xooki-br"/><b>Tag:</b> settings<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.settings">Configures some important ivy info: default resolver, latest strategy, conflict manager...</span>

The default resolver is used whenever nothing else is configured in the modules section of the settings file. It should give the name of a dependency resolver defined in the <a href="settings/resolvers.html">resolvers</a> section of the settings file.<br class="xooki-br"/><br class="xooki-br"/>The default latest strategy and conflict manager can also be configured here.<br class="xooki-br"/><br class="xooki-br"/><em>validate</em> indicates if ivy files should generally be validated against the xsd or not. This setting is only a default value, and can be overridden:<br class="xooki-br"/>1) in ant tasks<br class="xooki-br"/>2) in resolvers<br class="xooki-br"/>So if there is a setting in the resolver, it always wins against all other settings.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultResolver</td><td>the name of the default resolver to use</td>
        <td>No, but all modules should be configured in the modules section if not provided</td></tr>
    <tr><td>defaultLatestStrategy</td><td>the name of the default latest strategy to use</td>
        <td>No, defaults to latest-revision</td></tr>
    <tr><td>defaultConflictManager</td><td>the name of the default conflict manager to use</td>
        <td>No, defaults to latest-revision</td></tr>
    <tr><td>defaultBranch</td><td>the default branch to use for all modules, except if they have a <a href="settings/module.html">module specific branch setting</a>. <span class="since">since 1.4</span></td>
        <td>No, defaults to no default branch</td></tr>
    <tr><td>defaultResolveMode</td><td>the default <a href="use/resolve.html">resolve mode</a> to use for all modules, except if they have a <a href="settings/module.html">module specific resolve mode setting</a>. <span class="since">since 2.0</span></td>
        <td>No, defaults to 'default'</td></tr>
    <tr><td><a name="circularDependencyStrategy"></a>circularDependencyStrategy</td><td>the name of the <a href="../concept.html#circular">circular dependency strategy</a> to use <span class="since">since 1.4</span></td>
        <td>No, defaults to warn</td></tr>
    <tr><td>validate</td><td>Indicates if ivy files should be validated against ivy.xsd or not.</td>
        <td>No, defaults to true</td></tr>
    <tr><td>useRemoteConfig</td><td>true to configure ivyrep and ibiblio resolver from a remote configuration file (updated with changes in those repository structure if any) (<span class="since">since 1.2</span>)</td>
        <td>No, defaults to false</td></tr>
    <tr><td>httpRequestMethod</td><td>specifies the HTTP method to use to retrieve information about an URL. Possible values are 'GET' and 'HEAD'. This setting can be used to solve problems with firewalls and proxies. (<span class="since">since 2.0</span>)</td>
        <td>No, defaults to 'HEAD'</td></tr>
    <tr><td><s>defaultCache</s></td><td>a path to a directory to use as default basedir for both resolution and repository cache(s).<br class="xooki-br"/>	    <i>Deprecated, we recommend using defaultCacheDir on the <a href="settings/caches.html">caches</a> tag instead</i></td>
        <td>No, defaults to .ivy2/cache in user home</td></tr>
    <tr><td><s>checkUpToDate</s></td><td>Indicates if date should be checked before retrieving artifacts from cache.<br class="xooki-br"/>    	<i>Deprecated, we recommend using overwriteMode on the <a href="use/retrieve.html">retrieve</a> task instead</i></td>
        <td>No, defaults to true</td></tr>
    <tr><td><s>cacheIvyPattern</s></td><td>a pattern to indicate where ivy files should be put in cache.<br class="xooki-br"/>    	<i>Deprecated, we recommend using ivyPattern on the <a href="settings/caches.html">caches</a> tag instead</i></td>
        <td>No, defaults to [organisation]/[module]/ivy-[revision].xml</td></tr>
    <tr><td><s>cacheArtifactPattern</s></td><td>a pattern to indicate where artifact files should be put in cache.<br class="xooki-br"/>    	<i>Deprecated, we recommend using artifactPattern on the <a href="settings/caches.html">caches</a> tag instead</i></td>
        <td>No, defaults to [organisation]/[module]/[type]s/[artifact]-[revision].[ext]</td></tr>
</tbody>
</table>
<hr/><div class='toc-title toc-title-4'>include</div><br class="xooki-br"/><b>Tag:</b> include<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.include">Includes another ivysettings file as if it were part of this one.</span> <span class="since">since 1.3</span>

The included ivysettings file has to be a complete well formed ivysettings file, i.e. it does have to include the <pre>&lt;ivysettings&gt;</pre> tag.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>url</td><td>a URL to the ivysettings file to include</td>
        <td>Yes, unless file is specified</td></tr>
    <tr><td>file</td><td>a path to the ivysettings file to include</td>
        <td>Yes, unless url is specified</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;property name="myrepository" value="path/to/my/real/rep"/&gt;<br class="xooki-br"/>  &lt;settings defaultResolver="default"/&gt;<br class="xooki-br"/>  &lt;include file="path/to/ivysettings-default.xml"/&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
with ivysettings-default.xml:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;property name="myrepository" value="path/to/rep" overwrite="false"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;ivyrep name="default" ivyroot="${myrepository}"/&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

The included ivysettings defines a resolver named default, which is an ivyrep resolver, with its root configured as being the value of myrepository variable. This variable is given the value path/to/rep in the included file, but because the attribute overwrite is set to false, it will not override the value given in the main ivysettings including this one, so the value used for myrepository will be path/to/my/real/rep.<br class="xooki-br"/><hr/>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;include file="ivysettings-macro.xml"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;mymacro name="includeworks" mymainrep="included/myrep" mysecondrep="included/secondrep"/&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt; 
</pre>
with ivysettings-macro.xml being the ivysettings example given on the <a href="settings/macrodef.html">macrodef documentation page</a>.<br class="xooki-br"/>This lets us easily reuse the custom macro resolver.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>classpath</div><br class="xooki-br"/><b>Tag:</b> classpath<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.classpath">Includes a jar in the classpath used to load plugins.</span> <span class="since">since 1.4</span>

This let you add ivy plugins without relying on an external classpath (the ant classpath for instance), therefore easing the use of ivy in multiple execution environments (ant, standalone, IDE plugins, ...).<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>url</td><td>the url of a jar to add to the classpath</td>
        <td>Yes, unless file is specified</td></tr>
    <tr><td>file</td><td>a jar to add to the classpath</td>
        <td>Yes, unless url is specified</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;classpath file="${ivy.settings.dir}/custom-resolver.jar"/&gt;<br class="xooki-br"/>  &lt;typedef name="custom" classname="org.apache.ivy.resolver.CustomResolver"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;custom name="custom"/&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
Adds the custom-resolver.jar (found in the same directory as the ivysettings.xml file) to the classpath, then defines a custom resolver and uses it.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;classpath url="<a href="http://www.myserver.com/ivy/custom-resolver.jar">http://www.myserver.com/ivy/custom-resolver.jar</a>"/&gt;<br class="xooki-br"/>  &lt;typedef name="custom" classname="org.apache.ivy.resolver.CustomResolver"/&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;custom name="custom"/&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
Same as above, but finds the jar on a web server.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>typedef</div><br class="xooki-br"/><b>Tag:</b> typedef<br/>
<br/>
<span class="tagdoc" id="ivysettings.typedef">Defines a new type in ivy. Useful to define new dependency resolvers, in particular, but also latest strategies.</span>
See <a href="../extend.html">how to write and plug your own dependency resolver</a> for details.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the type to define. This name is then used as an xml tag.</td>
        <td>Yes</td></tr>
    <tr><td>classname</td><td>the fully qualified class name of the type to define.</td>
        <td>Yes</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>credentials</div><br class="xooki-br"/><b>Tag:</b> credentials<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.credentials">Configures HTTP authentication credentials.</span> <span class="since">since 2.0</span>.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>host</td><td>the name of the host</td>
        <td>Yes</td></tr>
    <tr><td>realm</td><td>the name of the realm</td>
        <td>No</td></tr>
    <tr><td>username</td><td>the username</td>
        <td>Yes</td></tr>
    <tr><td>passwd</td><td>the password</td>
        <td>Yes</td></tr>
</tbody>
</table>
<hr/><div class='toc-title toc-title-4'>signers</div><br class="xooki-br"/><b>Tag:</b> signers<br class="xooki-br"/><span class="since">since 2.2</span>

<span class="tagdoc" id="ivysettings.signers">Defines a list of detached signature generators usable in ivy. Each generator is identified by its name, given as an attribute.<br class="xooki-br"/>The child tags used to configure the signature generator must be equal to the name of a signature generator type (either built-in or added with the typedef tag).</span>

Ivy supports the following signature generator out of the box: 
<ul>
<li>pgp</li> generates an OpenPGP compatible ASCII armored detached signature.
</ul>


<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any signature generator</td><td>adds a signature generator to the list of registered generators</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Built-in Generators</h1>

<h2>PGP</h2>

This generator is capable of generating an OpenPGP compatible ASCII armored detached signature.<br class="xooki-br"/><br class="xooki-br"/><b>Remark:</b> This generator uses the <a href="http://www.bouncycastle.org/java.html">BouncyCastle OpenPGP</a> library. Before this generator can be used, these libraries must be available on Ivy's classpath.<br class="xooki-br"/><br class="xooki-br"/>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>The name of the signature generator.</td>
        <td>Yes</td>
    </tr>
    <tr><td>secring</td><td>The location of the secret keyring.</td>
        <td>No, defaults to ${user.home}/.gnupg/secring.gpg</td>
    </tr>
    <tr><td>keyId</td><td>The identifier of the key to use. The keyword 'auto' can be used to indicate a key will be selected automatically.</td>
        <td>No, defaults to 'auto'.</td>
    </tr>
    <tr><td>password</td><td>The password of the private key.</td>
        <td>Yes</td>
    </tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;signers&gt;<br class="xooki-br"/>    &lt;pgp name="mypgp" password="my-password" /&gt;<br class="xooki-br"/>&lt;/signers&gt;
</pre>
Defines a detached signature generator with name 'mypgp' which uses the secret key ring on the default location and automatically selects a private key.<br class="xooki-br"/><hr/>
<pre>
&lt;signers&gt;<br class="xooki-br"/>    &lt;pgp name="mypgp" password="my-password" keyId="123ABC45"/&gt;<br class="xooki-br"/>&lt;/signers&gt;
</pre>
Same as before, but this time the key '123ABC45' is used to generate the detached signature.<br class="xooki-br"/><hr/><div class='toc-title toc-title-4'>lock-strategies</div><br class="xooki-br"/><b>Tag:</b> lock-strategies <span class="since">since 2.0</span>

<span class="tagdoc" id="ivysettings.lock-strategies">Defines a list of lock strategies usable in Ivy.</span>

A lock strategy is used by a cache manager to decide when and how locking should be performed (see settings/cache to see how to configure the lock strategy to use).<br class="xooki-br"/><br class="xooki-br"/>Two lock strategies are registered by default:
<ul>
<li><b>no-lock</b></li> This lock strategy actually performs no locking at all, and thus should not be used in an environment where the cache is shared by multiple processes. <br class="xooki-br"/><br class="xooki-br"/>This strategy is implemented by (<a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/plugins/lock/NoLockStrategy.java">NoLockStrategy</a>)<br class="xooki-br"/><br class="xooki-br"/>
<li><b>artifact-lock</b></li> This strategy acquires a lock whenever a module descriptor or an artifact is downloaded to the cache, which makes a good solution when you want to share your repository cache.<br class="xooki-br"/><br class="xooki-br"/>Note that this strategy is based on file locking, performed by default using the java.io.File.createNewFile() atomicity (which is documented as atomic in the javadoc, but not recommended to perform locks). A java.nio.FileLock based implementation is also provided, but according to our tests the createNewFile based one performs better and more reliably. We heavily recommend making your own testing in your target environment before relying on this lock strategy for heavily concurrent operations.<br class="xooki-br"/><br class="xooki-br"/>This strategy is implemented by (<a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/plugins/lock/ArtifactLockStrategy.java">ArtifactLockStrategy</a>)
</ul>

The child tag used for the lock strategy must be equal to a name of a lock strategy type (added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any lock strategy</td><td>adds a lock strategy to the list of available ones</td>
        <td>0..n</td></tr>
</tbody>
</table><hr/><div class='toc-title toc-title-4'>caches</div><br class="xooki-br"/><b>Tag:</b> caches<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.caches">Configures the Ivy cache system.</span> <span class="since">since 2.0</span>.<br class="xooki-br"/>See <a href="../concept.html#cache">cache concept</a> for details on the Ivy cache concept.<br class="xooki-br"/><br class="xooki-br"/>By default, Ivy defines one repository cache instance, called 'default-cache', which uses the default cache settings defined using attributes on this tag. This default instance is defined as long as you don't define your own default cache using the 'default' attribute, and have at least one dependency resolver which doesn't specify which cache instance to use.<br class="xooki-br"/><br class="xooki-br"/><em>defaultCacheDir</em> is the default directory used for both the resolution and repository cache(s). It usually points to a directory in your filesystem. If you want to isolate resolution cache from repository cache, we recommend setting both the resolutionCacheDir and repositoryCacheDir attributes on this tag instead of using defaultCacheDir.<br class="xooki-br"/><br class="xooki-br"/>Since repository cache implementations are pluggable, you can either define new cache instances based on the default implementation provided in Ivy using the <a href="settings/caches/cache.html">cache</a> child element, or use custom cache implementations using child elements as you have defined using <a href="settings/typedef.html">typedef</a>.<br class="xooki-br"/><br class="xooki-br"/><em>ivyPattern</em> and <em>artifactPattern</em> are used to configure the default way Ivy stores ivy files and artifacts in repository cache(s). Usually you do not have to change this, unless you want to use the cache directly from another tool, which is not recommended. These patterns are relative to the repository cache base directory.<br class="xooki-br"/><br class="xooki-br"/><em>checkUpToDate</em> indicates to ivy if it must check date of artifacts before retrieving them (i.e. copying them from<br class="xooki-br"/>cache to another place in your filesystem). Usually it is a good thing to check date to avoid unnecessary copy, even if it's most of the time a local copy.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>default</td><td>the name of the default cache to use on all resolvers not defining the cache instance to use</td>
        <td>No, defaults to a default cache manager instance named 'default-cache'</td></tr>
    <tr><td>defaultCacheDir</td><td>a path to a directory to use as default basedir for both resolution and repository cache(s)</td>
        <td>No, defaults to .ivy2/cache in the user's home directory</td></tr>
    <tr><td>resolutionCacheDir</td><td>the path of the directory to use for all resolution cache data</td>
        <td>No, defaults to defaultCacheDir</td></tr>
    <tr><td>repositoryCacheDir</td><td>the path of the default directory to use for repository cache data. <strong>This should not point to a directory used as a repository!</strong></td>
        <td>No, defaults to defaultCacheDir</td></tr>
    <tr><td>ivyPattern</td><td>default pattern used to indicate where ivy files should be put in the repository cache(s)</td>
        <td>No, defaults to [organisation]/[module]/ivy-[revision].xml</td></tr>
    <tr><td>artifactPattern</td><td>default pattern used to indicate where artifact files should be put in the repository cache(s)</td>
        <td>No, defaults to [organisation]/[module]/[type]s/[artifact]-[revision].[ext]</td></tr>
    <tr><td><s>checkUpToDate</s></td><td>Indicates if date should be checked before retrieving artifacts from cache.<br class="xooki-br"/>    	<i>Deprecated, we recommend using overwriteMode on the <a href="use/retrieve.html">retrieve</a> task instead</i></td>
        <td>No, defaults to true</td></tr>
    <tr><td>useOrigin</td><td>the default value to use for useOrigin for caches in which it isn't specifically defined.<br class="xooki-br"/>    	Use true to avoid the copy of local artifacts to the cache and use directly their original location.</td>
        <td>No, defaults to false</td></tr>
    <tr><td>lockStrategy</td><td>the name of the default <a href="settings/lock-strategies.html">lock strategy</a> to use when accessing repository cache(s)</td>
        <td>No, defaults to <em>no-lock</em></td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="caches/cache.html">cache</a></td><td>defines a new repository cache instance, based on the default repository cache implementation</td>
        <td>0..n</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;caches&gt;<br class="xooki-br"/>  &lt;cache name="mycache" basedir="path/to/my/cache/1" /&gt;<br class="xooki-br"/>  &lt;cache name="mycache2" basedir="path/to/my/cache/2" /&gt;<br class="xooki-br"/>&lt;/caches&gt; 
</pre>
Define 2 cache instances, named mycache and mycache2, using two different directories as base directory, and using the default patterns and lock strategies. The default cache instance will still be defined as long as at least one dependency resolver does not declare which cache manager to use.<br class="xooki-br"/><hr/><hr/><div class='toc-title toc-title-5'>cache</div><br class="xooki-br"/><b>Tag:</b> cache<br class="xooki-br"/><br class="xooki-br"/><span class="since">Since 2.0</span>.<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.caches.cache">Defines a repository cache instance based on the default repository cache implementation.</span>

The default repository cache implementation caches files on the local filesystem in subdirectories of a configured base directory.<br class="xooki-br"/><br class="xooki-br"/>By default also, the parsed module descriptor read from the cache are kept in a memory cache in case they are reused.  This may enhance the performance of multi-module build, provided that all modules are build using the same ivy instance.  The size of this memory cache is configurable in term of number of module descriptors.  A size of 0 means no memory caching.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>name of the cache instance</td>
        <td>Yes</td></tr>
    <tr><td>basedir</td><td>the path of the base directory to use to put repository cache data. <strong>This should not point to a directory used as a repository!</strong></td>
        <td>No, defaults to repositoryCacheDir defined in <a href="settings/caches.html">caches</a></td></tr>
    <tr><td>ivyPattern</td><td>the pattern to use to store cached ivy files</td>
        <td>No, defaults to default cache ivy pattern as configured in <a href="settings/caches.html">caches</a></td></tr>
    <tr><td>artifactPattern</td><td>the pattern to use to store cached artifacts</td>
        <td>No, defaults to default cache artifact pattern as configured in <a href="settings/caches.html">caches</a></td></tr>
    <tr><td>useOrigin</td><td>true to avoid the copy of local artifacts to the cache and use directly their original location, false otherwise. <br class="xooki-br"/>To know if an artifact is local ivy asks to the resolver. Only filesystem resolver is considered local by default, but this can be disabled if you want to force the copy on one filesystem resolver and use the original location on another. Note that it is safe to use useOrigin even if you use the cache for some non local resolvers. In this case the cache will behave as usual, copying files to the cache. Note also that this only applies to artifacts, not to ivy files, which are still copied in the cache.</td>
        <td>No. defaults to the default value configured in <a href="settings/caches.html">caches</a></td></tr>
    <tr><td>lockStrategy</td><td>the name of the <a href="settings/lock-strategies.html">lock strategy</a> to use for this cache</td>
        <td>No, defaults to default lock strategy as configured in <a href="settings/caches.html">caches</a></td></tr>
    <tr><td>defaultTTL</td><td>the default <a href="settings/caches/ttl.html">TTL</a> to use when no specific one is defined</td>
        <td>No, defaults to ${ivy.cache.ttl.default}</td></tr>
    <tr><td>memorySize</td><td>the number of parsed module descriptors to keep in a memory cache.</td><td>No, default to 150</td></tr>
</tbody>
</table>

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/caches/ttl.html">ttl</a></td><td>defines a TTL rule</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;cache name="mycache" <br class="xooki-br"/>       basedir="/path/to/mycache"<br class="xooki-br"/>       ivyPattern="[module]/ivy-[revision].xml" <br class="xooki-br"/>       artifactPattern="[module]/[artifact]-[revision].[ext]"<br class="xooki-br"/>       lockStrategy="no-lock"<br class="xooki-br"/>       defaultTTL="1s"&gt;<br class="xooki-br"/>    &lt;ttl revision="latest.integration" duration="200ms" /&gt;<br class="xooki-br"/>    &lt;ttl organisation="org1" duration="10m 20s" /&gt;<br class="xooki-br"/>    &lt;ttl organisation="org2" duration="5h" /&gt;<br class="xooki-br"/>    &lt;ttl organisation="org3" duration="2d 12h" /&gt;<br class="xooki-br"/>&lt;/cache&gt;
</pre>
Defines a cache called 'mycache', storing files in the '/path/to/mycache' directory using '[module]/ivy-[revision].xml' as pattern to store Ivy files and '[module]/[artifact]-[revision].[ext]' as pattern to store other artifacts.<br class="xooki-br"/>The lock strategy used by this cache is the 'no-lock' strategy, which does not perform any locking. <br class="xooki-br"/>The defaultTTL used is of 1s, meaning that by default dynamic revision result will be stored and used for one second. TTL rules then define that all 'latest.integration' revisions will be stored and used for 200ms, while other dynamic revisions from org1 org2 and org3 modules will be stored respectively for 10 minutes 20 seconds; 5 hours; and 2 days and 12 hours.<hr/><div class='toc-title toc-title-6'>ttl</div><br class="xooki-br"/><b>Tag:</b> ttl<br class="xooki-br"/><br class="xooki-br"/><span class="since">Since 2.0</span> <span class="tagdoc" id="ivysettings.caches.cache.TTL">Defines a TTL (Time To Live) rule for resolved revision caching.</span>

When Ivy resolves a dynamic version constraint (like latest.integration or a version range), it can store the result of the resolution (like latest.integration=1.5.1) for a given time, called TTL. It means that Ivy will reuse this dynamic revision resolution result without accessing the repositories for the duration of the TTL, unless running <a href="use/resolve.html">resolve</a> in refresh mode.<br class="xooki-br"/><br class="xooki-br"/>This tag let you define a rule to define a TTL specific to a set of dynamic revision, based on the whole module revision information (organization, module name, revision, ...). The revision considered in the rule is the revision before the resolution (for instance 'latest.integration') and not the resolved revision (for instance '1.5.1').<br class="xooki-br"/><br class="xooki-br"/>The rules are evaluated in order, the first matching rule being used to define the TTL. If no rule matches, the cache defaultTTL will be used.<br class="xooki-br"/><br class="xooki-br"/>The format used to specify the TTL is of the form:
<pre>
XXd XXh XXm XXs XXXms
</pre>
Where 'd' stands for days, 'h' for hours, 'm' for minutes, 's' for seconds and 'ms' for milliseconds. Any part of the specification can be omitted, so '12d', '2h 5m' and '1d 5ms' are all valid.<br class="xooki-br"/><br class="xooki-br"/>The TTL duration can also be set to 'eternal', in which case once resolved the revision is always use, except when resolving in refresh mode. <br class="xooki-br"/><br class="xooki-br"/>Using a 0ms TTL disable resolved revision caching for the given rule.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the organisation to match to apply the rule.</td>
        <td>No, defaults to *</td></tr>
    <tr><td>module</td><td>the module's name to match to apply the rule.</td>
        <td>No, defaults to *</td></tr>
    <tr><td>revision</td><td>the module's revision to match to apply the rule. Note that the version is not resolved when evaluating the rule ('latest.integration' for instance).</td>
        <td>No, defaults to *</td></tr>
    <tr><td><em>any extra attribute</em></td><td>an extra attribute to match to apply the rule.</td>
        <td>No, defaults to *</td></tr>
    <tr><td>matcher</td><td>the <a href="../../concept.html#matcher">matcher</a> to use to match the modules to which the resolver should be applied</td>
        <td>No, defaults to exact</td></tr>
    <tr><td>duration</td><td>the TTL to apply (see above for format)</td>
        <td>Yes</td></tr>
</tbody>
</table>

<hr/><div class='toc-title toc-title-4'>latest-strategies</div><br class="xooki-br"/><b>Tag:</b> latest-strategies<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.latest-strategies">Defines a list of <a href="../concept.html#latest">latest strategies</a> usable in Ivy.</span> Each latest strategy is identified by its name, given as an attribute.<br class="xooki-br"/>The child tag used for the latest strategy must be equal to a name of a latest strategy type (usually added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/>The latest strategies which are included in Ivy by default are:
<ul>
<li>latest-time</li> compares the revisions date to know which is the latest. While this is often a good strategy in terms of pertinence, it's drawback is that it can be slow when dealing with remote repositories. If you use ivyrep, <br class="xooki-br"/>for example, Ivy has to ask the http server for the date of each ivy file before knowing which is the latest.
<li>latest-revision</li> compares the revisions as strings, using an algorithm close to the one used in php's version_compare function.<br class="xooki-br"/>This algorithm takes into account the special meaning of some text. For instance, with this strategy, 1.0-dev1 is considered before 1.0-alpha1, which in turn is before 1.0-rc1, which is before 1.0, which is before 1.0.1.
<li>latest-lexico</li> compares the revisions as strings, using lexicographic order (the one used by java string comparison).
</ul>

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any latest strategy</td><td>adds a latest strategy to the list of available strategies</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>latest-revision</h1>
<span class="since">since 1.4</span> The latest-revision can now be configured to handle more words with special meanings than the one defined in php version_compare function.<br class="xooki-br"/><br class="xooki-br"/>Here is an example of how you can do so:
<pre>
&lt;latest-strategies&gt;<br class="xooki-br"/>  &lt;latest-revision name="mylatest-revision"&gt;<br class="xooki-br"/>    &lt;specialMeaning name="PRE" value="-2"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="QA" value="4"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="PROD" value="5"/&gt;<br class="xooki-br"/>  &lt;/latest-revision&gt;<br class="xooki-br"/>&lt;/latest-strategies&gt; 
</pre>
Knowing that the default "special meaning" words are the following:
<pre>
    &lt;specialMeaning name="dev" value="-1"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="rc" value="1"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="final" value="2"/&gt;
</pre>
You can even remove or redefine the default special meanings by setting usedefaultspecialmeanings="false" on the latest-revision tag.<br class="xooki-br"/>Example:
<pre>
&lt;latest-strategies&gt;<br class="xooki-br"/>  &lt;latest-revision name="mylatest-revision" usedefaultspecialmeanings="false"&gt;<br class="xooki-br"/>    &lt;specialMeaning name="pre" value="-2"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="m" value="1"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="rc" value="2"/&gt;<br class="xooki-br"/>    &lt;specialMeaning name="prod" value="3"/&gt;<br class="xooki-br"/>  &lt;/latest-revision&gt;<br class="xooki-br"/>&lt;/latest-strategies&gt; 
</pre>


	<hr/><div class='toc-title toc-title-4'>parsers</div><br class="xooki-br"/><b>Tag:</b> parsers<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.parsers">Defines a list of module descriptor parsers usable in ivy.</span> Each parser defines which resources (which descriptor file) it accepts.<br class="xooki-br"/>The child tag used for the parser must be equal to a name of a parser type (added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/>Note that when looking for a parser, ivy queries the parsers list in the reverse order. So the last parser in the list will be queried first. Consequently, if the last parser accepts all resources, the other parsers will never have a chance to parse the resource.<br class="xooki-br"/><br class="xooki-br"/>Two parsers are available by default and thus do not need to be declared in this section:
<ul>
<li>ivy file parser</li> this is the parser used for ivy xml files. This parser is used for resources that aren't accepted by any other parser.
<li>pom parser</li>this parser is able to parse maven2 pom files
</ul>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any module descriptor parser</td><td>adds a module descriptor parser to the list of available parsers</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>namespaces</div><br class="xooki-br"/><b>Tag:</b> namespaces<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.namespaces">Namespaces are an advanced feature of Ivy which let you use resolvers in which module names and organisations are not consistent between each other.</span>

For instance, if you want to use both a maven2 repository and an ivyrep, you will face some naming issues. For example, all apache commons projects are declared to be part of the organisation <i>apache</i> in ivyrep whereas in maven2 ibiblio repository, their organisation is same as the module.<br class="xooki-br"/><br class="xooki-br"/>So if you try to use both maven2 and ivyrep repositories, you will face some issues like:<br class="xooki-br"/><quote>
How do I declare a dependency on commons-lang?<br class="xooki-br"/>I have an error while trying to resolve module xxx. It says that it depends on [commons-httpclient commons-httpclient] and that it isn't available.<br class="xooki-br"/>...<br class="xooki-br"/></quote>

Ivy's answer to this issue is called namespaces. In short, you can attach a namespace to each dependency resolver in Ivy, and each namespace defines rules to convert names from the system namespace to the defined namespace itself, and vice versa.<br class="xooki-br"/><br class="xooki-br"/>This very powerful feature is thoroughly used in the <a href="../tutorial/build-repository/advanced.html">build your own repository tutorial</a>, so is the best place to see an example of what can be done with namespaces.<br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/namespace.html">namespace</a></td><td>defines a new namespace</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>namespace</div><br class="xooki-br"/><b>Tag:</b> namespace<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.namespaces.namespace">Defines a new namespace. A namespace is identified by a name, which can be referenced by one of the <a href="settings/resolvers.html">resolvers</a>.</span>

An overview of Namespaces is given in the <a href="settings/namespaces.html">namespaces</a> documentation.<br class="xooki-br"/><br class="xooki-br"/>A namespace mainly consists of a list of rules, each rule defining a translation between a system namespace and the defined namespace, and vice versa.<br class="xooki-br"/><br class="xooki-br"/>There are two main possibilities for using these rules. By default, a namespace iterates through the rules, and when it finds one that translates the given name, it returns the translated name. But the namespace can be configured to use the list as a translator chain: in this case, all rules are applied in order, the result of the first rule translation being passed to the second, and so on.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the namespace name</td>
        <td>Yes</td></tr>
    <tr><td>chainrules</td><td>true to indicate that namespaces rules should be chained, false otherwise</td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/namespace/rule.html">rule</a></td><td>defines a new namespace rule</td>
        <td>0..n</td></tr>
</tbody>
</table>
<h1>Example</h1>
<pre>
&lt;namespace name="test"&gt;<br class="xooki-br"/>  &lt;rule&gt;<br class="xooki-br"/>    &lt;fromsystem&gt;<br class="xooki-br"/>      &lt;src org="systemorg"/&gt;<br class="xooki-br"/>      &lt;dest org="A"/&gt;<br class="xooki-br"/>    &lt;/fromsystem&gt;<br class="xooki-br"/>    &lt;tosystem&gt;<br class="xooki-br"/>      &lt;src org="A"/&gt;<br class="xooki-br"/>      &lt;dest org="systemorg"/&gt;<br class="xooki-br"/>    &lt;/tosystem&gt;<br class="xooki-br"/>  &lt;/rule&gt;<br class="xooki-br"/>&lt;/namespace&gt;
</pre>

<pre>
&lt;namespace name="test"&gt;<br class="xooki-br"/>  &lt;rule&gt;<br class="xooki-br"/>    &lt;fromsystem&gt;<br class="xooki-br"/>      &lt;src org="systemorg2" module="system\-(.+)"/&gt;<br class="xooki-br"/>      &lt;dest org="B" module="$m1"/&gt;<br class="xooki-br"/>    &lt;/fromsystem&gt;<br class="xooki-br"/>    &lt;tosystem&gt;<br class="xooki-br"/>      &lt;src org="B" module=".+"/&gt;<br class="xooki-br"/>      &lt;dest org="systemorg2" module="system-$m0"/&gt;<br class="xooki-br"/>    &lt;/tosystem&gt;<br class="xooki-br"/>  &lt;/rule&gt;<br class="xooki-br"/>&lt;/namespace&gt;
</pre>

<pre>
&lt;namespace name="test" chainrules="true"&gt;<br class="xooki-br"/>  &lt;rule&gt;<br class="xooki-br"/>    &lt;fromsystem&gt;<br class="xooki-br"/>      &lt;src org="systemorg"/&gt;<br class="xooki-br"/>      &lt;dest org="A"/&gt;<br class="xooki-br"/>    &lt;/fromsystem&gt;<br class="xooki-br"/>    &lt;tosystem&gt;<br class="xooki-br"/>      &lt;src org="A"/&gt;<br class="xooki-br"/>      &lt;dest org="systemorg"/&gt;<br class="xooki-br"/>    &lt;/tosystem&gt;<br class="xooki-br"/>  &lt;/rule&gt;<br class="xooki-br"/>  &lt;rule&gt;<br class="xooki-br"/>    &lt;fromsystem&gt;<br class="xooki-br"/>      &lt;src module="systemmod"/&gt;<br class="xooki-br"/>      &lt;dest module="A"/&gt;<br class="xooki-br"/>    &lt;/fromsystem&gt;<br class="xooki-br"/>    &lt;tosystem&gt;<br class="xooki-br"/>      &lt;src module="A"/&gt;<br class="xooki-br"/>      &lt;dest module="systemmod"/&gt;<br class="xooki-br"/>    &lt;/tosystem&gt;<br class="xooki-br"/>  &lt;/rule&gt;<br class="xooki-br"/>  &lt;rule&gt;<br class="xooki-br"/>    &lt;fromsystem&gt;<br class="xooki-br"/>      &lt;src module="systemmod2"/&gt;<br class="xooki-br"/>      &lt;dest module="B"/&gt;<br class="xooki-br"/>    &lt;/fromsystem&gt;<br class="xooki-br"/>    &lt;tosystem&gt;<br class="xooki-br"/>      &lt;src module="B"/&gt;<br class="xooki-br"/>      &lt;dest module="systemmod2"/&gt;<br class="xooki-br"/>    &lt;/tosystem&gt;<br class="xooki-br"/>  &lt;/rule&gt;<br class="xooki-br"/>&lt;/namespace&gt;
</pre>

	<hr/><div class='toc-title toc-title-6'>rule</div><br class="xooki-br"/><b>Tag:</b> rule<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.namespaces.namespace.rule">Defines a new namespace rule. A rule defines a translation between system namespace and the defined namespace, and vice versa.</span>

See the <a href="settings/namespace.html">namespace</a> doc for details.<br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/namespace/fromtosystem.html">fromsystem</a></td><td>defines the translation to apply from the system namespace to the defined namespace</td>
        <td>1</td></tr>
    <tr><td><a href="settings/namespace/fromtosystem.html">tosystem</a></td><td>defines the translation to apply from the defined namespace to the system namespace</td>
        <td>1</td></tr>
</tbody>
</table>
	<hr/><div class='toc-title toc-title-7'>fromsystem / tosystem</div><br class="xooki-br"/><b>Tag:</b> fromsystem / tosystem<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.namespaces.namespace.fromsystem">Defines a one way translation rule, i.e. a translation from system namespace to the defined namespace or vice versa.</span>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/namespace/src.html">src</a></td><td>defines a source name which can be accepted</td>
        <td>1..n</td></tr>
    <tr><td><a href="settings/namespace/dest.html">dest</a></td><td>defines the translation to apply when a name is accepted by an src pattern</td>
        <td>1</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-8'>src</div><br class="xooki-br"/><b>Tag:</b> src<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.namespaces.namespace.rule.fromsystem.src">Defines the acceptation part of a translation rule.</span> If a name matches this src, it will be translated using the dest part.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the organisation to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>module</td><td>the module name to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>rev</td><td>the revision to match as a regexp</td>
        <td>No, defaults to .*</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-8'>dest</div><br class="xooki-br"/><b>Tag:</b> dest<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.namespaces.namespace.rule.fromsystem.dest">Defines the translation part of a translation rule. If a name has matched a corresponding src, it will be translated using this dest part.</span>

The new names can contain references to groups of the matched name, using a slightly modified regexp syntax. Indeed, referenced groups can be part of either the organisation, module or revision part of the original name. So, to reference the groups, you just have to add a letter identifying the part in which the group should be selected: o for organisation, m for module, and r for revision.<br class="xooki-br"/><br class="xooki-br"/>For instance, $o0 matches the whole matched organisation, and $m0 the whole matched module name. $o1 matches the first group of the matched organisation.<br class="xooki-br"/><br class="xooki-br"/>For details about regexp and groups, see the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">Pattern class documentation</a> in the jdk.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the new organisation name</td>
        <td>No, defaults to $o0</td></tr>
    <tr><td>module</td><td>the new module name</td>
        <td>No, defaults to $m0</td></tr>
    <tr><td>rev</td><td>the new revision</td>
        <td>No, defaults to $r0</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
    &lt;fromsystem&gt;<br class="xooki-br"/>      &lt;src org="systemorg2" module="system\-(.+)"/&gt;<br class="xooki-br"/>      &lt;dest org="B" module="$m1"/&gt;<br class="xooki-br"/>    &lt;/fromsystem&gt;
</pre>
Matches modules from systemorg2 which have a name beginning with system followed by a minus and anything else, and translate it to organisation B and module the part following <pre>system-</pre> of the original name.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>macrodef</div><br class="xooki-br"/><b>Tag:</b> macrodef<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.macrodef">Defines a new dependency resolver type based upon another.</span> This definition is very similar to the macrodef feature of ant for defining macro tasks. <span class="since">since 1.3</span>

This task eases the process of creating a new dependency resolver, because it avoids writing java code.<br class="xooki-br"/><br class="xooki-br"/>It is generally used in combination with the <a href="settings/include.html">include</a> feature to help reuse a macro in multiple settings files.<br class="xooki-br"/><br class="xooki-br"/>A macro is defined by declaring an existing resolver within it. Then you can use attributes to pass parameters to the newly defined resolver type. Attributes are defined with a name, and optionally a default value, and are used using the following syntax: 
<pre>@{attributename}</pre>
<h2>Resolvers names</h2>
Since you can use the same macro several times it can define several resolvers (in a chain for instance), the resolver names need to be chosen carefully to avoid name conflicts (each resolver must have a unique name).<br class="xooki-br"/><br class="xooki-br"/>Here is how Ivy deals with the names of the resolvers defined in a macro:
<ul>
<li>if there is no name attribute on a resolver in the macrodef, then Ivy will use the name given when using the macro. This is what usually should be done for the main resolver defined in the macro</li>
<li>if there is a name attribute on a resolver in the macrodef, but this name doesn't contain a @{name} inside, then Ivy will use the provided name prefixed with the name of the macro separated by a dash</li>
<li>if there is a name attribute on a resolver in the macrodef, and this name contains @{name} somewhere, then Ivy will use this name, and replace @{name} with the name provided when using the macro.</li>
</ul>

Example:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;macrodef name="mymacro"&gt;<br class="xooki-br"/>    &lt;chain&gt;<br class="xooki-br"/>      &lt;ibiblio name="ex1" /&gt;<br class="xooki-br"/>      &lt;ibiblio name="ex2.@{name}" m2compatible="true" /&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>  &lt;/macrodef&gt;<br class="xooki-br"/>	<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;mymacro name="default" /&gt;<br class="xooki-br"/>    &lt;mymacro name="other" /&gt;<br class="xooki-br"/>   &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>
This is equivalent to:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;chain name="default"&gt;<br class="xooki-br"/>      &lt;ibiblio name="default-ex1" /&gt;<br class="xooki-br"/>      &lt;ibiblio name="ex2.default" m2compatible="true" /&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>    &lt;chain name="other"&gt;<br class="xooki-br"/>      &lt;ibiblio name="other-ex1" /&gt;<br class="xooki-br"/>      &lt;ibiblio name="ex2.other" m2compatible="true" /&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>   &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>name of the resover type created</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/macrodef/attribute.html">attribute</a></td><td>defines an attribute for the macro resolver</td>
        <td>0..n</td></tr>
    <tr><td>any resolver</td><td>defines the base resolver upon which this macro is defined</td>
        <td>1</td></tr>
</tbody>
</table>
<h1>Examples</h1>
Defining a simple macro:
<pre>
  &lt;macrodef name="mymacro"&gt;<br class="xooki-br"/>    &lt;attribute name="mymainrep"/&gt;<br class="xooki-br"/>      &lt;filesystem name="fs1"&gt;<br class="xooki-br"/>        &lt;ivy pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>        &lt;artifact pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>      &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;/macrodef&gt;
</pre>
Using it:
<pre>
  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;mymacro name="default" mymainrep="path/to/myrep"/&gt;<br class="xooki-br"/>  &lt;/resolvers&gt;
</pre>
<hr/>
A complete example:
<pre>
&lt;ivysettings&gt;<br class="xooki-br"/>  &lt;macrodef name="mymacro"&gt;<br class="xooki-br"/>    &lt;attribute name="mymainrep"/&gt;<br class="xooki-br"/>    &lt;attribute name="mysecondrep"/&gt;<br class="xooki-br"/>    &lt;attribute name="myseconddirlayout" default="[organisation]/[module]/[type]s"/&gt;<br class="xooki-br"/>    &lt;chain&gt;<br class="xooki-br"/>      &lt;filesystem name="fs1"&gt;<br class="xooki-br"/>        &lt;ivy pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>        &lt;artifact pattern="@{mymainrep}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>      &lt;/filesystem&gt;<br class="xooki-br"/>      &lt;filesystem name="fs2" latest="latest-time"&gt;<br class="xooki-br"/>        &lt;ivy pattern="@{mysecondrep}/@{myseconddirlayout}/ivy-[revision].xml"/&gt;<br class="xooki-br"/>        &lt;artifact pattern="@{mysecondrep}/@{myseconddirlayout}/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>      &lt;/filesystem&gt;<br class="xooki-br"/>    &lt;/chain&gt;<br class="xooki-br"/>  &lt;/macrodef&gt;<br class="xooki-br"/>	<br class="xooki-br"/>  &lt;resolvers&gt;<br class="xooki-br"/>    &lt;mymacro name="default" mymainrep="path/to/myrep" mysecondrep="path/to/secondrep"/&gt;<br class="xooki-br"/>    &lt;mymacro name="other" <br class="xooki-br"/>       mymainrep="path/to/myrep" <br class="xooki-br"/>       mysecondrep="path/to/secondrep" <br class="xooki-br"/>       myseconddirlayout="[module]/[type]s"/&gt;<br class="xooki-br"/>   &lt;/resolvers&gt;<br class="xooki-br"/>&lt;/ivysettings&gt;
</pre>

	<hr/><div class='toc-title toc-title-5'>attribute</div><br class="xooki-br"/><b>Tag:</b> attribute<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.macrodef.attribute">Defines a macrodef attribute.</span> See macrodef for details.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the attribute</td>
        <td>Yes</td></tr>
    <tr><td>default</td><td>the default value of the attribute if none is specified</td>
        <td>No, by default attribute are required</td></tr>
</tbody>
</table>


	<hr/><div class='toc-title toc-title-4'>resolvers</div><br class="xooki-br"/><b>Tag:</b> resolvers<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.resolvers">Defines a list of dependency resolvers usable in ivy.</span> Each dependency resolver is identified by its name, given as an attribute.<br class="xooki-br"/><br class="xooki-br"/>The child tag used for the dependency resolver must be equal to a name of a dependency resolver type (either built-in or added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> Once defined, resolvers can be referenced by their name, using the following syntax:
<pre>
&lt;resolver ref="alreadydefinedresolver"/&gt;
</pre>
Note that this works only if the resolver has already been defined and NOT if it is defined later in the ivysettings file.<br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any resolver</td><td>adds a resolver to the list of available resolvers</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Built-in Resolvers</h1>
Ivy comes with a set of built-in dependency resolvers that handle most common needs.<br class="xooki-br"/><br class="xooki-br"/>If you don't find the one you want here, you can also check if someone has contributed it on the links page, or even <a href="../extend.html">write your own</a>.<br class="xooki-br"/><br class="xooki-br"/>There are basically two types of resolvers in Ivy: composite and standard. A composite resolver is a resolver which delegates the work to other resolvers. The other resolvers are standard resolvers.<br class="xooki-br"/><br class="xooki-br"/>Here is the list of built-in resolvers:<br class="xooki-br"/>
<table class="ivy-attributes">
<thead>
    <tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="../resolver/ivyrep.html">IvyRep</a></td><td>Standard</td><td>Finds ivy files on ivyrep and artifacts on ibiblio.</td></tr>
<tr><td><a href="../resolver/ibiblio.html">IBiblio</a></td><td>Standard</td><td>Finds artifacts on ibiblio.</td></tr>
<tr><td><a href="../resolver/packager.html">Packager</a></td><td>Standard</td><td>Finds ivy files and packaging instructions via URLs, then creates artifacts by following the instructions.</td></tr>
<tr><td><a href="../resolver/filesystem.html">FileSystem</a></td><td>Standard</td><td>This very performant resolver finds ivy files and artifacts in your file system.</td></tr>
<tr><td><a href="../resolver/url.html">Url</a></td><td>Standard</td><td>Finds ivy files and artifacts in any repository accessible with urls.</td></tr>
<tr><td><a href="../resolver/vfs.html">Vfs</a></td><td>Standard</td><td>Finds ivy files and artifacts in any repository accessible with <a href="http://jakarta.apache.org/commons/vfs/">apache commons vfs</a>.</td></tr>
<tr><td><a href="../resolver/ssh.html">ssh</a></td><td>Standard</td><td>Finds ivy files and artifacts in any repository accessible with ssh.</td></tr>
<tr><td><a href="../resolver/sftp.html">sftp</a></td><td>Standard</td><td>Finds ivy files and artifacts in any repository accessible with sftp.</td></tr>
<tr><td><a href="../resolver/jar.html">Jar</a></td><td>Standard</td><td>Finds ivy files and artifacts within a specified jar.</td></tr>
<tr><td><a href="../resolver/chain.html">Chain</a></td><td>Composite</td><td>Delegates the finding to a chain of sub resolvers.</td></tr>
<tr><td><a href="../resolver/dual.html">Dual</a></td><td>Composite</td><td>Delegates the finding of ivy files to one resolver and of artifacts to another.</td></tr>
<tr><td><a href="../resolver/obr.html">OBR</a></td><td>Standard</td><td>Resolve modules as OSGi bundles listed by an OSGi obr.xml.</td></tr>
<tr><td><a href="../resolver/updatesite.html">Eclipse updatesite</a></td><td>Standard</td><td>Resolve modules as OSGi bundles which are hosted on an Eclipse update site.</td></tr>
</tbody>
</table>

<h1><a name="common">Common features and attributes</a></h1>
All resolvers of the same type share some common features and attributes detailed here.<br class="xooki-br"/><h2>Features</h2>
<h3>validation</h3>
All standard resolvers support several options for validation.<br class="xooki-br"/><br class="xooki-br"/>The <i>validate</i> attribute is used to configure if ivy files should be checked against the ivy file xml schema.<br class="xooki-br"/><br class="xooki-br"/>The checkconsistency attribute allows you to enable or disable consistency checking between what is expected by Ivy when it finds a module descriptor, and what the module descriptor actually contains.<br class="xooki-br"/><br class="xooki-br"/>The descriptor attribute lets you define if module descriptors are mandatory or optional.<br class="xooki-br"/><br class="xooki-br"/>The checksums attribute is used to define the list of checksums files to use to check if the content of downloaded files has not been corrupted (eg during transfer).<br class="xooki-br"/><h3>force</h3>
Any standard resolver can be used in force mode, which is used mainly to handle local development builds. In force mode, the resolver attempts to find a dependency whatever the requested revision is (internally it replace the requested revision by 'latest.integration'), and if it finds one, it forces this revision to be returned, even when used in a chain with returnFirst=false.<br class="xooki-br"/><br class="xooki-br"/>By using such a resolver at the beginning of a chain, you can be sure that Ivy will pick up whatever module is available in this resolver (usually a private local build) instead of the real requested revision. This allows to handle use case like a developer working on modules A and C, where A -> B -> C, and pick up the local build for C without having to publish a local version of B.<br class="xooki-br"/><span class="since">since 2.0</span>

<h2>Attributes</h2>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th><th>Composite</th><th>Standard</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name which identifies the resolver</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr><td>validate</td><td>indicates if resolved ivy files should be validated against ivy xsd</td>
        <td>No, defaults to call setting</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr><td>force</td><td>Indicates if this resolver should be used in force mode (see above). <span class="since">since 2.0</span></td>
        <td>No, defaults to false</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr><td>checkmodified</td><td>Indicates if this resolver should check lastmodified date to know if an ivy file is up to date.</td>
        <td>No, defaults to ${ivy.resolver.default.check.modified}</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr><td>changingPattern</td><td>Indicates for which revision pattern this resolver should check lastmodified date to know if an artifact file is up to date. <span class="since">since 1.4</span>. See <a href="../concept.html#change">cache and change management</a> for details.</td>
        <td>No, defaults to none</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr><td>changingMatcher</td><td>The name of the <a href="../concept.html#matcher">pattern matcher</a> to use to match a revision against the configured changingPattern. <span class="since">since 1.4</span>. See <a href="../concept.html#change">cache and change management</a> for details.</td>
        <td>No, defaults to exactOrRegexp</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr><td>alwaysCheckExactRevision</td><td>Indicates if this resolver should check the given revision even if it's a special one (like latest.integration). <span class="since">since 1.3</span></td>
        <td>No, defaults to ${ivy.default.always.check.exact.revision}</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr><td>namespace</td><td>The name of the namespace to which this resolver belons <span class="since">since 1.3</span></td>
        <td>No, defaults to 'system'</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr><td>checkconsistency</td><td>true to check consistency of module descriptors found by this resolver, false to avoid consistency check <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr><td>descriptor</td><td>'optional' if a module descriptor (usually an ivy file) is optional for this resolver, 'required' to refuse modules without module descriptor <span class="since">since 2.0</span></td>
        <td>No, defaults to 'optional'</td>
        <td>No (except dual)</td>
        <td>Yes</td>
    </tr>
    <tr><td>allownomd</td><td><em>DEPRECATED. Use descriptor="required | optional" instead.</em><br class="xooki-br"/>    true if the absence of module descriptor (usually an ivy file) is authorised for this resolver, false to refuse modules without module descriptor <span class="since">since 1.4</span></td>
        <td>No, defaults to true</td>
        <td>No (except dual)</td>
        <td>Yes</td>
    </tr>
    <tr><td>checksums</td><td>a comma separated list of <a href="../concept.html#checksum">checksum algorithms</a> to use both for publication and checking <span class="since">since 1.4</span></td>
        <td>No, defaults to ${ivy.checksums}</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr><td>latest</td><td>The name of the latest strategy to use.</td>
        <td>No, defaults to 'default'</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr><td>cache</td><td>The name of the cache manager to use.</td>
        <td>No, defaults to the value of the default attribute of caches</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr><td>signer</td><td>The name of the <a href="settings/signers.html">detached signature generator</a> to use when publishing artifacts. <span class="since">(since 2.2)</span></td>
        <td>No, by default published artifacts will not get signed by Ivy.</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;resolvers&gt;<br class="xooki-br"/>  &lt;filesystem name="1" cache="cache-1"&gt;<br class="xooki-br"/>    &lt;ivy pattern="${ivy.settings.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/&gt;<br class="xooki-br"/>    &lt;artifact pattern="${ivy.settings.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>  &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;chain name="chain1"&gt;<br class="xooki-br"/>    &lt;resolver ref="1"/&gt;<br class="xooki-br"/>    &lt;ivyrep name="ivyrep"/&gt;<br class="xooki-br"/>  &lt;/chain&gt;<br class="xooki-br"/>  &lt;chain name="chain2" returnFirst="true" dual="true"&gt;<br class="xooki-br"/>    &lt;resolver ref="1"/&gt;<br class="xooki-br"/>    &lt;ibiblio name="ibiblio"/&gt;<br class="xooki-br"/>  &lt;/chain&gt;<br class="xooki-br"/>&lt;/resolvers&gt;
</pre>
Defines a filesystem resolver, named '1', which is then used in two chains, the first which combines the filesystem resolver with an ivyrep resolver, and second which combines the filesystem resolver with an ibiblio resolver, and which returns the first module found, and uses the whole chain to download artifacts (see corresponding resolvers documentation for details about them).   Resolver 1 will use a cache named 'cache-1' which should have been defined under the caches element.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>IvyRep Resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ivyrep</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes, at least if the repository server is apache based</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>
<span class="tagdoc" id="ivysettings.resolvers.ivyrep">This resolver usually uses an URL based repository usually similar in structure to <a href="http://ivyrep.jayasoft.org/">ivyrep</a> to find ivy files, and ibiblio to find artifacts.</span>
It can also be configured to use other similar repositories.<br class="xooki-br"/>
<div class="tip">
Since ivyrep is not maintained anymore, the ivyroot attribute is mandatory, and the use of this resolver is not recommended (we recommend using <a href="resolver/url.html">url resolver</a> as replacement in most cases).
</div>

<h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>ivyroot</td><td>the root of the ivy repository.</td>
        <td>Yes, but may be provided through ${ivy.ivyrep.default.ivy.root} <span class="since">since 2.0</span></td></tr>
    <tr><td>ivypattern</td><td>a pattern describing the layout of the ivy repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.ivy.pattern}</td></tr>
    <tr><td>artroot</td><td>the root of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.artifact.root}</td></tr>
    <tr><td>artpattern</td><td>a pattern describing the layout of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ivyrep.default.artifact pattern}</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivyrep name="ivyrep" ivyroot="<a href="http://ivyrep.mycompany.com">http://ivyrep.mycompany.com</a>"/&gt;
</pre>
Looks for ivy files on and ivyrep like web site located at <a href="http://ivyrep.mycompany.com">http://ivyrep.mycompany.com</a>.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>IBiblio Resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ibiblio</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes, at least if the repository server is apache based</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<span class="tagdoc" id="ivysettings.resolvers.ibiblio">This resolver usually uses ibiblio to find artifacts. </span>

<span class="since">since 1.3</span> Using the m2compatible attribute, you can benefit from maven 2 repository compatibility (convert dots in organisation into slashes, search for poms, use transitive dependencies of poms). This setting also affects the default place where the resolver looks for its artifacts to point to the maven2 repository. So setting this attribute to true is sufficient to use maven 2 ibiblio repository.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> When using the m2compatible flag, you can disable the use of poms by setting the usepoms flag to false. It is then roughly equivalent to a url resolver configured like this:
<pre>
&lt;url name="test" m2compatible="true"&gt;<br class="xooki-br"/>  &lt;artifact pattern="<a href="http://repo1.maven.org/maven2/[organisation]/[module]/[revision]/[artifact]-[revision].[ext">http://repo1.maven.org/maven2/[organisation]/[module]/[revision]/[artifact]-[revision].[ext</a>]"/&gt;<br class="xooki-br"/>&lt;/url&gt;
</pre>

<span class="since">since 2.0</span> When used in m2compatible mode with the default pattern, this resolver uses maven-metadata.xml files (if present) to list the revisions available on the repository. This is especially useful when using a maven specific proxy, which does not serve directory listing. This can be disabled by using the useMavenMetadata flag.<br class="xooki-br"/><br class="xooki-br"/><strong>Limitation</strong>: in m2compatible mode, this resolver is not able list available organizations. It means some features like <a href="use/repreport.html">repreport</a> are not available.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>root</td><td>the root of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ibiblio.default.artifact.root}</td></tr>
    <tr><td>pattern</td><td>a pattern describing the layout of the artifacts repository.</td>
        <td>No, defaults to ${ivy.ibiblio.default.artifact.pattern}</td></tr>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>usepoms</td><td>True if this resolver should use maven poms when it is already in m2compatible mode, false otherwise <span class="since">since 1.4</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>useMavenMetadata</td><td>True if this resolver should use maven-metadata.xml files to list available revisions, false to use directory listing <span class="since">since 2.0</span></td>
        <td>No, defaults to true</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;ibiblio name="maven2" m2compatible="true"/&gt;
</pre>
Defines a resolver called "maven2" using the maven 2 public repository to find module metadata (using maven 2 poms) and artifacts.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ibiblio name="maven" m2compatible="true" usepoms="false"/&gt;
</pre>
Same as above, but doesn't use poms, only artifacts.<hr/><div class='toc-title toc-title-5'>Packager resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">packager</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes with http urls (and apache server) and with file urls, no with other urls</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<br/>
<p>
<span class="since">Since 2.0</span>.<br class="xooki-br"/></p>

<p>
<span class="tagdoc" id="ivysettings.resolvers.packager">This resolver accesses ivy files and "packaging instructions" from an online "packager" repository.</span> "Packager" repositories contain no actual artifacts. To get the artifacts, the packaging instructions are downloaded from the repository and executed locally. These instructions specify additional resource(s) to download and how to create the artifacts from them, for example, by downloading a project's original distribution archive directly from their web site and extracting the desired artifacts.<br class="xooki-br"/></p>

<p>
Packager repositories allow the creation of Ivy repositories that require neither the participation of any of the modules' creators nor setting up a huge mirror site. One such repository on the web is <a href="http://ivyroundup.googlecode.com/">Ivy RoundUp</a>. Of course, private packager repositories are feasible as well.<br class="xooki-br"/></p>

<p>
The Packager resolver supports a "resource cache", where downloaded archives can be stored to avoid duplicate downloads. This cache is entirely separate from the <a href="../concept.html#cache">normal Ivy cache</a>: it is "private" to the Packager resolver, and it stores unmodified original software archives, not Ivy artifacts. See the <span class="ivy-att">resourceCache</span> attribute below for details.<br class="xooki-br"/></p>

<p>
The packaging instructions are contained in "packager.xml" in a simple XML format. At resolve time this file gets converted into a "build.xml" file via XSLT and then executed using <a href="http://ant.apache.org/">ant</a>. Therefore, ant must be available as an executable on the platform. The ant task executes in a separate ant project and so is not affected by properties, etc. that may be set in any existing ant environment in which Ivy is running. However, Ivy will define a few properties for convenience; see the "Properties" listed below.<br class="xooki-br"/></p>

<p>
For security reasons, the XSLT transform ensures that (a) all downloaded archives have verified SHA1 checksums (including cached resources); and (b) only a very limited set of ant tasks can be performed during the artifact "build" phase; currently these include move, copy, mkdir, zip, unzip, tar, and untar (this restriction may be overridden however; see below).<br class="xooki-br"/></p>

<p>
The Packager resolver is based on the <a href="url.html">URL resolver</a> and is configured similarly, except the artifact child tags specify where to find the packager.xml files, rather than the artifacts themselves.<br class="xooki-br"/></p>

<p>
Because the packaging process is relatively slow, it is important to use <a href="../concept.html#cache">Ivy's caching support</a> to avoid repeated execution of the packaging instructions.<br class="xooki-br"/></p>

<h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers, plus the following:
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
  <tr>
    <td>buildRoot</td>
    <td>Defines the root of the temporary build directory hierarchy</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>resourceCache</td>
    <td>Directory where downloaded resources should be cached</td>
    <td>No; defaults to none</td>
  </tr>
  <tr>
    <td>resourceURL</td>
    <td>Ivy pattern that specifies a base URL to use for downloading <i>all</i> resources; overrides the URLs in the packaging instructions</td>
    <td>No; defaults to none</td>
  </tr>
  <tr>
    <td>restricted</td>
    <td>True if this resolver should only allow "safe" ant tasks in the packaging instructions. <strong>Warning:</strong> setting <span class="ivy-att">restricted</span> to false creates a security problem due to ant tasks like delete, exec, etc. Do not use this setting when your configuration points to an untrusted repository.</td>
    <td>No; defaults to true</td>
  </tr>
  <tr>
    <td>verbose</td>
    <td>True to run ant with the -verbose flag</td>
    <td>No; defaults to false</td>
  </tr>
  <tr>
    <td>quiet</td>
    <td>True to run ant with the -quiet flag</td>
    <td>No; defaults to false</td>
  </tr>
  <tr>
    <td>validate</td>
    <td>True if this resolver should validate (via XSD) the downloaded XML packaging instructions</td>
    <td>No; defaults to true</td>
  </tr>
  <tr>
    <td>preserveBuildDirectories</td>
    <td>True if this resolver should not delete the temporary build directories in which the ant tasks are executed (for debugging purposes)</td>
    <td>No; defaults to false</td>
  </tr>
</tbody>
</table>
<br />
<p>
Setting a resourceURL will cause the resolver to override the URLs for resources specified by the packaging instructions. Instead, all resources will be downloaded from an URL constructed by first resolving the resourceURL pattern into a base URL, and then resolving the resource filename relative to that base URL. In other words, the resourceURL pattern specifies the URL "directory", so it should always end in a forward slash.<br class="xooki-br"/></p>

<p>
If a resourceURL download fails, the resolver will fall back to the original URL from the packaging instructions.<br class="xooki-br"/></p>

<p>
Configure a resourceURL in situations where you don't want to rely on (or wait for) the web sites configured in the packaging instructions, and have access to a better (perhaps private) mirror site.<br class="xooki-br"/></p>

<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>Defines a pattern for ivy.xml files, using the pattern attribute</td>
    <td>1..n</td></tr>
    <tr><td>artifact</td><td>Defines a pattern for packager.xml files, using the pattern attribute</td>
    <td>1..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;packager name="ivyroundup"<br class="xooki-br"/>         buildRoot="${user.home}/.ivy2/packager/build"<br class="xooki-br"/>         resourceCache="${user.home}/.ivy2/packager/cache"<br class="xooki-br"/>         resourceURL="<a href="ftp://mirror.example.com/pub/resources/[organisation]/[module]/">ftp://mirror.example.com/pub/resources/[organisation]/[module]/</a>"&gt;<br class="xooki-br"/>    &lt;ivy pattern="<a href="http://ivyroundup.googlecode.com/svn/trunk/repo/modules/[organisation]/[module]/[revision]/ivy.xml">http://ivyroundup.googlecode.com/svn/trunk/repo/modules/[organisation]/[module]/[revision]/ivy.xml</a>"/&gt;<br class="xooki-br"/>    &lt;artifact pattern="<a href="http://ivyroundup.googlecode.com/svn/trunk/repo/modules/[organisation]/[module]/[revision]/packager.xml">http://ivyroundup.googlecode.com/svn/trunk/repo/modules/[organisation]/[module]/[revision]/packager.xml</a>"/&gt;<br class="xooki-br"/>&lt;/packager&gt;
</pre>
Defines a packager resolver which points to the <a href="http://ivyroundup.googlecode.com/">Ivy RoundUp</a> online repository. Builds will occur in a subdirectory of <pre>${user.home}/.ivy2/packager/build</pre> downloaded resources will be cached in <pre>${user.home}/.ivy2/packager/cache</pre> and the mirror site <pre><a href="ftp://mirror.example.com/pub/resources/[organisation]/[module]/">ftp://mirror.example.com/pub/resources/[organisation]/[module]/</a> </pre> will be tried first for all resources.<br class="xooki-br"/><br class="xooki-br"/><h1>Packaging Instructions</h1>
<p>
The goal of the packaging instructions is to download the required archives, extract the artifacts, and put the artifacts into a subdirectory. Each artifact should be written to artifacts/[type]s/[artifact].[ext] when the ant build completes.<br class="xooki-br"/></p>

<p>
Below is an example of packaging instructions for <a href="http://testng.org/">TestNG 2.5</a>:
<pre>
&lt;packager-module version="1.0"&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;property name="name" value="${ivy.packager.module}"/&gt;<br class="xooki-br"/>    &lt;property name="version" value="${ivy.packager.revision}"/&gt;<br class="xooki-br"/>    &lt;property name="zipname" value="${name}-${version}"/&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;resource dest="archive" url="<a href="http://testng.org/${zipname}.zip">http://testng.org/${zipname}.zip</a>" sha1="2ea19275dc17453306f8bb780fe6ef6e9af7756b"&gt;<br class="xooki-br"/>        &lt;url href="http://mirror.example.com/archives/${zipname}.zip"/&gt;<br class="xooki-br"/>        &lt;include name="${zipname}/src/main/**/*"/&gt;<br class="xooki-br"/>        &lt;include name="${zipname}/src/jdk15/**/*"/&gt;<br class="xooki-br"/>        &lt;include name="${zipname}/javadocs/**/*"/&gt;<br class="xooki-br"/>        &lt;include name="${zipname}/*.jar"/&gt;<br class="xooki-br"/>    &lt;/resource&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;build&gt;<br class="xooki-br"/><br class="xooki-br"/>        &lt;!-- jar  --&gt;<br class="xooki-br"/>        &lt;move file="archive/${zipname}/${zipname}-jdk14.jar" tofile="artifacts/jars/${name}-jdk14.jar"/&gt;<br class="xooki-br"/>        &lt;move file="archive/${zipname}/${zipname}-jdk15.jar" tofile="artifacts/jars/${name}-jdk15.jar"/&gt;<br class="xooki-br"/><br class="xooki-br"/>        &lt;!-- source --&gt;<br class="xooki-br"/>        &lt;zip destfile="artifacts/sources/${name}.zip"&gt;<br class="xooki-br"/>            &lt;fileset dir="archive/${zipname}/src/main"&gt;<br class="xooki-br"/>                &lt;include name="**/*.java"/&gt;<br class="xooki-br"/>            &lt;/fileset&gt;<br class="xooki-br"/>            &lt;fileset dir="archive/${zipname}/src/jdk15"&gt;<br class="xooki-br"/>                &lt;include name="**/*.java"/&gt;<br class="xooki-br"/>            &lt;/fileset&gt;<br class="xooki-br"/>        &lt;/zip&gt;<br class="xooki-br"/><br class="xooki-br"/>        &lt;!-- javadoc --&gt;<br class="xooki-br"/>        &lt;zip destfile="artifacts/javadocs/javadoc.zip"&gt;<br class="xooki-br"/>            &lt;fileset dir="archive/${zipname}/javadocs"/&gt;<br class="xooki-br"/>        &lt;/zip&gt;<br class="xooki-br"/>    &lt;/build&gt;<br class="xooki-br"/>&lt;/packager-module&gt;
</pre>
Of course, packaging instructions must produce artifacts consistent with those listed in the associated ivy.xml file.<br class="xooki-br"/></p>

<h1>Build-time properties</h1>
This resolver ensures following ant properties are defined when it executes the ant build task.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Property</th><th class="ivy-att-desc">Description</th></tr>
</thead>
<tbody>
  <tr>
    <td>ivy.packager.organisation</td>
    <td>Organization of the ivy module whose artifacts are being built</td>
  </tr>
  <tr>
    <td>ivy.packager.module</td>
    <td>Module of the ivy module whose artifacts are being built</td>
  </tr>
  <tr>
    <td>ivy.packager.revision</td>
    <td>Revision of the ivy module whose artifacts are being built</td>
  </tr>
  <tr>
    <td>ivy.packager.branch</td>
    <td>Branch of the ivy module whose artifacts are being built</td>
  </tr>
  <tr>
    <td>ivy.packager.resourceCache</td>
    <td>The configured <span class="ivy-att">resourceCache</span> if any; otherwise not defined</td>
  </tr>
  <tr>
    <td>ivy.packager.resourceURL</td>
    <td>The resolved <span class="ivy-att">resourceURL</span> pattern if any; otherwise not defined</td>
  </tr>
</tbody>
</table>

<h1>Packager XML Elements</h1>
The packager.xml document element can contain the following child tags.
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
  <tr>
    <td>property</td>
    <td>Set an ant property</td>
    <td>0..n</td>
  </tr>
  <tr>
    <td>resource</td>
    <td>Define a resource to download and (optionally) unpack</td>
    <td>0..n</td>
  </tr>
  <tr>
    <td>m2resource</td>
    <td>Define a Maven2 resource to download and (optionally) unpack</td>
    <td>0..n</td>
  </tr>
  <tr>
    <td>build</td>
    <td>Specify ant tasks that ultimately result in each artifact being placed into artifacts/[type]s/[artifact].[ext]</td>
    <td>0..1</td>
  </tr>
</tbody>
</table>
<br />
Which ant tasks are allowed within the build tag is controlled by the <span class="ivy-att">restricted</span> configuration attribute. When true (the default), only the following ant tasks are allowed: copy, jar, mkdir, move, tar, unjar, untar, unwar, unzip, war, and zip. When false, all ant tasks are allowed.<br class="xooki-br"/><br class="xooki-br"/><p>
<strong>Warning:</strong> setting <span class="ivy-att">restricted</span> to false creates a security problem due to ant tasks like delete, exec, etc. Do not use this setting when your configuration points to an untrusted repository.<br class="xooki-br"/></p>

<h1>Resource XML Elements</h1>
The resource XML tag supports the following attributes:
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
  <tr>
    <td>url</td>
    <td>Primary URL for the resource</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>sha1</td>
    <td>SHA1 checksum of the resource</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>dest</td>
    <td>Defines the name of the subdirectory into which the artifact should be unpacked</td>
    <td>No; defaults to "archive"</td>
  </tr>
  <tr>
    <td>tofile</td>
    <td>Where to put the file directly; if present no extraction will be performed</td>
    <td>No; if present, "dest" is ignored</td>
  </tr>
  <tr>
    <td>filename</td>
    <td>Name of the file to download</td>
    <td>No; if not present, same as the last component of the URL</td>
  </tr>
  <tr>
    <td>type</td>
    <td>Type of archive: "zip", "jar", "war", "tar", "tgz", "tar.gz", "tar.bz2"</td>
    <td>No; if not present, will be automatically determined from the filename suffix</td>
  </tr>
</tbody>
</table>
<br />
The resource XML tag may contain child elements. An url tag with an href attribute specifies an alternate URL for the resource (see TestNG example above). Any other tags will be included as children of an automatically generated fileset tag.<br class="xooki-br"/><br class="xooki-br"/><h1>Maven2 Resources</h1>
Special support is included for maven2 resources. For these resources, use the m2resource tag instead of the resource tag. Each m2resource tag specifies one or more artifacts that are downloaded from the Maven2 repository.<br class="xooki-br"/><br class="xooki-br"/><h1>M2Resource XML Elements</h1>
The m2resource XML tag supports the following attributes:
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
  <tr>
    <td>groupId</td>
    <td>Maven group ID</td>
    <td>No; defaults to ${ivy.packager.organisation}</td>
  </tr>
  <tr>
    <td>artifactId</td>
    <td>Maven artifact ID</td>
    <td>No; defaults to ${ivy.packager.module}</td>
  </tr>
  <tr>
    <td>version</td>
    <td>Maven version</td>
    <td>No; defaults to ${ivy.packager.revision}</td>
  </tr>
  <tr>
    <td>repo</td>
    <td>Maven repository URL</td>
    <td>No; defaults to <a href="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</a> </td>
  </tr>
</tbody>
</table>
<br />
Each m2resource XML tag must have one or more artifact tags that define the artifacts to directly download. The URL for each artifact is constructed automatically based on the attributes in the m2resource and artifact tags.<br class="xooki-br"/><br class="xooki-br"/><h1>M2Resource Artifact Attributes</h1>
The artifact children of m2resource tags support the following attributes:
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
  <tr>
    <td>ext</td>
    <td>Maven filename extension</td>
    <td>No; defaults to "jar"</td>
  </tr>
  <tr>
    <td>classifier</td>
    <td>Maven classifier (e.g., "sources", "javadoc")</td>
    <td>No; defaults to none</td>
  </tr>
  <tr>
    <td>sha1</td>
    <td>SHA1 checksum of the resource</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>dest</td>
    <td>Defines the name of the subdirectory into which the artifact should be unpacked</td>
    <td rowspan="2">Exactly one of "dest" or "tofile" must be supplied</td>
  </tr>
  <tr>
    <td>tofile</td>
    <td>Where to put the file; no extraction will be performed</td>
  </tr>
  <tr>
    <td>type</td>
    <td>Type of archive: "zip", "jar", "war", "tar", "tgz", "tar.gz", "tar.bz2"</td>
    <td>No; if not present, will be automatically determined from the filename suffix</td>
  </tr>
</tbody>
</table>
<br />
Below is an example of packaging instructions for the <a href="http://commons.apache.org/email/">Apache Commons Email</a> module. Note that no build tag is required because all of the maven2 artifacts are usable directly (i.e., without unpacking anything).
<pre>
&lt;packager-module version="1.0"&gt;<br class="xooki-br"/>    &lt;m2resource&gt;<br class="xooki-br"/>        &lt;artifact tofile="artifacts/jars/${ivy.packager.module}.jar" sha1="a05c4de7bf2e0579ac0f21e16f3737ec6fa0ff98"/&gt;<br class="xooki-br"/>        &lt;artifact classifier="javadoc" tofile="artifacts/javadocs/javadoc.zip" sha1="8f09630f1600bcd0472a36fb2fa2d2a6f2836535"/&gt;<br class="xooki-br"/>        &lt;artifact classifier="sources" tofile="artifacts/sources/source.zip" sha1="15d67ca689a792ed8f29d0d21e2d0116fa117b7e"/&gt;<br class="xooki-br"/>    &lt;/m2resource&gt;<br class="xooki-br"/>&lt;/packager-module&gt;
</pre>

	<hr/><div class='toc-title toc-title-5'>File System resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">filesystem</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">yes</td></tr>
</table><br/>

<span class="tagdoc" id="ivysettings.resolvers.filesystem">This resolver uses the file system to resolve ivy files and artifacts.</span> An advantage of this resolver is that it usually provides very good performance. Moreover, it is easy to setup using basic OS file sharing mechanisms.<br class="xooki-br"/><br class="xooki-br"/>The configuration of such a resolver is mainly done through ivy and artifact patterns, indicating where ivy files and artifacts can be found in the file system. These patterns must be absolute paths (<span class="since">since 2.0</span>). You can indicate a list of patterns which will be checked one after the other.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> Using the m2compatible attribute, this resolver will convert dots found in organisation into slashes like maven2 does for groupId. For instance, it will transform the organisation from 'com.company' into 'com/company' when replacing the token [organisation] in your pattern.<br class="xooki-br"/><strong>Limitation</strong>: in m2compatible mode, this resolver is not able list available organizations. It means some features like <a href="use/repreport.html">repreport</a> are not available.<br class="xooki-br"/><br class="xooki-br"/><h2>Atomic publish support</h2>
<span class="since">since 2.0</span> This resolver supports atomic publish, which is useful for environments with a lot of concurrent publish and resolve actions. The atomic publish relies on the atomicity of the rename operation in the underlying filesystem (which includes NTFS and POSIX based filesystems).<br class="xooki-br"/>In this case the resolver starts by publishing the module according to the pattern, but where a '.part' suffix is appended to the revision. Then the publish is committed with a rename to the final location. <br class="xooki-br"/><br class="xooki-br"/><b>Limitations</b><br class="xooki-br"/>Atomic publish is currently limited in several ways:
<ul>
<li>you need to use a pattern for both the artifact and the ivy files which uses the revision as a directory. For instance "${repository.dir}/[module]/[revision]/[artifact].[ext]" works, "${repository.dir}/[module]/[artifact]-[revision].[ext]" doesn't</li>
<li>both the artifact and ivy pattern should have the same prefix until the [revision] token.</li>
<li>overwrite during publish is not supported</li>
<li>you should not use revision names ending with '.part'</li>
</ul>

The <b>transactional</b> attribute can be used to configure the atomicity behavior:
<ul>
<li>auto</li> use transaction if possible (according to limitation), otherwise don't
<li>true</li> always use transaction, fail the build if a limitation is not fulfilled
<li>false</li> don't use transaction at all
</ul>


<h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>local</td><td>True if this resolver should be considered local, false otherwise <span class="since">since 1.4</span>. See useOrigin attribute on the <a href="settings/caches.html">caches</a> element for details.</td>
        <td>No, defaults to true</td></tr>
    <tr><td>transactional</td><td>true to force the use of transaction, false to prevent the use of transaction, auto to get transaction when possible <span class="since">since 2.0</span>. See above for details.</td>
        <td>No, defaults to auto</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>Url Resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">url</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes with http urls (and apache server) and with file urls, no with other urls</td></tr>
<tr><td class="title">Handle publish</td><td class="value">yes with http urls whose destination supports publishing (as of Ivy 2.0)</td></tr>
</table>

<br/>
<span class="tagdoc" id="ivysettings.resolvers.url">This resolver is one of the most generic. In fact, most of the previous resolvers can be obtained by a particular configuration of this one.</span> Indeed it uses urls to find ivy files and artifacts. The urls it uses are defined through ivy and artifact children, each giving a pattern to find ivy files or artifacts.<br class="xooki-br"/><br class="xooki-br"/><strong>Limitation</strong>: in m2compatible mode, this resolver is not able list available organizations. It means some features like <a href="use/repreport.html">repreport</a> are not available.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Example</h1>
<pre>
&lt;url name="two-patterns-example"&gt;<br class="xooki-br"/>  &lt;ivy pattern="<a href="http://ivyrep.mycompany.com/[module]/[revision]/ivy-[revision].xml">http://ivyrep.mycompany.com/[module]/[revision]/ivy-[revision].xml</a>" /&gt;<br class="xooki-br"/>  &lt;artifact pattern="<a href="http://ivyrep.mycompany.com/[module]/[revision]/[artifact]-[revision].[ext">http://ivyrep.mycompany.com/[module]/[revision]/[artifact]-[revision].[ext</a>]" /&gt;<br class="xooki-br"/>  &lt;artifact pattern="<a href="http://ivyrep.mycompany.com/[module]/[revision]/[artifact].[ext">http://ivyrep.mycompany.com/[module]/[revision]/[artifact].[ext</a>]" /&gt;<br class="xooki-br"/>&lt;/url&gt;
</pre>
Looks for ivy files in one place and for artifacts in two places: with or without revision in name (revision being already in the directory structure).<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>Chain Resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">chain</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depends on sub resolvers</td></tr>
<tr><td class="title">Handle publish</td><td class="value">delegates to first sub resolver in chain</td></tr>
</table>

<span class="tagdoc" id="ivysettings.resolvers.chain">This resolver is only a container of a chain of other resolvers.</span> The sub resolvers can be any resolver, including a chain. An attribute enable to indicate if the chain must be iterated after the first found or not (at least when asking for a latest revision). If the chain is iterated, then it's the latest among the ones found that is returned. If the chain is not iterated, then it's the first found which is returned.<br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of composite resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>returnFirst</td><td>true if the first found should be returned.</td>
        <td>No, defaults to false</td></tr>
    <tr><td>dual</td><td>true if the chain should behave like a dual chain. <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any resolver</td><td>a sub resolver to use</td>
        <td>1..n</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;chain name="test"&gt;<br class="xooki-br"/>  &lt;filesystem name="1"&gt;<br class="xooki-br"/>    &lt;ivy pattern="${ivy.settings.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/&gt;<br class="xooki-br"/>    &lt;artifact pattern="${ivy.settings.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>  &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;ivyrep name="2"/&gt;<br class="xooki-br"/>&lt;/chain&gt;
</pre>
Both a filesystem and ivyrep will be used to look for ivy files. If a dynamic revision is required, then both the filesystem and ivyrep will be queried to find the most recent revision among the two resolvers. Once the most recent revision is found in one resolver, it's the same resolver which will be used to download artifacts.<br class="xooki-br"/><hr/>
<pre>
&lt;chain name="test" returnFirst="true"&gt;<br class="xooki-br"/>  &lt;filesystem name="1"&gt;<br class="xooki-br"/>    &lt;ivy pattern="${ivy.settings.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/&gt;<br class="xooki-br"/>    &lt;artifact pattern="${ivy.settings.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>  &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;ivyrep name="2"/&gt;<br class="xooki-br"/>&lt;/chain&gt;
</pre>
Same as before, except that if a revision is found in the filesystem then ivyrep will not be queried: its the filesystem which will be used for both the ivy file and the artifacts.<br class="xooki-br"/><hr/>
<pre>
&lt;chain name="test" dual="true"&gt;<br class="xooki-br"/>  &lt;filesystem name="1"&gt;<br class="xooki-br"/>    &lt;ivy pattern="${ivy.settings.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/&gt;<br class="xooki-br"/>    &lt;artifact pattern="${ivy.settings.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/&gt;<br class="xooki-br"/>  &lt;/filesystem&gt;<br class="xooki-br"/>  &lt;ivyrep name="2"/&gt;<br class="xooki-br"/>&lt;/chain&gt;
</pre>
Same as first example, except that once a module is found by either filesystem or ivyrep, then it's the whole chain which will be queried to download the artifacts. So in this case ivy file and artifacts may be split across the two resolvers for the same module.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>Dual resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">dual</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depends on sub resolvers</td></tr>
<tr><td class="title">Handle publish</td><td class="value">delegates to ivy sub resolver if artifact to publish is of "ivy" type, to artifact sub resolver otherwise</td></tr>
</table>

<span class="tagdoc" id="ivysettings.resolvers.dual">This resolver delegates its job to one resolver for ivy files and another for artifacts.</span>

<h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of composite resolvers.<br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any resolver</td><td>two resolvers, the first being the ivy resolver, the second the artifact resolver</td>
        <td>2</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>sftp resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">sftp</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">yes</td></tr>
</table>

<br/>
<span class="tagdoc" id="ivysettings.resolvers.sftp">This resolver can be used when your ivy repository is located on a server accessible via sftp.</span> The secured nature of sftp and its widespread implementation on most *nix servers makes this resolver a very good candidate in an enterprise environment. <span class="since">since 1.4</span>

If your server supports ssh but not sftp, there is also an <a href="../resolver/ssh.html">ssh resolver</a>.<br class="xooki-br"/><br class="xooki-br"/>Note that sftp is also supported by vfs, so you can use a vfs resolver instead. The advantage of this resolver is that you have a better control over authentication, it can prompt for username/password credentials, or you can use private/public key authentication, which is not possible with the vfs resolver. When it prompts for username/password, it uses a Swing dialog, which is not possible in a headless environment. If you want to prompt for the credentials on the command line, use ant input task for example before calling ivy.<br class="xooki-br"/><br class="xooki-br"/>All necessary connection parameters can be set here via attributes.<br class="xooki-br"/>However all attributes defined in the pattern url of the resolver will have higher priority and will overwrite the values given here. To specify connection parameters in the pattern, you have to specify a full url and not just a path as pattern.<br class="xooki-br"/>e.g. pattern="/path/to/my/repos/[artifact].[ext]" will use all connection parameters from this class<br class="xooki-br"/>e.g. pattern="s<a href="ftp://myserver.com/path/to/my/repos/[artifact].[ext">ftp://myserver.com/path/to/my/repos/[artifact].[ext</a>]" will use all parameters from the attributes with the exception of the host, which will be "myserver.com"<br class="xooki-br"/>e.g. pattern="s<a href="ftp://user:geheim@myserver.com:8022/path/to/my/repos/[artifact].[ext">ftp://user:geheim@myserver.com:8022/path/to/my/repos/[artifact].[ext</a>]" will use only the keyFile and keyFilePassword from the attributes (if needed). Rest will come from the url.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>Note that the authentication features of this resolver are exactly the same as the ssh resolver. Choosing between the two is often a matter of server implementation. If your server supports sftp, usually it's preferrable.<br class="xooki-br"/><br class="xooki-br"/>Internally this resolver relies on <a href="http://www.jcraft.com/jsch/">jsch</a> as ssh client, which is a popular java ssh client, used for example in eclipse.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>user</td><td>The username to provide as credential</td>
        <td>No, defaults to username given on the patterns, or prompt if none is set</td></tr>
    <tr><td>userPassword</td><td>The password to provide as credential</td>
        <td>No, defaults to password given on the patterns, or prompt if none is set</td></tr>
    <tr><td>keyFile</td><td>Path to the keyfile to use for authentication</td>
        <td>No, defaults to username/password authentication</td></tr>
    <tr><td>keyFilePassword</td><td>the password used to protect the key file</td>
        <td>No, will prompt for password if keyFile authentication is used and if it is password encrypted</td></tr>
    <tr><td>host</td><td>The host to connect to</td>
        <td>No, defaults to host given on the patterns, fail if none is set</td></tr>
    <tr><td>port</td><td>The port to connect to</td>
        <td>No, defaults to 22</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Example</h1>
<pre>
&lt;sftp user="myuser" host="myhost.com"&gt;<br class="xooki-br"/>  &lt;ivy pattern="/path/to/ivy/[module]/ivy.xml"/&gt;<br class="xooki-br"/>  &lt;artifact pattern="/path/to/[organisation]/[module]/[artifact].[ext]"/&gt;<br class="xooki-br"/>&lt;/sftp&gt; 
</pre>
Will connect to myhost.com using myuser and prompt for the password.<br class="xooki-br"/><hr/>
<pre>
&lt;sftp user="${myuser}" userPassword="${my.password}" host="myhost.com"&gt;<br class="xooki-br"/>  &lt;ivy pattern="path/to/ivy/[module]/ivy.xml"/&gt;<br class="xooki-br"/>  &lt;artifact pattern="path/to/[organisation]/[module]/[artifact].[ext]"/&gt;<br class="xooki-br"/>&lt;/sftp&gt;
</pre>
Will connect to myhost.com using user and password provided with ivy variables.<br class="xooki-br"/><hr/>
<pre>
&lt;sftp&gt;<br class="xooki-br"/>  &lt;ivy pattern="s<a href="ftp://user:geheim@yourserver.com:8022/path/to/repos/[module]/[revision]/ivy.xml">ftp://user:geheim@yourserver.com:8022/path/to/repos/[module]/[revision]/ivy.xml</a>"/&gt;<br class="xooki-br"/>  &lt;artifact pattern="s<a href="ftp://user:secret@myserver.com:8022/path/to/my/repos/[artifact].[ext">ftp://user:secret@myserver.com:8022/path/to/my/repos/[artifact].[ext</a>]"/&gt;<br class="xooki-br"/>&lt;/sftp&gt;
</pre>
Will connect to yourserver.com on port 8022 with user 'user' and password 'geheim' for authentication for ivy files, and to myserver.com on port 8022 using user 'user' and password 'secret' for the artifacts.<br class="xooki-br"/><hr/>
<pre>
&lt;sftp keyFile="path/to/key/file" keyFilePassword="${password}"&gt;<br class="xooki-br"/>  &lt;ivy pattern="s<a href="ftp://user@yourserver.com:8022/path/to/repos/[module]/[revision]/ivy.xml">ftp://user@yourserver.com:8022/path/to/repos/[module]/[revision]/ivy.xml</a>"/&gt;<br class="xooki-br"/>  &lt;artifact pattern="s<a href="ftp://user@myserver.com:8022/path/to/my/repos/[artifact].[ext">ftp://user@myserver.com:8022/path/to/my/repos/[artifact].[ext</a>]"/&gt;<br class="xooki-br"/>&lt;/sftp&gt;
</pre>
Will connect to yourserver.com on port 8022 with user 'user' and use keyFile path/to/key/file for keyFile and the value of password variable for keyFilePassword authentication for ivy files, and to myserver.com on port 8022 using user 'user' with the same keyFile/keyFilePassword pair for the artifacts.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>ssh resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">ssh</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">yes</td></tr>
</table>

<br/>
<span class="tagdoc" id="ivysettings.resolvers.ssh">This resolver can be used when your ivy repository is located on a server accessible via ssh.</span> The secured nature of ssh and its widespread implementation on most *nix servers makes this resolver a very good candidate in an enterprise environment. <span class="since">since 1.4</span>

If your server supports sftp, you can consider using the <a href="../resolver/sftp.html">sftp resolver</a>.<br class="xooki-br"/><br class="xooki-br"/>Internally this resolver shares most of its behaviour with the <a href="../resolver/sftp.html">sftp resolver</a>, so refer to its documentation for details.<br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>user</td><td>The username to provide as credential</td>
        <td>No, defaults to username given on the patterns, or prompt if none is set</td></tr>
    <tr><td>userPassword</td><td>The password to provide as credential</td>
        <td>No, defaults to password given on the patterns, or prompt if none is set</td></tr>
    <tr><td>keyFile</td><td>Path to the keyfile to use for authentication</td>
        <td>No, defaults to username/password authentication</td></tr>
    <tr><td>keyFilePassword</td><td>the password used to protect the key file</td>
        <td>No, will prompt for password if keyFile authentication is used and if it is password encrypted</td></tr>
    <tr><td>host</td><td>The host to connect to</td>
        <td>No, defaults to host given on the patterns, fail if none is set</td></tr>
    <tr><td>port</td><td>The port to connect to</td>
        <td>No, defaults to 22</td></tr>
    <tr><td>publishPermissions</td><td>A four digit string (e.g., 0644, see "man chmod", "man open") specifying the permissions of the published files. <span class="since">(since 2.0)</span>
</td><td>No, defaults to scp standard behaviour</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Example</h1>
<pre>
&lt;ssh user="myuser" host="myhost.com"&gt;<br class="xooki-br"/>  &lt;ivy pattern="/path/to/ivy/[module]/ivy.xml"/&gt;<br class="xooki-br"/>  &lt;artifact pattern="/path/to/[organisation]/[module]/[artifact].[ext]"/&gt;<br class="xooki-br"/>&lt;/ssh&gt; 
</pre>
Will connect to myhost.com using myuser and prompt for the password.<br class="xooki-br"/><hr/>
<pre>
&lt;ssh keyFile="path/to/key/file" keyFilePassword="${password}"&gt;<br class="xooki-br"/>  &lt;ivy pattern="ssh://user:geheim@yourserver.com:8022/path/to/repos/[module]/[revision]/ivy.xml"/&gt;<br class="xooki-br"/>  &lt;artifact pattern="ssh://user:geheim@myserver.com:8022/path/to/my/repos/[artifact].[ext]"/&gt;<br class="xooki-br"/>&lt;/ssh&gt;
</pre>
Will connect to yourserver.com on port 8022 with user geheim and use keyFile path/to/key/file for keyFile and the value of password variable for keyFilePassword authentication for ivy files, and to myserver.com on port 8022 using user geheim with the same keyFile/keyFilePassword pair for the artifacts.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>vfs resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">vfs</td></tr>
<tr><td class="title">Handle latest</td><td class="value">depend on vfs capacity, usually yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">depend on vfs capacity, usually yes</td></tr>
</table>
<br/>
<span class="tagdoc" id="ivysettings.resolvers.vfs">This resolver is certainly the most capable, since it relies on <a href="http://jakarta.apache.org/commons/vfs/">Apache commons VFS</a>, which gives an uniform access to <a href="http://jakarta.apache.org/commons/vfs/filesystems.html">a good number of file systems</a>, including ftp, webdav, zip, ...</span> <span class="since">since 1.4</span>

<i>Note: commons vfs has not released a stable version yet, hence Ivy relies on a nightly build. Stability should thus be considered carefully before using this resolver in a production environment</i><br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.<br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Example</h1>
<pre>
&lt;vfs name="vfs-resolver"&gt;<br class="xooki-br"/>  &lt;ivy pattern="s<a href="ftp://username:password@host/[organisation]/[module]/[revision]/ivy.xml">ftp://username:password@host/[organisation]/[module]/[revision]/ivy.xml</a>" /&gt;<br class="xooki-br"/>  &lt;artifact pattern="s<a href="ftp://username:password@host/[organisation]/[module]/[revision]/[artifact].[ext">ftp://username:password@host/[organisation]/[module]/[revision]/[artifact].[ext</a>]" /&gt;<br class="xooki-br"/>&lt;/vfs&gt; 
</pre>
Access ivy and artifacts files using sftp.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>Jar resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">jar</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table><br/>

<span class="since">since 2.3</span>

<span class="tagdoc" id="ivysettings.resolvers.jar">This resolver uses a specified jar resolve ivy files and artifacts.</span>

This kind of resolver helps the packaging of an entire repository. Since the entire "repository" jar is expected to be local at some point, the size of a such repository should be considered to be not too large if it is expected to be remote; hence the artifacts in a such repo should be little in size.<br class="xooki-br"/><br class="xooki-br"/>The configuration of such a resolver is done via specifying the location of the jar, and through ivy and artifact patterns, indicating where ivy files and artifacts can be found in the jar. You can indicate a list of patterns which will be checked one after the other. Note that the patterns MUST NOT start with a slash.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>the absolute path of the jar</td>
        <td>One of 'file' or 'url' is required</td></tr>
    <tr><td>url</td><td>the url of the jar</td>
        <td>One of 'file' or 'url' is required</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;jar name="my-local-jar-resolver" file="/home/me/myrepo.jar"&gt;<br class="xooki-br"/>    &lt;ivy pattern="[organisation]/[module]/ivys/ivy-[revision].xml" /&gt;<br class="xooki-br"/>    &lt;artifact pattern="[organisation]/[module]/[type]s/[artifact]-[revision].[type]" /&gt;<br class="xooki-br"/>&lt;/jar&gt;
</pre>
A simple local jar repository.<br class="xooki-br"/><hr />
<pre>
&lt;jar name="my-remote-jar-resolver" url="<a href="http://www.mywebsite.com/dist/myrepo.jar">http://www.mywebsite.com/dist/myrepo.jar</a>"&gt;<br class="xooki-br"/>    &lt;ivy pattern="dir_in_jar/subdir_in_jar/[organisation]/[module]/ivys/ivy-[revision].xml" /&gt;<br class="xooki-br"/>    &lt;ivy pattern="dir_in_jar/another_subdir_in_jar/[organisation]/[module]/ivys/ivy-[revision].xml" /&gt;<br class="xooki-br"/>    &lt;artifact pattern="dir_in_jar/subdir_in_jar/[organisation]/[module]/[type]s/[artifact]-[revision].[type]" /&gt;<br class="xooki-br"/>    &lt;artifact pattern="dir_in_jar/another_subdir_in_jar/[organisation]/[module]/[type]s/[artifact]-[revision].[type]" /&gt;<br class="xooki-br"/>    &lt;artifact pattern="dir_in_jar/yet_another_subdir_in_jar/[organisation]/[module]/[type]s/[artifact]-[revision].[type]" /&gt;<br class="xooki-br"/>&lt;/jar&gt;
</pre>
A remote jar repository with multiple ivy and artifact patterns, patterns pointing in some sub directories in the jar.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>OSGi Bundle Repository</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">obr</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<span class="since">since 2.3</span>

<span class="tagdoc" id="ivysettings.resolvers.obr">This resolver is one of the resolver which supports <a href="../osgi.html">OSGi&#153;</a> dependencies. As part of the OSGi specification resides the OBR (OSGi Bundle Repository). The OBR defines the aggregation of the OSGi metadata of every bundle included in an repository. So contrary to the other resolvers, this resolver needs to get the descriptor of the repository (an obr.xml) before starting to resolve modules.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of composite resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>repoXmlURL</td><td>the URL of the obr.xml to load.</td>
        <td>Yes</td></tr>
    <tr><td>repoXmlFile</td><td>the local path of the obr.xml to load.</td>
        <td>Yes</td></tr>
    <tr><td>requirementStrategy</td><td>defines how strict should be the OSGi resolution. Can be one of <tt>first</tt> or <tt>noambiguity</tt></td>
        <td>No, default to <tt>noambiguity</tt></td></tr>
    <tr><td>metadataTtl</td><td>the time in milliseconds the obr.xml is considered up to date</td>
        <td>No, default to 3600000 (1 hour)</td></tr>
    <tr><td>forceMetadataUpdate</td><td>force the update of the obr.xml without checking its freshness</td>
        <td>No, default to false</td></tr>
</tbody>
</table>

The requirement strategy is defining how the resolver should behave in front of several choices. In the OSGi dependency model, an <tt>Import-Package</tt> requirement can be satisfied by several different bundles. So when resolving such requirement, Ivy will first look into the already resolved bundles if one provides that package. If it fails to find one, then two behaviours can occur:
<ul>
<li>if the requirement strategy is <tt>first</tt>, among the bundles statifying the requirement, it will shoose the first one. A warn will be logged ahout the choice Ivy has to arbitrarily do.</li>
<li>if the requirement strategy is <tt>noambiguity</tt>, Ivy will make the resolution fail.</li>
</ul>

<h1>Examples</h1>
<pre>
&lt;obr name="felix-repo" repoXmlURL="<a href="http://felix.apache.org/obr/releases.xml">http://felix.apache.org/obr/releases.xml</a>" /&gt;
</pre>
A simple repository configured to use the Felix OBR.<br class="xooki-br"/><hr />
<pre>
&lt;obr name="my-osgi-repo" repoXmlFile="${ivy.settings.dir}/obr/obr.xml" requirementStrategy="first" /&gt;
</pre>
A local repository which is trusted to always provide correct dependency for the <tt>Import-Package</tt> requirements.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>Eclipse updatesite</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">updatesite</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<span class="since">since 2.3</span>

<span class="tagdoc" id="ivysettings.resolvers.updatesite">This resolver is one of the resolver which supports <a href="../osgi.html">OSGi&#153;</a> dependencies.<br class="xooki-br"/>It resolves modules (OSGi bundles) which are hosted in an Eclipse&#153; update site.<br class="xooki-br"/><br class="xooki-br"/>This resolver supports old style Eclipse updatesite, based on simply a site.xml. It also supports Eclipse P2 repositories.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of composite resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>url</td><td>the URL of the Eclipse updatesite</td>
        <td>Yes</td></tr>
    <tr><td>requirementStrategy</td><td>defines how strict should be the OSGi resolution. Can be one of <tt>first</tt> or <tt>noambiguity</tt></td>
        <td>No, default to <tt>noambiguity</tt></td></tr>
    <tr><td>metadataTtl</td><td>the time in milliseconds the updatesite metadata are considered up to date</td>
        <td>No, default to 3600000 (1 hour)</td></tr>
    <tr><td>forceMetadataUpdate</td><td>force the update of the updatesite metadata without checking their freshness</td>
        <td>No, default to false</td></tr>
</tbody>
</table>

The requirement strategy is defining how the resolver should behave in front of several choices. In the OSGi dependency model, an <tt>Import-Package</tt> requirement can be satisfied by several different bundles. So when resolving such requirement, Ivy will first look into the already resolved bundles if one provides that package. If it fails to find one, then two behaviours can occur:
<ul>
<li>if the requirement strategy is <tt>first</tt>, among the bundles statifying the requirement, it will shoose the first one. A warn will be logged ahout the choice Ivy has to arbitrarily do.</li>
<li>if the requirement strategy is <tt>noambiguity</tt>, Ivy will make the resolution fail.</li>
</ul>

<h1>Examples</h1>
<pre>
&lt;updatesite name="ivyde-updatesite" url="<a href="http://www.apache.org/dist/ant/ivyde/updatesite">http://www.apache.org/dist/ant/ivyde/updatesite</a>" /&gt;
</pre>
A simple repository configured to load the Apache IvyDE Eclipse update site.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>Mirrored Resolver</div>
<table class="resolver">
<tr><td class="title">Tag</td><td class="value">mirroredurl</td></tr>
<tr><td class="title">Handle latest</td><td class="value">yes with http urls (and apache server) and with file urls, no with other urls</td></tr>
<tr><td class="title">Handle publish</td><td class="value">no</td></tr>
</table>

<span class="since">since 2.3</span>

<br/>
<span class="tagdoc" id="ivysettings.resolvers.mirroredurl">This resolver can resolve dependencies against several mirrors of the same repository. From a list of mirror urls, it will iteratively try to resolve the dependencies against each one.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
This resolver shares the <a href="../settings/resolvers.html#common">common attributes</a> of standard resolvers.
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>m2compatible</td><td>True if this resolver should be maven2 compatible, false otherwise</td>
        <td>No, defaults to false</td></tr>
    <tr><td>mirrorListUrl</td><td>The url where to retrive the list of mirror urls.</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>ivy</td><td>defines a pattern for ivy files, using the pattern attribute</td>
        <td>0..n</td></tr>
    <tr><td>artifact</td><td>defines a pattern for artifacts, using the pattern attribute</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Example</h1>

Having the file mavenrepolist.txt content:
<pre>
<a href="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</a><br class="xooki-br"/><a href="http://repo2.maven.org/maven2/">http://repo2.maven.org/maven2/</a>
</pre>
And the piece of settings:
<pre>
&lt;mirroredurl name="mirrored-maven" m2compatible="true" mirrorListUrl="<a href="file:///Users/me/dev/repo/mavenrepolist.txt">file:///Users/me/dev/repo/mavenrepolist.txt</a>"&gt;<br class="xooki-br"/>      &lt;artifact pattern="[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;<br class="xooki-br"/>&lt;/mirroredurl&gt;
</pre>
It will resolve first on the repo1 and if failing it will fall back on repo2.<br class="xooki-br"/><br class="xooki-br"/><hr />

The mirror list can be retrieved from a geo-location aware url:
<pre>
&lt;mirroredurl name="mirrored-asf" mirrorListUrl="<a href="http://www.apache.org/dyn/closer.cgi">http://www.apache.org/dyn/closer.cgi</a>"&gt;<br class="xooki-br"/>  &lt;ivy pattern="repo/[organisation]/[module]/[revision]/ivy.xml" /&gt;<br class="xooki-br"/>  &lt;artifact pattern="repo/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]" /&gt;<br class="xooki-br"/>&lt;/mirroredurl&gt;
</pre>
<hr/><div class='toc-title toc-title-4'>conflict-managers</div><br class="xooki-br"/><b>Tag:</b> conflict-managers<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.conflict-managers">Defines a list of <a href="../concept.html#conflict">conflicts managers</a> usable in Ivy.</span> Each conflict manager is identified by its name, given as an attribute.<br class="xooki-br"/>The child tag used for the conflict manager must be equal to a name of a conflict manager type (either built-in or added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/>Here is a list of built-in conflicts managers (which do not require anything in the configuration file):
<ul>
<li>all</li> this conflicts manager resolve conflicts by selecting all revisions. Also called the NoConflictManager, it doesn't evict any modules.
<li>latest-time</li> this conflict manager selects only the 'latest' revision, latest being defined as the latest in time. Note that latest in time is costly to compute, so prefer latest-revision if you can.
<li>latest-revision</li> this conflict manager selects only the 'latest' revision, latest being defined by a string comparison of revisions.
<li>latest-compatible</li> this conflict manager selects the latest version in the conflicts which can result in a compatible set of dependencies. This means that in the end, this conflict manager does not allow any conflicts (similar to the strict conflict manager), except that it follows a best effort strategy to try to find a set of compatible modules (according to the version constraints)
<li>strict</li> this conflict manager throws an exception (i.e. causes a build failure) whenever a conflict is found.
</ul>
The two "latest" conflict managers also take into account the force attribute of the dependencies.<br class="xooki-br"/>Indeed direct dependencies can declare a force attribute (see <a href="../ivyfile/dependency.html">dependency</a>), which indicates that the revision given in the direct dependency should be preferred over indirect dependencies.<br class="xooki-br"/><br class="xooki-br"/>Here is a list of conflict manager types available, which can be used to define your own custom conflict managers:
<ul>
<li>latest-cm</li>The latest conflict manager uses a latest strategy to select the latest revision among several ones. Both latest-time and latest-revision conflict managers are based on this conflict manager type. It takes 'latest' as attribute to define which latest strategy should be used. Example:
<pre>&lt;latest-cm name="mylatest-conflict-manager" latest="my-latest-strategy"/&gt;</pre>
<li>compatible-cm</li>The latest compatible conflict manager uses a latest strategy to select the latest revision among several ones. It takes 'latest' as an attribute to define which latest strategy should be used. Example:
<pre>&lt;compatible-cm name="my-latest-compatible-conflict-manager" latest="my-latest-strategy"/&gt;</pre>
<li>regexp-cm</li>This conflict manager is based on a regular expression and throws an exception (i.e. causes a build failure) when a conflict is found with versions with different matching group. For instance if a conflict is found between 1.2.x and 1.3.y it will throw an exception if the regular expression is (.*)\.\d, because the matching group will match different strings (1.2 and 1.3). 1.2.1 and 1.2.2 won't throw an exception with the same regular expression. The regular expression is set using the 'regexp' attribute. A 'ignoreNonMatching' attribute can also be set to simply warn when a version is found which does not match the regular expression, instead of throwing an exception.
</ul>

<h3>Child elements</h3>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any conflict manager</td><td>adds a conflict manager to the list of available conflict managers</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>modules</div><br class="xooki-br"/><b>Tag:</b> modules<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.modules">Defines per module or module set settings.</span>

The rules are given by defining a module set, using a pattern for module organisation and name, and giving some settings for the set, like the name of the corresponding resolver to use.<br class="xooki-br"/><br class="xooki-br"/>If no rules match a given module, the default setting will be used.<br class="xooki-br"/><br class="xooki-br"/>Note: You can greatly improve the performance of dependency resolution by configuring multiple smaller resolvers instead of one large resolver (i.e. chain). For instance, if you have a local repository for your modules and a remote repository for third party libraries, it is a good idea to have two separate resolvers, one for all of your modules and another for the rest (the default one).<br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/module.html">module</a></td><td>defines a module set rule</td>
        <td>1..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>module</div><br class="xooki-br"/><b>Tag:</b> module<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.modules.module">Define a module set rule.</span> The tag defines a module set, by giving an expression and the matcher to use for organisation, name, revision and any extra attribute identifying your modules. The rule matching is performed in order, and is using a pattern matcher. Hence you can use * to specify all, or simply avoid specifying the attribute. <br class="xooki-br"/><br class="xooki-br"/>The revision and extra attributes are only used for rules defining the resolver to use. For other settings, use only organisation and module name.<br class="xooki-br"/><br class="xooki-br"/>It also gives the specific setting to use for this module set.<br class="xooki-br"/><br class="xooki-br"/>For each module set, you can configure:
<ul>
<li>the <a href="settings/resolvers.html">resolver</a> to use</li>
<li>the <a href="settings/conflict-managers.html">conflict manager</a> to use</li>
<li>the default <a href="../terminology.html#branch">branch</a> to use</li>
<li>the <a href="use/resolve.html">resolve mode</a> to use</li>
</ul>

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the organisation to match to apply the rule.</td>
        <td>No, defaults to *</td></tr>
    <tr><td>name</td><td>the module's name to match to apply the rule.</td>
        <td>No, defaults to *</td></tr>
    <tr><td>revision</td><td>the module's revision to match to apply the rule. Note that the version may not be resolved yet (be latest.integration for instance), so be very careful when using this attribute. <span class="since">since 2.0</span></td>
        <td>No, defaults to *</td></tr>
    <tr><td><em>any extra attribute</em></td><td>an extra attribute to match to apply the rule. <span class="since">since 2.0</span></td>
        <td>No, defaults to *</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules to which the resolver should be applied <span class="since">since 1.3</span></td>
        <td>No, defaults to exactOrRegexp</td></tr>
    <tr><td>resolver</td><td>the name of the resolver to apply. The resolver must have been defined in the resolvers section of the configuration file.</td>
        <td>No</td></tr>
    <tr><td>conflict-manager</td><td>the name of the conflict manager to apply. <span class="since">since 1.4</span></td>
        <td>No</td></tr>
    <tr><td>branch</td><td>the default branch to apply. <span class="since">since 1.4</span></td>
        <td>No</td></tr>
    <tr><td>resolveMode</td><td>the resolve mode to use. <span class="since">since 2.0</span></td>
        <td>No</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;modules&gt;<br class="xooki-br"/>  &lt;module organisation="apache" name="*" resolver="myprojectsresolver"/&gt;<br class="xooki-br"/>&lt;/modules&gt;
</pre>
Uses myprojectresolver for all modules from <i>apache</i>.<br class="xooki-br"/><hr/>
<pre>
&lt;modules&gt;<br class="xooki-br"/>  &lt;module organisation="apache" name="commons-*" matcher="glob" resolver="myapachecommonsresolver"/&gt;<br class="xooki-br"/>&lt;/modules&gt;
</pre>
Uses myapachecommonsresolver for all modules beginning with 'commons-' from 'apache'.<br class="xooki-br"/><hr/>
<pre>
&lt;modules&gt;<br class="xooki-br"/>  &lt;module organisation="apache" name="commons-[a-z]+" myextra="val.*" matcher="regexp" resolver="myapachecommonsresolver"/&gt;<br class="xooki-br"/>&lt;/modules&gt;
</pre>
Uses myapachecommonsresolver for all modules from <i>apache</i> beginning with 'commons-' followed by any number of alphabetic lowercase characters, and with the extra attribute 'myextra' having a value beginning with 'val.'.<br class="xooki-br"/><hr/>
<pre>
&lt;modules&gt;<br class="xooki-br"/>  &lt;module organisation="apache" name="ivy*" matcher="glob" conflict-manager="latest-time"/&gt; <br class="xooki-br"/>&lt;/modules&gt;
</pre>
Uses latest-time conflict manager for all modules from <i>apache</i> whose name begins with 'ivy'.<br class="xooki-br"/><hr/>
<pre>
&lt;modules&gt;<br class="xooki-br"/>  &lt;module organisation="apache" name="ivy*" matcher="glob" branch="fix-103"/&gt; <br class="xooki-br"/>&lt;/modules&gt;
</pre>
Uses 'fix-103' as default branch for all modules from <i>apache</i> whose name begins with 'ivy'.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>outputters</div><br class="xooki-br"/><b>Tag:</b> outputters<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.outputters">Defines a list of report outputters usable in ivy. </span>

A report outputter is used at the end of the resolve process to generate a report of how the resolve has been performed.<br class="xooki-br"/><br class="xooki-br"/>Two report outputters are registered by default:
<ul>
<li>a log report outputter (<a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/plugins/report/LogReportOutputter.java">LogReportOutputter</a>)</li>which produces the output on the console at the end of the resolve, which looks like this:
<pre>
        ---------------------------------------------------------------------<br class="xooki-br"/>        |                  |            modules            ||   artifacts   |<br class="xooki-br"/>        |       conf       | number| search|dwnlded|evicted|| number|dwnlded|<br class="xooki-br"/>        ---------------------------------------------------------------------<br class="xooki-br"/>        |      default     |   1   |   1   |   0   |   0   ||   1   |   1   |<br class="xooki-br"/>        ---------------------------------------------------------------------
</pre>
<li>an xml report outputter (<a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/plugins/report/XmlReportOutputter.java">XmlReportOutputter</a>)</li>which produces an xml report in the cache, which is mandatory for correct Ivy behaviour, since it's that report which is used when you do a post resolve step in a separate build from the resolve itself. It's also this xml report which is processed to generate all the different reports available in the <a href="use/report.html">report</a> task.
</ul>

The child tag used for the parser must be equal to a name of a report outputter type (added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/>To see how to define your own report outputter see <a href="../extend.html">Extending Ivy documentation</a><br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any report outputter</td><td>adds a report outputter to the list of available ones</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>signers</div><br class="xooki-br"/><b>Tag:</b> signers<br class="xooki-br"/><span class="since">since 2.2</span>

<span class="tagdoc" id="ivysettings.signers">Defines a list of detached signature generators usable in ivy. Each generator is identified by its name, given as an attribute.<br class="xooki-br"/>The child tags used to configure the signature generator must be equal to the name of a signature generator type (either built-in or added with the typedef tag).</span>

Ivy supports the following signature generator out of the box: 
<ul>
<li>pgp</li> generates an OpenPGP compatible ASCII armored detached signature.
</ul>


<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any signature generator</td><td>adds a signature generator to the list of registered generators</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Built-in Generators</h1>

<h2>PGP</h2>

This generator is capable of generating an OpenPGP compatible ASCII armored detached signature.<br class="xooki-br"/><br class="xooki-br"/><b>Remark:</b> This generator uses the <a href="http://www.bouncycastle.org/java.html">BouncyCastle OpenPGP</a> library. Before this generator can be used, these libraries must be available on Ivy's classpath.<br class="xooki-br"/><br class="xooki-br"/>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>The name of the signature generator.</td>
        <td>Yes</td>
    </tr>
    <tr><td>secring</td><td>The location of the secret keyring.</td>
        <td>No, defaults to ${user.home}/.gnupg/secring.gpg</td>
    </tr>
    <tr><td>keyId</td><td>The identifier of the key to use. The keyword 'auto' can be used to indicate a key will be selected automatically.</td>
        <td>No, defaults to 'auto'.</td>
    </tr>
    <tr><td>password</td><td>The password of the private key.</td>
        <td>Yes</td>
    </tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;signers&gt;<br class="xooki-br"/>    &lt;pgp name="mypgp" password="my-password" /&gt;<br class="xooki-br"/>&lt;/signers&gt;
</pre>
Defines a detached signature generator with name 'mypgp' which uses the secret key ring on the default location and automatically selects a private key.<br class="xooki-br"/><hr/>
<pre>
&lt;signers&gt;<br class="xooki-br"/>    &lt;pgp name="mypgp" password="my-password" keyId="123ABC45"/&gt;<br class="xooki-br"/>&lt;/signers&gt;
</pre>
Same as before, but this time the key '123ABC45' is used to generate the detached signature.<br class="xooki-br"/><hr/><div class='toc-title toc-title-4'>statuses</div><br class="xooki-br"/><b>Tag:</b> statuses<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.statuses">Defines the list of available statuses.</span> <span class="since">since 1.4</span>

By default, ivy has 3 statuses: release, milestone and integration. By adding a statuses section to your ivysettings file, you define the statuses you want to use. Note that in this case if you still want to have ivy default statuses you will have to declare them.<br class="xooki-br"/><br class="xooki-br"/>The integration property on each status is only used for recursive delivery, an integration dependency being delivered if the caller is not in integration state itself.<br class="xooki-br"/><br class="xooki-br"/>The default status is the one used when none is defined in a module descriptor. If not specified, it defaults to the last defined status.<br class="xooki-br"/><br class="xooki-br"/>The statuses order is important, the first is considered the more mature, the last the less mature. This is used to know if a status is compatible with a latest.<em>&lt;status&gt;</em> version matcher.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>default</td><td>the name of the status to use when none is declared in an ivy file</td>
        <td>No, defaults to the last status declared</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="settings/status.html">status</a></td><td>defines a new status</td>
        <td>0..n</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;statuses default="bronze"&gt;<br class="xooki-br"/>  &lt;status name="gold" integration="false"/&gt;<br class="xooki-br"/>  &lt;status name="silver" integration="false"/&gt;<br class="xooki-br"/>  &lt;status name="bronze" integration="true"/&gt;<br class="xooki-br"/>&lt;/statuses&gt; 
</pre>
Defines 3 statuses, gold, silver and bronze. The default status used when none is declared in an ivy file will be bronze. <br class="xooki-br"/>It is also considered as an integration status, and thus doesn't trigger any recrusive delivery.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>status</div><br class="xooki-br"/><b>Tag:</b> status<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.statuses.status">Define one available module status.</span>

See <a href="settings/statuses.html">statuses</a> page for details about how statuses are defined.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>name of status defined</td>
        <td>Yes</td></tr>
    <tr><td>integration</td><td>true if this is an integration status, false otherwise</td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
	<hr/><div class='toc-title toc-title-4'>triggers</div><br class="xooki-br"/><b>Tag:</b> triggers<br class="xooki-br"/><span class="since">since 1.4</span>

<span class="tagdoc" id="ivysettings.triggers">Defines a list of triggers to activate on some Ivy events.</span>

A trigger is an action which is performed whenever a particular event occurs.<br class="xooki-br"/>Ivy supports 3 type of triggers out of the box: 
<ul>
<li>ant-call</li> calls a target in the same build as the original one whenever a particular event occurs. 
<li>ant-build</li> calls an ant build which may be in another ant build script. 
<li>log</li> echo a message, usually in a file
</ul>

If you want to use a different trigger, you can <a href="../extend.html">implement your own</a>.<br class="xooki-br"/><br class="xooki-br"/>The following events are available in Ivy:
<table class="ivy-children">
<thead>
    <tr><th>Name</th><th>Attributes</th><th>Description</th></tr>
</thead>
<tbody>
    <tr><td>pre-resolve</td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the module for which the dependencies will be resolved<br class="xooki-br"/>            <li>module</li>the name of the module for which the dependencies will be resolved<br class="xooki-br"/>            <li>revision</li>the revision of the module for which the dependencies will be resolved<br class="xooki-br"/>            <li>conf</li>comma separated list of configurations which will be resolved<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired at the beginning of the resolve process, before module dependencies and transitive dependencies are resolved.</td>
    </tr>
    <tr><td>pre-resolve-dependency</td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the dependency resolved<br class="xooki-br"/>            <li>module</li>the name of the dependency resolved<br class="xooki-br"/>            <li>req-revision</li>the requested revision for the dependency <span class="since">since 2.0</span> (provided for consistency with post-resolve-dependency)<br class="xooki-br"/>            <li>req-revision-default</li>the default requested revision constraint for the dependency <span class="since">since 2.0</span>
            <li>req-revision-dynamic</li>the requested revision dynamic constraint for the dependency <span class="since">since 2.0</span>
            <li>revision</li>the requested revision for the dependency<br class="xooki-br"/>            <li>resolver</li>the name of the resolver used to resolve the dependency<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired before each dependency is resolved. In this case resolved means resolving the actual revision if the requested revision is a version constraint and not a static version, and downloading all necessary metadata information.</td>
    </tr>
    <tr><td>post-resolve-dependency</td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the dependency resolved<br class="xooki-br"/>            <li>module</li>the name of the dependency resolved<br class="xooki-br"/>            <li>req-revision</li>the requested revision for the dependency <span class="since">since 2.0</span>
            <li>req-revision-default</li>the default requested revision constraint for the dependency <span class="since">since 2.0</span>
            <li>req-revision-dynamic</li>the requested revision dynamic constraint for the dependency <span class="since">since 2.0</span>
            <li>revision</li>the revision of the dependency resolved, or the requested revision if the resolution was not successful<br class="xooki-br"/>            <li>resolved</li>true if the resolution was successful, false otherwise<br class="xooki-br"/>            <li>duration</li>the time elapsed to resolve the dependency (in ms) <span class="since">since 2.0</span>
            <li>resolver</li>the name of the resolver used to resolve the dependency<br class="xooki-br"/>            <li>any extra attribute</li>all extra attributes found on the info tag of the resolved dependency are available <span class="since">since 2.0</span>
          </ul>
        </td>
        <td>Fired after each dependency is resolved</td>
    </tr>
    <tr><td>post-resolve</td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the module for which the dependencies have been resolved<br class="xooki-br"/>            <li>module</li>the name of the module for which the dependencies have been resolved<br class="xooki-br"/>            <li>revision</li>the revision of the module for which the dependencies have been resolved<br class="xooki-br"/>            <li>conf</li>comma separated list of configurations resolved<br class="xooki-br"/>            <li>resolve-id</li>the identifier of the resolution process <span class="since">since 2.0</span>
            <li>nb-dependencies</li>total number of dependencies, including transitive and evicted ones <span class="since">since 2.0</span>
            <li>nb-artifacts</li>total number of artifacts resolved, excluding metadata artifacts <span class="since">since 2.0</span>
            <li>resolve-duration</li>the time (in ms) elapsed to resolve dependencies, before dowloading artifacts <span class="since">since 2.0</span>
            <li>download-duration</li>the time (in ms) elapsed to download all artifacts, excluding metadata artifacts downloaded during the first phase of the resolution process <span class="since">since 2.0</span>
            <li>download-size</li>the total size (in bytes) of all downloaded artifacts, excluding metadata artifacts. Only artifacts actually downloaded (not in cache or used from their original location) are considered <span class="since">since 2.0</span>
          </ul>
        </td>
        <td>Fired at the end of the resolve process, when all module dependencies have been resolved</td>
    </tr>
    <tr><td>pre-download-artifact</td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the artifact which is about to be downloaded<br class="xooki-br"/>            <li>module</li>the name of the module of the artifact which is about to be downloaded<br class="xooki-br"/>            <li>revision</li>the revision of the the artifact which is about to be downloaded<br class="xooki-br"/>            <li>artifact</li>the name of the the artifact which is about to be downloaded<br class="xooki-br"/>            <li>type</li>the type of the the artifact which is about to be downloaded<br class="xooki-br"/>            <li>ext</li>the extension of the the artifact which is about to be downloaded<br class="xooki-br"/>            <li>metadata</li>true if the artifact to be downloaded is a metadata artifact, false for published artifacts <span class="since">since 2.0</span>
            <li>resolver</li>the name of the resolver used to download the artifact<br class="xooki-br"/>            <li>origin</li>the origin location from which it will be downloaded<br class="xooki-br"/>            <li>local</li>true if it's a local artifact, false otherwise<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired before an artifact is downloaded from a repository to the cache</td>
    </tr>
    <tr><td>post-download-artifact</td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the artifact which was just downloaded<br class="xooki-br"/>            <li>module</li>the name of the module of the artifact which was just downloaded<br class="xooki-br"/>            <li>revision</li>the revision of the the artifact which was just downloaded<br class="xooki-br"/>            <li>artifact</li>the name of the the artifact which was just downloaded<br class="xooki-br"/>            <li>type</li>the type of the the artifact which was just downloaded<br class="xooki-br"/>            <li>ext</li>the extension of the the artifact which was just downloaded<br class="xooki-br"/>            <li>metadata</li>true if the downloaded artifact is a metadata artifact, false for published artifacts <span class="since">since 2.0</span>
            <li>resolver</li>the name of the resolver used to download the artifact<br class="xooki-br"/>            <li>origin</li>the origin location from which it was downloaded<br class="xooki-br"/>            <li>local</li>true if it's a local artifact, false otherwise<br class="xooki-br"/>            <li>size</li>the size in bytes of the downloaded artifact<br class="xooki-br"/>            <li>duration</li>the time elapsed to download the artifact (in ms) <span class="since">since 2.0</span>
            <li>file</li>the file to which it has been downloaded<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired after an artifact has been downloaded from a repository to the cache</td>
    </tr>
    <tr><td>pre-retrieve <br/><span class="since">since 2.0</span></td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the module for which the dependencies will be retrieved<br class="xooki-br"/>            <li>module</li>the name of the module for which the dependencies will be retrieved<br class="xooki-br"/>            <li>revision</li>the revision of the module for which the dependencies will be retrieved<br class="xooki-br"/>            <li>conf</li>comma separated list of configurations which will be retrieved<br class="xooki-br"/>            <li>symlink</li>true if Ivy will use symbolic links instead of copies on supported platforms, false otherwise<br class="xooki-br"/>            <li>sync</li>true if the retrieve process will be performed in sync mode, false otherwise<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired at the beginning of the retrieve process.</td>
    </tr>
    <tr><td>post-retrieve <br/><span class="since">since 2.0</span></td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the module for which the dependencies have been retrieved<br class="xooki-br"/>            <li>module</li>the name of the module for which the dependencies will be retrieved<br class="xooki-br"/>            <li>revision</li>the revision of the module for which the dependencies have been retrieved<br class="xooki-br"/>            <li>conf</li>comma separated list of configurations which have been retrieved<br class="xooki-br"/>            <li>symlink</li>true if Ivy used symbolic links instead of copies on supported platforms, false otherwise<br class="xooki-br"/>            <li>sync</li>true if the retrieve process has been performed in sync mode, false otherwise<br class="xooki-br"/>            <li>duration</li>the time elapsed in ms during the retrieve process<br class="xooki-br"/>            <li>size</li>the total size of artifacts which have actually been copied (or symlinked)<br class="xooki-br"/>            <li>nbCopied</li>the number of artifacts copied or symlinked<br class="xooki-br"/>            <li>nbUptodate</li>the number of artifacts which were already present and up to date at the destination location<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired at the end of the retrieve process.</td>
    </tr>
    <tr><td>pre-retrieve-artifact <br/><span class="since">since 2.1</span></td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the artifact which is about to be retrieved<br class="xooki-br"/>            <li>module</li>the name of the module of the artifact which is about to be retrieved<br class="xooki-br"/>            <li>revision</li>the revision of the the artifact which is about to be retrieved<br class="xooki-br"/>            <li>artifact</li>the name of the the artifact which is about to be retrieved<br class="xooki-br"/>            <li>type</li>the type of the the artifact which is about to be retrieved<br class="xooki-br"/>            <li>ext</li>the extension of the the artifact which is about to be retrieved<br class="xooki-br"/>            <li>metadata</li>true if the retrieved artifact is a metadata artifact, false for published artifacts <br class="xooki-br"/>            <li>size</li>the size in bytes of the retrieved artifact<br class="xooki-br"/>            <li>from</li>the absolute path from which it will be retrieved (usually a location in cache)<br class="xooki-br"/>            <li>to</li>the absolute path to which it will be retrieved<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired before an artifact is retrieved from the cache to a local location</td>
    </tr>
    <tr><td>post-retrieve-artifact <br/><span class="since">since 2.1</span></td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the artifact which has just been retrieved<br class="xooki-br"/>            <li>module</li>the name of the module of the artifact which has just been retrieved<br class="xooki-br"/>            <li>revision</li>the revision of the the artifact which has just been retrieved<br class="xooki-br"/>            <li>artifact</li>the name of the the artifact which has just been retrieved<br class="xooki-br"/>            <li>type</li>the type of the the artifact which has just been retrieved<br class="xooki-br"/>            <li>ext</li>the extension of the the artifact which has just been retrieved<br class="xooki-br"/>            <li>metadata</li>true if the retrieved artifact is a metadata artifact, false for published artifacts <br class="xooki-br"/>            <li>size</li>the size in bytes of the retrieved artifact<br class="xooki-br"/>            <li>from</li>the absolute path from which it has just been retrieved (usually a location in cache)<br class="xooki-br"/>            <li>to</li>the absolute path to which it has just been retrieved<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired after an artifact is retrieved from the cache to a local location</td>
    </tr>
    <tr><td>pre-publish-artifact <br/><span class="since">since 2.0</span></td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the artifact which is about to be published<br class="xooki-br"/>            <li>module</li>the name of the module of the artifact which is about to be published<br class="xooki-br"/>            <li>revision</li>the revision of the the artifact which is about to be published<br class="xooki-br"/>            <li>artifact</li>the name of the the artifact which is about to be published<br class="xooki-br"/>            <li>type</li>the type of the the artifact which is about to be published<br class="xooki-br"/>            <li>ext</li>the extension of the the artifact which is about to be published<br class="xooki-br"/>            <li>resolver</li>the name of the resolver into which the artifact is about to be published<br class="xooki-br"/>            <li>file</li>the absolute path of the source file for the artifact<br class="xooki-br"/>            <li>overwrite</li>"true" if the new data will overwrite existing artifacts, "false" otherwise<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired before an artifact is published into a repository</td>
    </tr>
    <tr><td>post-publish-artifact <br/><span class="since">since 2.0</span></td>
        <td>
          <ul>
            <li>organisation</li>the organisation of the artifact that was published<br class="xooki-br"/>            <li>module</li>the name of the module of the artifact that was published<br class="xooki-br"/>            <li>revision</li>the revision of the the artifact that was published<br class="xooki-br"/>            <li>artifact</li>the name of the the artifact that was published<br class="xooki-br"/>            <li>type</li>the type of the the artifact that was published<br class="xooki-br"/>            <li>ext</li>the extension of the the artifact that was published<br class="xooki-br"/>            <li>resolver</li>the name of the resolver into which the artifact was published<br class="xooki-br"/>            <li>file</li>the absolute path of the source file for the artifact<br class="xooki-br"/>            <li>overwrite</li>"true" if the new data overwrote existing artifacts, "false" otherwise<br class="xooki-br"/>            <li>status</li>"successful" if the artifact published successfully; "failed" if the artifact failed to publish, or if the status is unknown<br class="xooki-br"/>          </ul>
        </td>
        <td>Fired after an artifact is published into a repository.  Note that this event is fired whether or not the publication succeeded.  The "status" property can be checked to verify success.</td>
    </tr>
</tbody>
</table>


The child tag used for the dependency resolver must be equal to a name of a trigger type (either built-in or added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any trigger</td><td>adds a trigger to the list of registered triggers</td>
        <td>1..n</td></tr>
</tbody>
</table>

<h1>Built-in Triggers</h1>
Ivy comes with 3 built-in triggers: <br class="xooki-br"/>
<table class="ivy-attributes">
<thead>
    <tr><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>ant-build</td><td>Triggers an ant build. Note that by default the ant build is triggered only once per build file, the property onlyonce can be set to false to change this.</td></tr>
<tr><td>ant-call</td><td>Calls a target in the current ant build.</td></tr>
<tr><td>log</td><td>Logs a message on the console or in a log file.</td></tr>
</tbody>
</table>


<h1><a name="common">Common attributes</a></h1>
All triggers share some common attributes detailed here.<br class="xooki-br"/><br class="xooki-br"/>Among these attributes, you will find how to select when the trigger should be performed. You have to provide an event name, which is simple, but you can also use a filter expression. The syntax for this expression is very simple and limited: <br class="xooki-br"/>you can use the = operator to compare an attribute (left operande) with a value (right operande).<br class="xooki-br"/>you can use AND OR NOT as boolean operators<br class="xooki-br"/>you cannot use parenthesis to change the precedence<br class="xooki-br"/>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the trigger for identification purpose only</td>
        <td>Yes</td>
    </tr>
    <tr><td>event</td><td>the name of the event on which the trigger should be performed</td>
        <td>Yes</td>
    </tr>
    <tr><td>filter</td><td>a filter expression used to restrict when the trigger should be performed</td>
        <td>No, defaults to no filter</td>
    </tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;triggers&gt;<br class="xooki-br"/>    &lt;ant-build antfile="${ivy.settings.dir}/[module]/build.xml" target="publish"<br class="xooki-br"/>           event="pre-resolve-dependency" filter="revision=latest.integration"/&gt;<br class="xooki-br"/>&lt;/triggers&gt;
</pre>
Triggers an ant build of the ant file ${ivy.settings.dir}/[module]/build.xml (where [module] is replaced by the name of the dependency resolved) with the target "publish", just before resolving a dependency with a latest.integration revision.<br class="xooki-br"/>Note that by default the ant build is triggered only once per build file. See below to see how to trigger the build more than once.<br class="xooki-br"/><hr/>
<pre>
&lt;triggers&gt;<br class="xooki-br"/>    &lt;ant-build antfile="${ivy.settings.dir}/[module]/build.xml" target="publish"<br class="xooki-br"/>           event="pre-resolve-dependency" filter="revision=latest.integration"<br class="xooki-br"/>           onlyonce="false" /&gt;<br class="xooki-br"/>&lt;/triggers&gt;
</pre>
Same as before, but this time the builds will be triggered as many time as the dependency is resolved, instead of only once.<br class="xooki-br"/><hr/>
<pre>
&lt;triggers&gt;<br class="xooki-br"/>    &lt;ant-call target="unzip" prefix="dep"<br class="xooki-br"/>          event="post-download-artifact" filter="type=zip AND status=successful"/&gt;<br class="xooki-br"/>&lt;/triggers&gt;
</pre>
Triggers an ant call of the target unzip just after downloading a zip artifact, prefixing all parameters to the target with 'dep'.<br class="xooki-br"/>Here is how the target can look like:
<pre>
&lt;target name="unzip"&gt;<br class="xooki-br"/>     &lt;echo&gt;<br class="xooki-br"/>        unzipping artifact: <br class="xooki-br"/>        organisation=${dep.organisation} <br class="xooki-br"/>        module=${dep.module} <br class="xooki-br"/>        revision=${dep.revision}<br class="xooki-br"/>        artifact=${dep.artifact}<br class="xooki-br"/>        type=${dep.type}<br class="xooki-br"/>        ext=${dep.ext}<br class="xooki-br"/>        origin=${dep.origin}<br class="xooki-br"/>        local=${dep.local}<br class="xooki-br"/>        size=${dep.size}<br class="xooki-br"/>        file=${dep.file}<br class="xooki-br"/>     &lt;/echo&gt;<br class="xooki-br"/>     &lt;mkdir dir="${basedir}/out"/&gt;<br class="xooki-br"/>     &lt;unzip src="${dep.file}" dest="${basedir}/out"/&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>
<hr/>
<pre>
&lt;triggers&gt;<br class="xooki-br"/>    &lt;log file="ivy.log" <br class="xooki-br"/>          message='downloaded "${origin}" to "${file}" (${duration}ms - ${size}B)'<br class="xooki-br"/>          event="post-download-artifact" filter="status=successful"/&gt;<br class="xooki-br"/>&lt;/triggers&gt;
</pre>
Logs any successful artifact download, with information on the source and destination, and details on download size and duration.<br class="xooki-br"/><br class="xooki-br"/>The file attribute is optional, the log trigger will output messages to console if it isn't provided.<hr/><div class='toc-title toc-title-4'>version-matchers</div><br class="xooki-br"/><b>Tag:</b> version-matchers<br class="xooki-br"/><br class="xooki-br"/><span class="tagdoc" id="ivysettings.version-matchers">Defines a list of version matchers.</span> <span class="since">since 1.4</span> 

The child tag used for the version matcher must be equal to a name of a report outputter type (added with the typedef tag).<br class="xooki-br"/><br class="xooki-br"/>A version matcher is used to evaluate if a dependency version constraint matches a dependency version.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class"ivy-att">Attribute</th><th class="ivy-att-desc">Descrition</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>usedefaults</td>
        <td>when set to true, includes the built-in version matchers (Latest, Sub Revision, and Version Ranger Matcher). Exact Revision Matcher is always included</td>
        <td>No, defaults to false</td>
    </tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>any version matcher</td><td>adds a version matcher to the list of available ones</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Built-in Version Matchers</h1>
<h2>Exact Revesion Matcher</h2>
A matcher that matches a dependency revision id to the module revision id using simple string equality.<br class="xooki-br"/><br class="xooki-br"/><h2>Sub Revision Matcher</h2>
A matcher that matches all revisions starting with a specific prefix. The syntax is: [prefix]+<br class="xooki-br"/>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Revision</th><th class="ivy-chld-desc">Matches</th></tr>
</thead>
<tbody>

<tr><td>1.0.+</td><td>all revisions starting with '1.0.', like 1.0.1, 1.0.5, 1.0.a</td></tr>
<tr><td>1.1+</td><td>all revisions starting with '1.1', like 1.1, 1.1.5, but also 1.10, 1.11</td></tr>
</table>

<h2>Latest (Status) Matcher</h2>

A matcher that matches versions based on their status. The predefined statuses in Ivy are 'release', 'milestone' and 'integration'. It's possible to define your own statuses, see <a href="settings/statuses.html">statuses</a> for more details.<br class="xooki-br"/>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Revision</th><th class="ivy-chld-desc">Matches</th></tr>
</thead>
<tbody>

<tr><td>latest.integration</td><td>all versions</td></tr>
<tr><td>latest.milestone</td><td>all modules having at least 'milestone' as status</td></tr>
<tr><td>latest.release</td><td>all modules having at least 'release' as status</td></tr>
<tr><td>latest.[any status]</td><td>all modules having at least the specified status</td></tr>
</table>

<h2>Version Range Matcher</h2>

Range types are exhaustively listed by example in the table below.<br class="xooki-br"/>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Revision</th><th class="ivy-chld-desc">Matches</th></tr>
</thead>
<tbody>

<tr><td> [1.0,2.0] </td><td> all versions greater or equal to 1.0 and lower or equal to 2.0</td></tr>

<tr><td> [1.0,2.0[ </td><td> all versions greater or equal to 1.0 and lower than 2.0</td></tr>

<tr><td> ]1.0,2.0] </td><td> all versions greater than 1.0 and lower or equal to 2.0<tr>

<tr><td> ]1.0,2.0[ </td><td> all versions greater than 1.0 and lower than 2.0</td></tr>

<tr><td> [1.0,) </td><td> all versions greater or equal to 1.0 </td></tr>

<tr><td> ]1.0,) </td><td> all versions greater than 1.0</td></tr>

<tr><td> (,2.0] </td><td> all versions lower or equal to 2.0</td></tr>

<tr><td> (,2.0[ </td><td> all versions lower than 2.0 </td></tr>

</tbody>
</table>

<h2>Version Pattern Matcher</h2>

The version pattern matcher allows for more flexibility in pattern matching at the cost of adding a matcher declaration in Ivy settings.  A simple example is given below.<br class="xooki-br"/><br class="xooki-br"/><h3>Settings.xml</h3>
<pre>
&lt;pattern-vm&gt;<br class="xooki-br"/>  &lt;match revision="foo" pattern="${major}\.${minor}\.\d+" args="major, minor" matcher="regexp" /&gt;<br class="xooki-br"/>&lt;/pattern-vm&gt;
</pre>

<h3>Ivy.xml</h3>
<pre>
&lt;dependency org="acme" name="tool" rev="foo(1, 3)" /&gt;
</pre>

The version pattern matcher may contain more than one match element.  The matcher will attempt to match a dependency revision against each match in sequence, checking the revision tag (e.g. foo(..)) and then the pattern.<br class="xooki-br"/>Matcher types may be one of "regexp", "exact", "glob", or "exactOrRegexp".  Glob pattern matching requires Apache ORO 2.0.8 or higher to be on the classpath.<hr/><div class='toc-title toc-title-3'>Ivy Files</div><br class="xooki-br"/>Ivy use is entirely based on <em>module descriptors</em> known as "ivy files". Ivy files are xml files, usually called ivy.xml, containing the description of the dependencies of a module, its published artifacts and its configurations.<br class="xooki-br"/><br class="xooki-br"/>Here is the simplest ivy file you can write:
<pre>
&lt;ivy-module version="2.0"&gt;<br class="xooki-br"/>  &lt;info organisation="myorg"<br class="xooki-br"/>        module="mymodule"<br class="xooki-br"/>        /&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>

If you want to see a sample module descriptor using almost all possibilities of ivy files, check this one, <a href="samples/ivy-sample-xslt.xml">with</a> or <a href="samples/ivy-sample.xml">without</a> xslt.<br class="xooki-br"/><br class="xooki-br"/>Before beginning the reference itself, it is required to have in mind the terminology defined in the <a href="reference.html">main page</a> of this reference documentation.<br class="xooki-br"/><br class="xooki-br"/>For those familiar with xml schema, the schema used to validate ivy files can be found <a href="http://ant.apache.org/ivy/schemas/ivy.xsd">here</a>. For those using xsd aware IDE, you can declare the xsd in your ivy files to benefit from code completion / validation:
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="xooki-br"/>&lt;ivy-module version="2.0" <br class="xooki-br"/>            xmlns:xsi="<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>"<br class="xooki-br"/>            xsi:noNamespaceSchemaLocation=<br class="xooki-br"/>                   "<a href="http://ant.apache.org/ivy/schemas/ivy.xsd">http://ant.apache.org/ivy/schemas/ivy.xsd</a>"&gt;<br class="xooki-br"/>  &lt;info organisation="myorg"<br class="xooki-br"/>        module="mymodule"<br class="xooki-br"/>        /&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>

<h2>Dynamic and <a name="resolved">resolved</a> ivy files</h2>

A module descriptor (ivy file) is needed both before and after the publication of each revision of the module. Depending on the case, a module descriptor can be either <em>dynamic</em> or <em>resolved</em>:<br class="xooki-br"/><br class="xooki-br"/><h3>Dynamic descriptor for module development</h3>

During the module development time, between publications, the descriptor helps in managing all the possibly changing dependencies of the module. For that purpose, development time ivy files can declare dynamic dependencies to allow for a greater flexibility of use. <a href="ivyfile/dependency.html#revision">Dynamic revision</a> references like "latest.integration" or "1.0.+" are possible and may resolve to different artifacts at different times. Variables can be used for even more flexibility. Development time ivy files are hence called "dynamic", because they can produce different results over time. The dynamic ivy files are normally considered source files and kept with them (under SCM control).<br class="xooki-br"/><br class="xooki-br"/><h3>Resolved descriptors for publishing</h3>

At each publication, another kind of a module descriptor is needed to document the dependencies of the particular published revision of the module. For that purpose, the descriptor usually needs to be fixed as its dependencies should no longer change. In doing so, the published module revision gets fixed, explicitly resolved dependencies. No variables are allowed either. Such publication-friendly, static ivy files are called "resolved", because they should always produce the same results. The resolved ivy files are comparable to published artifacts and are kept with them in a repository.<br class="xooki-br"/><br class="xooki-br"/>Resolved ivy files are generated from their original dynamic ivy files via the <a href="use/deliver.html">deliver</a> task.<br class="xooki-br"/><br class="xooki-br"/>Note that although it is technically possible to publish module revisions with dynamic ivy files, it is not a generally recommended practice.<br class="xooki-br"/><br class="xooki-br"/><h1>Hierarchical Index</h1>
<pre>
ivy-module<br class="xooki-br"/>    <a href="ivyfile/info.html">info</a><br class="xooki-br"/>        <a href="ivyfile/license.html">license</a><br class="xooki-br"/>        <a href="ivyfile/ivyauthor.html">ivyauthor</a><br class="xooki-br"/>        <a href="ivyfile/repository.html">repository</a><br class="xooki-br"/>        <a href="ivyfile/description.html">description</a><br class="xooki-br"/>    <a href="ivyfile/configurations.html">configurations</a><br class="xooki-br"/>        <a href="ivyfile/conf.html">conf</a><br class="xooki-br"/>    <a href="ivyfile/publications.html">publications</a><br class="xooki-br"/>        <a href="ivyfile/artifact.html">artifact</a><br class="xooki-br"/>            <a href="ivyfile/artifact-conf.html">conf</a><br class="xooki-br"/>    <a href="ivyfile/dependencies.html">dependencies</a><br class="xooki-br"/>        <a href="ivyfile/dependency.html">dependency</a><br class="xooki-br"/>            <a href="ivyfile/dependency-conf.html">conf</a><br class="xooki-br"/>                <a href="ivyfile/mapped.html">mapped</a><br class="xooki-br"/>            <a href="ivyfile/dependency-artifact.html">artifact</a><br class="xooki-br"/>                <a href="ivyfile/dependency-artifact-conf.html">conf</a><br class="xooki-br"/>            <a href="ivyfile/dependency-artifact.html">include</a><br class="xooki-br"/>                <a href="ivyfile/dependency-artifact-conf.html">conf</a><br class="xooki-br"/>            <a href="ivyfile/artifact-exclude.html">exclude</a><br class="xooki-br"/>                <a href="ivyfile/artifact-exclude-conf.html">conf</a><br class="xooki-br"/>        <a href="ivyfile/exclude.html">exclude</a><br class="xooki-br"/>        <a href="ivyfile/override.html">override</a><br class="xooki-br"/>        <a href="ivyfile/conflict.html">conflict</a><br class="xooki-br"/>    <a href="ivyfile/conflicts.html">conflicts</a><br class="xooki-br"/>        <a href="ivyfile/manager.html">manager</a>
</pre>

<h1>ivy-module</h1>
<b>Tag:</b> ivy-module<br class="xooki-br"/><br class="xooki-br"/>The root tag of any ivy file (module descriptor).<br class="xooki-br"/><h2>Attributes</h2>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>version</td><td>the version of the ivy file specification - should be '2.0' with current version of ivy</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h2>Child elements</h2>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>info</td><td>contains information about the described module</td>
        <td>1</td></tr>
    <tr><td>configurations</td><td>container for configuration elements</td>
        <td>0..1</td></tr>
    <tr><td>publications</td><td>container for published artifact elements</td>
        <td>0..1</td></tr>
    <tr><td>dependencies</td><td>container for dependency elements</td>
        <td>0..1</td></tr>
    <tr><td>conflicts</td><td>section to configure the conflict managers to use</td>
        <td>0..1</td></tr>
</tbody>
</table>
	<hr/><div class='toc-title toc-title-4'>info</div><br class="xooki-br"/><b>Tag:</b> info <b>Parent:</b> <a href="../ivyfile.html">ivy-module</a><br class="xooki-br"/><br class="xooki-br"/>Gives identification and basic information about the module this ivy file describes.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> This tag supports <a href="../concept.html#extra">extra attributes</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the name of the organisation that is the owner of this module.</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the module described by this ivy file.</td>
        <td>Yes</td></tr>
    <tr><td>branch</td><td>the branch of this module. <span class="since">since 1.4</span></td>
        <td>No, defaults to the default branch setting, or nothing if no default branch is configured</td></tr>
    <tr><td>revision</td><td>the revision of this module.</td>
        <td>Yes in repository ivy files, no in ivy files to resolve</td></tr>
    <tr><td>status</td><td>the status of this module. See <a href="../reference.html">terminology</a> section for details</td>
        <td>No, default to 'integration'</td></tr>
    <tr><td>publication</td><td>the date of publication of this module. It should be given in this format: yyyyMMddHHmmss</td>
        <td>No, but it's a good practice to set it with delivered ivy files</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/extends.html">extends</a></td><td>identifies a parent Ivy file from which this descriptor inherits content</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/license.html">license</a></td><td>contains information about the licenses of the described module</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/ivyauthor.html">ivyauthor</a></td><td>describes who has contributed to write the ivy file</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/repository.html">repository</a></td><td>describes on which public repositories this module can be found</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/description.html">description</a></td><td>describes how to use the module</td>
        <td>0..1</td></tr>
</tbody>
</table>
After the description, you can also place your own tags in your own namespace.  This allow to provide some custom information about the module.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>extends</div><br class="xooki-br"/><b>Tag:</b> extends <b>Parent:</b> <a href="../ivyfile/info.html">info</a><br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.2</span> Identifies an optional parent descriptor for this module.  For complicated projects composed of many modules that have common configurations or dependencies, inheritance allows modules to share this information.  Which parts of the parent descriptor are inherited can be controlled with the <i>extendType</i> attribute.  Supported <i>extendType</i> values are:
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Value</th><th class="ivy-att-desc">Description</th></tr>
</thead>
<tbody>
    <tr><td>info</td><td>Attributes of the <a href="../ivyfile/info.html">info</a> element are inherited from the parent.  When an attribute appears in both child and parent, the child value is used.</td></tr>
    <tr><td>description</td><td>The content of the <a href="../ivyfile/description.html">info/description</a> element is inherited from the parent.</td></tr>
    <tr><td>configurations</td><td><a href="../ivyfile/conf.html">Configurations</a> defined in the parent descriptor are added to any configurations defined in the child descriptor.</td></tr>
    <tr><td>dependencies</td><td><a href="../ivyfile/dependency.html">Dependencies</a> defined in the parent descriptor are added to any dependencies defined in the child descriptor.</td></tr>
    <tr><td>licenses</td><td><a href="../ivyfile/license.html">Licenses</a> defined in the parent descriptor are added to any licenses defined in the child descriptor.</td></tr>
    <tr><td>all</td><td>info, description, configurations, licenses and dependencies from the parent descriptor are merged into the child descriptor.</td></tr>
</tbody>
</table>

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the organisation of the parent module</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the parent module</td>
        <td>Yes</td></tr>
    <tr><td>revision</td><td>the revision of the parent module.  Can be fixed, a dynamic value, or range of revisions; see <a href="../ivyfile/dependency.html">dependency</a> for information on specifying revisions.</td>
        <td>Yes</td></tr>
    <tr><td>extendType</td><td>which part(s) of the parent descriptor are inherited.  Valid values are <i>info</i>, <i>description</i>,<br class="xooki-br"/><i>configurations</i>, <i>dependencies</i>, and <i>all</i>.</td>
        <td>No, default is <i>all</i></td></tr>
    <tr><td>location</td><td><p>A local filesystem path that should be searched for the parent descriptor.  If the parent descriptor cannot be found at this location, it will be located using dependency resolvers like any normal dependency.</p><p>This attribute is intended for development use.  For example, child module descriptors appear in a source control directory with the parent module descriptor at a higher level.  <i>location</i> will then contain the relative path to the parent descriptor for use during development builds.</p></td>
        <td>No, as long as the parent descriptor exists in an Ivy resolver</td></tr>
</tbody>
</table>
<hr/><div class='toc-title toc-title-5'>license</div><br class="xooki-br"/><b>Tag:</b> license <b>Parent:</b> <a href="../ivyfile/info.html">info</a><br/>
<br/>
Gives information about a license of the described module.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the license. Try to respect spelling when using a classical license.</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to the license text.</td>
        <td>No, but it's a good practice to indicate it</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>ivyauthor</div><br class="xooki-br"/><b>Tag:</b> ivyauthor <b>Parent:</b> <a href="../ivyfile/info.html">info</a><br/>
<br/>
Gives information about who has contributed to write this ivy file. It does NOT indicate who <br class="xooki-br"/>is the author of the module itself.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the author, as a person or a company.</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to where the author can bea reached.</td>
        <td>No, but it's a good practice to indicate it</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>repository</div><br class="xooki-br"/><b>Tag:</b> repository <b>Parent:</b> <a href="../ivyfile/info.html">info</a><br/>
<br/>
Gives information about a public repository where the module can be found. This information<br class="xooki-br"/>is given as an indication, repositories being able to be down over time.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the repository. Try to respect spelling for common repositories (ibiblio, ivyrep, ...)</td>
        <td>Yes</td></tr>
    <tr><td>url</td><td>an url pointing to the repository.</td>
        <td>Yes</td></tr>
    <tr><td>pattern</td><td>an ivy pattern to find modules on this repository</td>
        <td>No, but it's recommended to indicate it.</td></tr>
    <tr><td>ivys</td><td>true if ivy file can be found on this repository</td>
        <td>No, defaults to false.</td></tr>
    <tr><td>artifacts</td><td>true if module artifacts can be found on this repository</td>
        <td>No, defaults to false.</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>description</div><br class="xooki-br"/><b>Tag:</b> description <b>Parent:</b> <a href="../ivyfile/info.html">info</a><br/>
<br/>
Describes the current module. This tag is the only one which can contain free text,<br class="xooki-br"/>including html. It is used to describe the module itself, usually in a single short phrase<br class="xooki-br"/>(it is not meant to replace the module description on the corresponding web site), and then<br class="xooki-br"/>gives all information necessary to use the module, especially information about<br class="xooki-br"/>public configurations, how and when to use them.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>homepage</td><td>the url of the homepage of the module</td>
        <td>No, but it's recommended to indicate it.</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>configurations</div><br class="xooki-br"/><b>Tag:</b> configurations <b>Parent:</b> <a href="../ivyfile.html">ivy-module</a><br class="xooki-br"/><br class="xooki-br"/>A container for configuration elements. If this container is not present, it is assumed that the module has one public configuration called 'default'.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.2</span> You can define the default conf on this container by specifying the defaultconf attribute.  This attribute defines the conf mapping to use when no conf mapping is specified for a dependency in this ivy file.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> You can define a default conf mapping on this container by specifying the defaultconfmapping attribute.<br class="xooki-br"/><br class="xooki-br"/>This attribute modifies the way ivy interprets conf mapping with no mapped conf. In this case, Ivy will look in the default conf mapping and use the conf mapping defined in the default conf mapping for the conf for which there is no mapped conf.<br class="xooki-br"/><br class="xooki-br"/>In order to maintain backwards compatibility with Ivy 2.1.0 and earlier, the defaultconfmapping also provides one additional function.  If no defaultconf is specified (on either the configurations tag or the dependencies tag), the defaultconfmapping becomes the default configuration for dependencies in this ivy file when no configuration is specified.  In other words, in addition to altering the interpretation of individual configurations with no mapping, defaultconfmapping also performs exactly like defaultconf in the absence of a definition for defaultconf.<br class="xooki-br"/><br class="xooki-br"/>If several defaultconfmapping or defaultconf attributes are defined (in the configurations tag, one or several in an included configurations file, and/or in the dependency tag, then it's only the last definition of each property which is taken into account.  The others will have no effect at all.<br class="xooki-br"/><br class="xooki-br"/>See <a href="#defaultconfmapping">examples below</a> to clarify the behavior of these two attributes together.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> You can activate a confmappingoverride mode for all configurations, in which case the extending configurations will override the mappings of the configurations they extend from.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultconf</td><td>the default conf to use in this ivy file <span class="since">since 2.2</span></td><td>No, defaults to no default conf</td></tr>
    <tr><td>defaultconfmapping</td><td>the default conf mapping to use in this ivy file <span class="since">since 1.3</span></td>
        <td>No, defaults to no default conf mapping</td></tr>
    <tr><td>confmappingoverride</td><td>true to activate configuration mapping override, false otherwise <span class="since">since 1.4</span></td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/conf.html">conf</a></td><td>declares a configuration of this module</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/include.html">include</a></td><td>include configurations from another file</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Configuration mappings details</h1>
When Ivy parses your Ivy file, it will create (internally) modify the configuration mapping of your dependencies.<br class="xooki-br"/>For instance, say you have:
<pre>
&lt;configurations defaultconfmapping="conf1-&gt;other1;conf2-&gt;other2"&gt;<br class="xooki-br"/>   &lt;conf name="conf1" /&gt;<br class="xooki-br"/>   &lt;conf name="conf2" extends="conf1" /&gt;<br class="xooki-br"/>&lt;/configurations&gt;<br class="xooki-br"/>&lt;dependencies&gt;<br class="xooki-br"/>   &lt;dependency name="other-module" conf="conf1" /&gt;<br class="xooki-br"/>&lt;/dependencies&gt;
</pre>
When Ivy parses this file, it will construct the following dependency (in-memory only):
<pre>&lt;dependency name="other-module" conf="conf1-&gt;other1" /&gt;</pre>

So, if you now resolve the conf2 configuration, you will only get the other1 dependencies of your other-module.<br class="xooki-br"/><br class="xooki-br"/>But when you set confmappingoverride to true, Ivy will construct the following dependency in memory:
<pre>&lt;dependency name="other-module" conf="conf1-&gt;other1;conf2-&gt;other2" /&gt;</pre>
As you can see, the defaultmappings of the extending configurations are also added (although you didn't explicitly defined them)<br class="xooki-br"/><br class="xooki-br"/>When you now resolve the conf2 configuration, you'll get the other2 dependencies of your other-module. <br class="xooki-br"/><br class="xooki-br"/><h1>Examples involving defaultconf and defaultconfmapping</h1>
The table below indicates how Ivy interprets the conf attribute according to how <a href="ivyfile/configurations.html">defaultconfmapping</a> and <a href="ivyfile/configurations.html">defaultconf</a> are set:<table class="ivy-attributes"><thead><tr><th>defaultconf</th><th>defaultconfmapping</th><th>conf</th><th>ivy interpretation</th></tr>
</thead>
<tbody>
<tr><td></td><td></td><td></td><td><pre>*-&gt;*</pre></td></tr>
<tr><td></td><td></td><td>runtime</td><td><pre>runtime-&gt;runtime</pre></td></tr>
<tr><td></td><td></td><td>test</td><td><pre>test-&gt;test</pre></td></tr>
<tr><td><pre>runtime</pre></td><td></td><td></td><td><pre>runtime-&gt;runtime</pre></td></tr>
<tr><td><pre>runtime</pre></td><td><pre>runtime-&gt;*;test-&gt;default</pre></td><td></td><td>runtime->*</td></tr>
<tr><td><pre>runtime</pre></td><td><pre>runtime-&gt;*;test-&gt;default</pre></td><td>test</td><td>test->default</td></tr>
<tr><td></td><td><pre>runtime-&gt;*;test-&gt;default</pre></td><td></td><td><pre>runtime-&gt;*;test-&gt;default</pre></td></tr>
<tr><td></td><td><pre>runtime-&gt;*;test-&gt;default</pre></td><td>runtime</td><td><pre>runtime-&gt;*</pre></td></tr>
<tr><td></td><td><pre>runtime-&gt;*;test-&gt;default</pre></td><td>test</td><td><pre>test-&gt;default</pre></td></tr>
</tbody>
</table>
<hr/><div class='toc-title toc-title-5'>conf</div><br class="xooki-br"/><b>Tag:</b> conf <b>Parent:</b> <a href="ivyfile/configurations.html">configurations</a><br class="xooki-br"/><br class="xooki-br"/>Declares a configuration of this module. As described in the reference page, a configuration is a way to use or construct a module. Some modules may be used in different ways (think about hibernate which can be used inside or outside an application server), and this way may alter the artifacts you need (in the case of hibernate, jta.jar is needed only if it is used outside an application server). Moreover, a module may need some other modules and artifacts only at build time, and some others at runtime. All those differents ways to use or build a module are called in Ivy module configurations.<br class="xooki-br"/><br class="xooki-br"/>The conf element in the configurations section declares one configuration. This declaration gives the name of the configuration declared, its visibility and the other configurations of the module it extends.<br class="xooki-br"/><br class="xooki-br"/>Visibility is used to indicate whether or not a configuration can be used from other modules depending on this one. Thus a private configuration is only used for internal purpose (maybe at build time), and other modules cannot declare to depend on it. <br class="xooki-br"/><br class="xooki-br"/>A configuration can also extend one or several other ones of the same module. When a configuration extends another one, then all artifacts required in the extended configuration will also be required in the configuration that extends the other one. For instance, if configuration B extends configuration A, and if artifacts art1 and art2 are required in configuration A, then they will be automatically required in configuration B. On the other hand, artifacts required in configuration B are not necessarily required in configuration A.<br class="xooki-br"/><br class="xooki-br"/>This notion is very helpful to define configurations which are similar with some differences.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> The extends attribute can use the following wildcards:<table class="ivy-attributes">
<tr><td>*</td><td>all other configurations</td></tr>
<tr><td>*(public)</td><td>all other public configurations</td></tr>
<tr><td>*(private)</td><td>all other private configurations</td></tr>
</table>
<br/>

<span class="since">since 1.4</span> A whole configuration can be declared as non transitive, so that all dependencies resolved in this configuration will be resolved with transitivity disabled. Note that the transitivity is disabled for all the configuration dependencies (including those obtained because this conf extends other ones), and only for this configuration (which means that a conf extending this one with transitivityy enabled will get transitive dependencies even for dependencies being part of the non transitive configuration).<br class="xooki-br"/>This is very useful to build a compile configuration, for instance, forcing the dependency declaration on each direct dependency, with no risk to forget some because of transitivity.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> This tag supports <a href="../concept.html#extra">extra attributes</a>.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the declared configuration</td>
        <td>Yes</td></tr>
    <tr><td>description</td><td>a description for the declared configuration</td>
        <td>No</td></tr>
    <tr><td>visibility</td><td>the visibility of the declared configuration. <br class="xooki-br"/>    'public' means that this configuration can be used by other modules, while 'private' means that this configuration is used only in the module itself, and is not exposed to other modules</td>
        <td>No, defaults to public</td></tr>
    <tr><td>extends</td><td>a comma separated list of configurations of this module that the <br class="xooki-br"/>    current configuration extends</td>
        <td>No, defaults to none</td></tr>
    <tr><td>transitive</td><td>a boolean to indicate if this conf is transitive or not <span class="since">since 1.4</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>deprecated</td><td>indicates that this conf has been deprecated by giving the date of the deprecation. <br class="xooki-br"/>    	It should be given in this format: yyyyMMddHHmmss</td>
        <td>No, by default the conf is not deprecated</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;conf name="core" visibility="private" /&gt;<br class="xooki-br"/>&lt;conf name="compile" extends="core" transitive="false" visibility="private" /&gt;<br class="xooki-br"/>&lt;conf name="runtime" extends="compile" description="everything needed to run this module" /&gt;
</pre>
Declares three configurations, core compile and runtime, with only the runtime one accessible from other modules, and with the compile one being non transitive.<br class="xooki-br"/>Therefore the core configuration will only be composed of dependencies declared in the core configuration itself, the compile configuration will be composed of all dependencies required in either core or compile configuration, but without transivity (neither for core nor compile dependencies), and runtime will be composed of all dependencies, all transitively, including the dependencies declared only in compile.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-5'>include</div><br class="xooki-br"/><b>Tag:</b> include <b>Parent:</b> <a href="ivyfile/configurations.html">configurations</a><br class="xooki-br"/><br class="xooki-br"/>Include configurations specified in another file. <span class="since">since 1.3</span>

The included file should have a configurations tag as root tag, which follow the same specification as the <a href="../ivyfile/configurations.html">configurations</a> tag of the ivy file. <br class="xooki-br"/><br class="xooki-br"/>This means that it can contain conf declarations, other file inclusion, and also a defaultconfmapping.<br class="xooki-br"/><br class="xooki-br"/>When delivering an ivy file with such an inclusion, the included configuration file is inlined, i.e. ivy remove the dependency on the external file.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>the file to include</td>
        <td>Yes</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>  &lt;info organisation="myorg"<br class="xooki-br"/>         module="mymodule"<br class="xooki-br"/>  /&gt;<br class="xooki-br"/>  &lt;configurations&gt;<br class="xooki-br"/>    &lt;include file="path/to/included-configurations.xml"/&gt;<br class="xooki-br"/>    &lt;conf name="conf3"/&gt;<br class="xooki-br"/>  &lt;/configurations&gt;<br class="xooki-br"/>  &lt;dependencies&gt;<br class="xooki-br"/>    &lt;dependency name="mymodule1" rev="1.0"/&gt;<br class="xooki-br"/>    &lt;dependency name="mymodule2" rev="2.0" conf="conf2,conf3-&gt;*"/&gt;<br class="xooki-br"/>  &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
with included-configurations.xml like this:
<pre>
&lt;configurations defaultconfmapping="*-&gt;@"&gt;<br class="xooki-br"/>  &lt;conf name="conf1" visibility="public"/&gt;<br class="xooki-br"/>  &lt;conf name="conf2" visibility="private"/&gt;<br class="xooki-br"/>&lt;/configurations&gt;
</pre>
Defines 3 configurations, conf1, conf2 and conf3. mymodule1 is required in each configuration, with for each the same configuration (conf1 is needed in conf1, conf2 in conf2, and conf3 in conf3) due to the defaultconfmapping defined in the included file.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>publications</div><br class="xooki-br"/><b>Tag:</b> publications <b>Parent:</b> <a href="../ivyfile.html">ivy-module</a><br/><br/>

Container for artifact elements, used to describe the artifacts published by this module. <br class="xooki-br"/><br class="xooki-br"/>If this container is not present, it is assumed that the module has one artifact, with the same name as the module, and published in all module configurations.<br/>

Thus if you have a module which publishes no artifacts (a sort of virtual module, made only to integrate several other modules as a whole), you have to include a publications element with no artifact sub element.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultconf</td><td>comma separated list of public configurations in which artifacts are published by default (when no specific configurations are set on the artifact element).<br class="xooki-br"/>    	'*' wildcard can be used to designate all public configurations of this module. <span class="since">since 2.0</span></td>
        <td>No, defaults to '*'</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="ivyfile/artifact.html">artifact</a></td><td>declares a published artifact for this module</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>artifact</div><br class="xooki-br"/><b>Tag:</b> artifact <b>Parent:</b> <a href="../ivyfile/publications.html">publications</a><br class="xooki-br"/><br class="xooki-br"/>Declares an artifact published by this module. This is especially useful for other modules dependending on this one. They thus get all published artifacts belonging to the configurations asked. Indeed, each published artifact declares in which public configuration it is published. Thus a module depending on this module only get artifacts marked with the asked configurations, taking into account configurations extension (see <a href="../ivyfile/conf.html">configuration declaration</a>).<br class="xooki-br"/><br class="xooki-br"/>The configurations in which an artifact is published can be configured in two ways:
<ul>
<li>conf attribute on artifact element</li>
<li>conf subelement</li>
</ul>
The two are equivalent, it is only a matter of preference. However, do not mix both for one artifact.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> The artifact element has default values for all its attributes, so if you want to declare a default artifact you can just declare it like that:<pre>
&lt;artifact /&gt;
</pre>If this is the only artifact declared, then it's equivalent to having no publication section at all.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> It is possible to give a url at which artifacts can be found. This is not mandatory, and even not recommended. This is only a convenient way to deal with an existing repository with a bad layout, but should not be avoided in an enterprise repository.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> This tag supports <a href="../concept.html#extra">extra attributes</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the published artifact. This name must not include revision.</td>
        <td>No, defaults to the name of the module</td></tr>
    <tr><td>type</td><td>the type of the published artifact. It's usually its extension, but not necessarily. For instance, ivy files are of type 'ivy' but have 'xml' extension</td>
        <td>No, defaults to jar</td></tr>
    <tr><td>ext</td><td>the extension of the published artifact</td>
        <td>No, defaults to type</td></tr>
    <tr><td>conf</td><td>comma separated list of public configurations in which this artifact is published.<br class="xooki-br"/>    	'*' wildcard can be used to designate all public configurations of this module</td>
        <td>No, defaults to defaultconf attribute value on parent publications element.</td></tr>
    <tr><td>url</td><td>a url at which this artifact can be found if it isn't located at the standard location in the repository <span class="since">since 1.4</span></td>
        <td>No, defaults to no url</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/artifact-conf.html">conf</a></td><td>indicates a public configuration in which this artifact is published</td>
        <td>0..n</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;artifact /&gt;
</pre>
Declares an artifact with the name of the module as name, type and ext jar, and published in all configurations.<br class="xooki-br"/><br class="xooki-br"/><hr />
<pre>
&lt;artifact name="foo-src" type="source" ext="zip" conf="src" /&gt;
</pre>
Declares an artifact foo-src, of type 'source' with extension 'zip', and published in the src configuration.<br class="xooki-br"/><br class="xooki-br"/><hr />
<pre>
&lt;artifact name="foo" url="<a href="http://www.acme.com/repository/barbaz/foo-1.2-bar.jar">http://www.acme.com/repository/barbaz/foo-1.2-bar.jar</a>" /&gt;
</pre>
Declares an artifact foo, of type and extension 'jar' located at the url <a href="http://www.acme.com/repository/barbaz/foo-1.2-bar.jar">http://www.acme.com/repository/barbaz/foo-1.2-bar.jar</a>. This url will only be used if the artifact cannot be found at its standard location.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-6'>conf</div><br class="xooki-br"/><b>Tag:</b> conf <b>Parent:</b> <a href="../ivyfile/artifact.html">artifact</a><br/>
<br/>
Indicates a public configuration in which enclosing artifact is published.<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the module public configuration in which this artifact is published. <br class="xooki-br"/>    	'*' wildcard can be used to designate all public configurations of this module</td>
        <td>Yes</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>dependencies</div><br class="xooki-br"/><b>Tag:</b> dependencies <b>Parent:</b> <a href="../ivyfile.html">ivy-module</a><br class="xooki-br"/><br class="xooki-br"/>Container for dependency elements, used to describe the dependencies of this module. <br class="xooki-br"/>If this container is not present, it is assumed that the module has no dependency at all.<br class="xooki-br"/><br class="xooki-br"/>This container provides for two similar behaviors.  An overview is given here.  (See <a href="ivyfile/configurations.html">configurations doc page</a> for more details about these behaviors).<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.1</span><pre>defaultconf</pre>Defines the conf attribute to use when no conf is defined for a dependency in this ivy file. It is only used when no conf mapping is defined, and has no influence in other cases.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span><pre>defaultconfmapping</pre> Influences the way that a conf mapping with no mapped conf is interpreted.<br class="xooki-br"/><br class="xooki-br"/>In Ivy 2.1.0 and earlier, if both defaultconf and defaultconfmapping are defined, it's the defaultconfmapping that is used. Since Ivy 2.2.0, these attributes can be used together.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>defaultconf</td><td>the default configuration to use when none is specified in a dependency. <span class="since">since 1.1</span></em></td>
        <td>No, defaults to *->*</td></tr>
    <tr><td>defaultconfmapping</td><td>the default configuration mapping to use in this ivy file. <span class="since">since 1.3</span></em></td>
        <td>No, defaults to no default conf mapping</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/dependency.html">dependency</a></td><td>declares a dependency for this module</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/exclude.html">exclude</a></td><td>excludes artifacts, modules or whole organizations from the set of dependencies of this module <span class="since">since 2.0</span></td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/override.html">override</a></td><td>specify an override mediation rule, overriding the revision and/or branch requested for a transitive dependency <span class="since">since 2.0</span></td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/conflict.html">conflict</a></td><td>specify a a conflict manager for one or several dependencies <span class="since">since 2.0</span></td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>dependency</div><br class="xooki-br"/><b>Tag:</b> dependency <b>Parent:</b> <a href="dependencies.html">dependencies</a><br class="xooki-br"/><br class="xooki-br"/>Declares a dependency for this module. A dependency is described by the module on which the current module depends (identified by its name, organisation and revision), and a mapping of configurations.<br class="xooki-br"/><br class="xooki-br"/><h2><a name="revision">Fixed and dynamic revisions</a></h2>
The revision can be given as a fixed one (1.5.2, for instance) or as a latest (or dynamic) one. Several possibilities for dynamic revisions are implemented in Ivy:
<ul>
<li>latest.integration</li> selects the latest revision of the dependency module.
<li>latest.[any status] <span class="since">since 1.4</span></li> selects the latest revision of the dependency module with at least the specified status. <br class="xooki-br"/><br class="xooki-br"/>For instance latest.milestone will select the latest version being either a milestone or a release, and latest.release will only selects the latest release. Note that in order to find the latest revision with the appropriate status Ivy has to parse all the ivy files in your repository from the last one until it finds such a revision. Hence don't be surprised if the resolution slow down.<br class="xooki-br"/>See also <a href="settings/statuses.html">statuses</a> to see how to configure module statuses.
<li>end the revision with a +</li> selects the latest sub-revision of the dependency module. For instance, <br class="xooki-br"/>if the dependency module exists in revision 1.0.3, 1.0.7 and 1.1.2, "1.0.+" will select 1.0.7.
<li>version ranges <span class="since">since 1.4</span></li> mathematical notation for ranges can be used to match a range of version.   <br class="xooki-br"/><br class="xooki-br"/>Examples:<br class="xooki-br"/>[1.0,2.0] matches all versions greater or equal to 1.0 and lower or equal to 2.0<br class="xooki-br"/>[1.0,2.0[ matches all versions greater or equal to 1.0 and lower than 2.0<br class="xooki-br"/>]1.0,2.0] matches all versions greater than 1.0 and lower or equal to 2.0<br class="xooki-br"/>]1.0,2.0[ matches all versions greater than 1.0 and lower than 2.0<br class="xooki-br"/>[1.0,) matches all versions greater or equal to 1.0<br class="xooki-br"/>]1.0,) matches all versions greater than 1.0<br class="xooki-br"/>(,2.0] matches all versions lower or equal to 2.0<br class="xooki-br"/>(,2.0[ matches all versions lower than 2.0 
</ul>
<span class="since">since 1.4</span> If you don't find a way to expression your dependency version constraint among these, you can <a href="settings/version-matchers.html">plug your own</a>.<br class="xooki-br"/>The way to determine which revision is the "latest" between two is configurable through the use of pluggable LatestStrategy. See <a href="../reference.html">ivy main concepts</a> for details about this.<br class="xooki-br"/><br class="xooki-br"/><h2><a name="revision-constraint">Revision constraint</a></h2>
<span class="since">since 2.0</span> The dependency tag supports two revision attributes: rev, corresponding to the default required dependency revision, and revConstraint, corresponding to a dynamic revision constraint applied on this dependency. <br class="xooki-br"/><br class="xooki-br"/>Depending on the <a href="use/resolve.html">resolve mode</a> used, the actual revision used during dependency resolution may vary. These revisions usually differ only for modules published in a repository. When <a href="use/deliver.html">deliver</a> is used, dynamic version constraints are replaced by a stic version constraint, to help build reproducibility. However, the information of the original version constraint is not lost, but rather put in the revConstraint attribute. This both ensure better metadata in the repository while still allowing easier build reproducibility. <br class="xooki-br"/><br class="xooki-br"/><h2>Configurations mapping</h2>
This mapping indicates which configurations of the dependency are required in which configurations of the current module, also called master configurations.<br class="xooki-br"/><br class="xooki-br"/>There are several ways to declare this mapping of configurations, choose depending more on preference than on possibilities. Try to avoid mixing usage in a single dependency element: do not use both nested and inline mapping declaration.<br class="xooki-br"/><br class="xooki-br"/>The first way to declare this mapping is called the inline mapping. It is maybe the less natural at first, but it's powerful and concise. Inline mapping can take several forms.<br class="xooki-br"/>
<ul>
<li>Specify one configuration name</li> This means that in this master configuration the same dependency configuration is needed (except if a defaultconfmapping has been specified in this ivy file, see <a href="ivyfile/configurations.html">configurations</a> for details, or table below for examples).<br class="xooki-br"/>For instance, if the current module has defined a configuration named 'runtime', and the dependency too, then having an inline mapping configuration set to 'runtime' means that in the runtime master configuration the runtime dependency configuration is required.<br class="xooki-br"/><br class="xooki-br"/>The <a href="../ivyfile/configurations.html#defaultconfmapping">examples on the dependency on the configurations page</a> explain how ivy interprets the conf attribute according to how <a href="ivyfile/configurations.html">defaultconfmapping</a> and <a href="ivyfile/configurations.html">defaultconf</a> is set.<br class="xooki-br"/><br/>
<li>Specify a configuration mapping using the '->' operator separating a comma separated list of master configurations (left operand) of a comma separated list of dependency configurations (right operand).</li>
A good way to remember which side is for the master configuration (i.e. the configuration of the module defining the dependency) and which side is for the dependency configuration is to read the '->' as 'depends on'.<br class="xooki-br"/><br class="xooki-br"/>In this case, all specified dependency configurations are required in all specified master configurations.<br class="xooki-br"/>For instance, 'A, B, C -> E, F' means that dependency configurations E & F are required in master configurations A, B and C.<br class="xooki-br"/><br class="xooki-br"/>Note that you can use the wildcard '*' as a configuration name, meaning that all configurations (either master or dependency public ones depending on the side) are wanted. For instance, '* -> B, C' means that B & C dependency configurations are required in all master configurations.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> you can use * wildcard followed by negated configurations to mean all but xxx. For instance, '*, !A, !B -> X' means that X dependency configuration is required in all master configurations except A and B.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.2</span> '@' also has a special meaning as a right operand of the dependency mapping, it means map to self. This is particularly useful with '*', '*->@' meaning that all configurations of the module maps to their equivalent (same name) in the dependency.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> '#' can be used as right side operand to mean 'this' configuration, and thus refers to the configuration being resolved. It is slightly similar to @, except that it takes into account the configuration being actually resolved in case of a configuration extending another one.<br class="xooki-br"/><br class="xooki-br"/>Example:<br class="xooki-br"/>Let's foo be a module with two configurations, A and B, B extending A.<br class="xooki-br"/>Then a dependency declaring conf A-># will get A dep conf in its confs A (when resolving A, ivy will find interpret the # symbol as A) and B dep conf in its conf B (when resolving B, ivy will interpret the # symbol as B, even if this dependency is only required because of the A dependency).<br class="xooki-br"/><br class="xooki-br"/>If you don't understand really how this works, do not use it :-)<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> '%' can be used as left side operand to mean 'all the other configurations'. This can be usefull when you only have a specific mapping for some configurations and a default mapping for all the others.<br class="xooki-br"/><br class="xooki-br"/>Example:
<pre>test-&gt;runtime;%-&gt;default</pre> means that the <pre>test</pre> configuration is mapped to the <pre>runtime</pre> configuration, but all the other configurations are mapped to the <pre>default</pre> configuration.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> a fallback mechanism can be used when you are not sure that the dependency will have the required conf. You can indicate to ivy that you want one configuration, but if it isn't present, use another one. <br class="xooki-br"/>The syntax for specifying this adds the fallback conf between parenthesis right after the required conf. <br class="xooki-br"/>For instance, <pre>test-&gt;runtime(default)</pre> means that in the test configuration of the module the <pre>runtime</pre> conf of the dependency is required, but if doesn't exist, it will use the <pre>default</pre> conf instead. If <pre>default</pre> conf doesn't exist then it will be considered as an error. Note that the <pre>*</pre> wildcard can be used as fallback conf.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.1</span> It is also possible to define dependencies on configurations intersection. A configuration intersection is defined using a '+' sign to separate the configuration (eg 'A+B' means the intersection of configuration 'A' and 'B'). In that case only artifacts and dependencies defined in both configurations in the dependency will be part of the master configuration defining the dependency on the configuration intersection.<br class="xooki-br"/><br class="xooki-br"/>Configuration intersections can also be used when specifying the confs to <a href="use/resolve.html">resolve</a>. <br class="xooki-br"/><br class="xooki-br"/>Moreover, the mapping '*->@' is handled as a specific case with configuration intersections: it maps also the intersections. So if one resolve conf A+B in a module which defines a dependency with mapping *->@, the mapping *->@ is interpreted as A+B->A+B so the intersection of A and B will be resolved in the dependency.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.1</span> you can refer to a group of configurations sharing the same value for an attribute as left side part of the dependency mapping. <br class="xooki-br"/><br class="xooki-br"/>The syntax is 
<pre>*[att=value]</pre>
where <em>att</em> is the name of the attribute shared by the configurations of the group, and <em>value</em is the value for this attribute that configurations must have to be part of the group. This is especially useful with extra attributes.<br class="xooki-br"/><br class="xooki-br"/>For instance, if you have:
<pre>
&lt;configurations&gt;<br class="xooki-br"/>	&lt;conf name="red" e:axis="color" /&gt;<br class="xooki-br"/>	&lt;conf name="blue" e:axis="color" /&gt;<br class="xooki-br"/>		<br class="xooki-br"/>	&lt;conf name="windows" e:axis="platform" /&gt;<br class="xooki-br"/>	&lt;conf name="linux" e:axis="platform"/&gt;<br class="xooki-br"/>&lt;/configurations&gt;
</pre>

Then you can do:
<pre>
&lt;dependency org="acme" name="foo" rev="2.0" conf="*[axis=platform]-&gt;default"/&gt;
</pre>
To map the windows and linux configurations (the one which have the attribute axis equal to platform) to the default configuration of foo.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> you can add simple conditions in the right side of the dependency mapping. This is done by adding a condition between '[' and ']'. If the condition evaluates to <pre>true</pre>, the mapping is performed. If the condition evaluates to <pre>false</pre>, the mapping will be ignored. For instance, <pre>test-&gt;[org=A]runtime,[org=B]default</pre> means that the <pre>test</pre> configuration will be mapped to the <pre>runtime</pre> conf for the dependencies of organisation 'A' and to the <pre>default</pre> conf for dependencies of organisation 'B'.<br class="xooki-br"/>
<li>Specify a semi-column separated list of any of the previous specs.</li> In this case, it is the union of the mapping which is kept. For instance, 'A -> B; * -> C' means that B conf is needed in A conf and C conf is need in all master conf... so both B & C dep conf are required in A master conf
</ul>

If you prefer more verbose mapping declaration, everything is also possible with sub elements mapping declaration. <br class="xooki-br"/><br class="xooki-br"/><h2>Artifact restriction</h2>
Moreover, the dependency element also supports an artifact restriction feature (since 0.6).<br class="xooki-br"/>See <a href="#dependency-artifact">dependency artifact restriction</a> for details.<br class="xooki-br"/><br class="xooki-br"/><h2>Forcing revision</h2>
Finally, the dependency element also supports an a force attribute (since 0.8), which gives an indication<br class="xooki-br"/>to conflicts manager to force the revision of a dependency to the one given here.<br class="xooki-br"/>See <a href="../ivyfile/conflicts.html">conflicts manager</a> for details. <br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> this tag supports <a href="../concept.html#extra">extra attributes</a><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the name of the organisation of the dependency.</td>
        <td>No, defaults to the master module organisation</td></tr>
    <tr><td>name</td><td>the module name of the dependency</td>
        <td>Yes</td></tr>
    <tr><td>branch</td><td>the branch of the dependency. <span class="since">since 1.4</span></td>
        <td>No, defaults to the default branch setting for the dependency.</td></tr>
    <tr><td>rev</td><td>the revision of the dependency. See <a href="#revision">above</a> for details.</td>
        <td>Yes</td></tr>
    <tr><td>revConstraint</td><td>the dynamic revision constraint originally used for this dependency. See <a href="#revision-constraint">above</a> for details.</td>
        <td>No, defaults to the value of rev</td></tr>
    <tr><td>force</td><td>a boolean to give an indication to conflict manager that this dependency <br class="xooki-br"/>     should be forced to this revision (see <a href="../ivyfile/conflicts.html">conflicts manager</a>)</td>
        <td>No, defaults to false</td></tr>
    <tr><td>conf</td><td>an inline mapping configuration spec (see above for details)</td>
        <td>No, defaults to defaultconf attribute of dependencies element if neither conf attribute nor conf children element is given</td></tr>
    <tr><td>transitive</td><td>true to resolve this dependency transitively, false otherwise (<span class="since">since 1.2</span>)</td>
        <td>No, defaults to true</td></tr>
    <tr><td>changing</td><td>true if the dependency artifacts may change without revision change, false otherwise (<span class="since">since 1.2</span>). See <a href="../concept.html#change">cache and change management</a> for details.</td>
        <td>No, defaults to false</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/dependency-conf.html">conf</a></td><td>defines configuration mapping has sub element</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/dependency-artifact.html">artifact / include</a></td><td>defines artifacts inclusion - use only if you do not control dependency ivy file</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/artifact-exclude.html">exclude</a></td><td>defines artifacts exclusion - use only if you do not control dependency ivy file</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;dependency org="jayasoft" name="swtbinding" revision="0.2"/&gt;
</pre>
Declares a dependency on the module swtbinding from jayasoft in its revision 0.2. All the configuration of this dependency will be included in all configurations of the module in which the dependency is declared.<br class="xooki-br"/><hr/>
<pre>
&lt;dependency org="jayasoft" name="swtbinding" branch="fix-103" revision="latest.integration"/&gt;
</pre>
Same as above except that it will take the latest revision on the branch 'fix-103' instead of revision '0.2'.<br class="xooki-br"/><hr/>
<pre>
&lt;dependency name="mymodule" revision="latest.integration" conf="test-&gt;default"/&gt;
</pre>
Declares a dependency on the module <pre>mymodule</pre> from the same organisation as the module in which the dependency is declared. The latest available revision of this dependency will be used. This dependency will only be included in the test configuration of the module, and it's only the default configuration of the dependency which will be included.<br class="xooki-br"/><hr/>
<pre>
&lt;dependency org="apache" name="commons-lang" revision="2.0" force="true" conf="default"/&gt;
</pre>
Declares a dependency on the module <pre>commons-lang</pre> from apache, in revision 2.0. The revision 2.0 will be used even if another dependency declares itself a dependency on another version of commons-lang. Moreover, if no defaultconfmapping is defined, only the <pre>default</pre> conf of commons-lang will be used in the <pre>default</pre> conf of the master module. If <pre>*-&gt;runtime</pre> was declared as defaultconfmapping, then the runtime conf of commons-lang would be included in the default conf of the master module. Note that whatever the defaultconfmapping is, the dependency only be included in the default conf of the master module. The defaultconfmapping only changes the required dependency confs.<br class="xooki-br"/><hr/>
<pre>
&lt;dependency org="foo" name="bar" revision="3.0" transitive="false" conf="default-&gt;@;runtime,test-&gt;runtime"/&gt;
</pre>
Declares a dependency on the module <pre>bar</pre> from foo, in revision 3.0. The dependencies of bar will themselves not be included due to the setting of transitive. The default dependency conf will be included in the default master conf, and the runtime dependency conf will be included in both the runtime and test master conf.<br class="xooki-br"/><hr/>
<pre>
&lt;dependency org="foo" name="bar" revision="3.0" changing="true" conf="compile-&gt;runtime(default)"/&gt;
</pre>
Declares a dependency on the module <pre>bar</pre> from foo, in revision 3.0. This revision is considered to be able to change (<pre>changing="true"</pre>), so even if it is already in ivy cache, Ivy will check if a revision is a more recent last modified date is available on the repository. The runtime conf of bar is required in the compile conf of the master module, but if bar doesn't define a runtime conf, then the <pre>default</pre> conf will be used.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-6'>conf</div><br class="xooki-br"/><b>Tag:</b> conf <b>Parent:</b> <a href="../ivyfile/dependency.html">dependency</a><br/>
<br/>
Describes a configuration mapping for a dependency. See also the inline configuration mapping<br class="xooki-br"/>in dependency element.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration to map. <br class="xooki-br"/>    	'*' wildcard can be used to designate all configurations of this module</td>
        <td>Yes</td></tr>
    <tr><td>mapped</td><td>a comma separated list of dependency configurations to which this<br class="xooki-br"/>    master configuration should be mapped</td>
        <td>No, default to the same configuration as master one, unless nested mapped elements are specified</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/mapped.html">mapped</a></td><td>map dependency configurations for this master configuration</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-7'>mapped</div><br class="xooki-br"/><b>Tag:</b> mapped <b>Parent:</b> <a href="../ivyfile/dependency-conf.html">conf</a><br/>
<br/>
Describes a mapped dependency configuration for a master configuration.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the dependency configuration mapped. <br class="xooki-br"/>    	'*' wildcard can be used to designate all configurations of this module</td>
        <td>Yes</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-6'>artifact</div><br class="xooki-br"/><b>Tag:</b> artifact <b>Parent:</b> <a href="../ivyfile/dependency.html">dependency</a><br class="xooki-br"/><br class="xooki-br"/>This feature gives you more control on a dependency for which you do not control its ivy file. <br class="xooki-br"/>It enables to specify the artifacts required, if the dependency has no ivy file. <br class="xooki-br"/><br class="xooki-br"/>Indeed, when a module has no ivy file, it is assumed that it publishes exactly one artifact having the same name as the module itself. But when this module publishes more artifacts, or simply does not respect the name rule, and if you cannot deliver an ivy file for it (because you do not control the repository, for instance - think about maven ibiblio repository, to give no name), then this feature let you specify the artifacts names you want to get.<br class="xooki-br"/><br class="xooki-br"/>Each artifact specification can be given in the context of particular master configurations. By default, if no configuration is specified, artifacts specification apply to all master configurations. But you can specify that a specification applies only to one or several master configurations, using either inline or nested conf specification. In this case, do not forget that if you do not specify any specification for a particular configuration, then no specification will apply for this configuration and it will be resolved not taking into account any specification.<br class="xooki-br"/><br class="xooki-br"/>For instance, imagine you have A, B & C master configurations. If you specify art1 in A & B and art2 in A, then C will not be specified at all, and will thus assume the default artifact. To prevent this, you have to specify a configuration mapping for the dependency, mapping only A & B to some or all dependency configurations.<br class="xooki-br"/><br class="xooki-br"/>Example:
<pre>
&lt;dependency org="yourorg" name="yourmodule9" rev="9.1" conf="A,B-&gt;default"&gt;<br class="xooki-br"/>  &lt;artifact name="art1" type="jar" conf="A,B"/&gt;<br class="xooki-br"/>  &lt;artifact name="art2" type="jar" conf="A"/&gt;<br class="xooki-br"/>&lt;/dependency&gt;	
</pre>

<span class="since">since 1.4</span> It's possible to indicate the url at which the artifact can be found. This is not mandatory, and even not recommended with an enterprise repository. Note that Ivy will always look at the location where the artifact should be and only use the url if it cannot be found at the standard location in the repository.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> This tag supports <a href="../concept.html#extra">extra attributes</a>.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> This feature can also be used for modules having their own module descriptor, but which doesn't declare an artifact you know that is published. Note that in this case artifacts declared to be published by the dependency will be ignored, so do not forget to include all artifacts you want.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of an artifact of the dependency module</td>
        <td>Yes</td></tr>
    <tr><td>type</td><td>the type of the artifact of the dependency module</td>
        <td>Yes</td></tr>
    <tr><td>ext</td><td>the extension of the artifact of the dependency module</td>
        <td>No, defaults to type</td></tr>
    <tr><td>conf</td><td>comma separated list of the master configurations in which this artifact should be included.<br class="xooki-br"/>    '*' wildcard can be used to designate all configurations of this module</td>
        <td>No, defaults to '*', unless nested conf are specified</td></tr>
    <tr><td>url</td><td>an url where this artifact can be found if it isn't present at the standard location in the repository <span class="since">since 1.4</span></td>
        <td>No, defaults to no url</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/dependency-artifact-conf.html">conf</a></td><td>configuration in which the artifact should be included</td>
        <td>0..n</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;dependency org="foo" name="bar" rev="1.0"&gt;<br class="xooki-br"/>  &lt;artifact name="baz" type="jar"/&gt;<br class="xooki-br"/>&lt;/dependency&gt;
</pre>
Declares a dependency on module bar which only publish one artifact: baz.jar.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;dependency org="foo" name="bar" rev="1.0"&gt;<br class="xooki-br"/>  &lt;artifact name="baz" type="jar" url="<a href="http://www.acme.com/repository/bar/baz-1.0-acme.jar">http://www.acme.com/repository/bar/baz-1.0-acme.jar</a>"/&gt;<br class="xooki-br"/>&lt;/dependency&gt;
</pre>
Same as above, except that if the artifact is not found at its standard location, Ivy will use <a href="http://www.acme.com/repository/bar/baz-1.0-acme.jar">http://www.acme.com/repository/bar/baz-1.0-acme.jar</a> to download it.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;dependency org="foo" name="bar" rev="1.0"&gt;<br class="xooki-br"/>  &lt;include name="*"/&gt;<br class="xooki-br"/>  &lt;artifact name="baz" type="source" ext="jar"/&gt;<br class="xooki-br"/>&lt;/dependency&gt;
</pre>
Declares a dependency on module bar for which all artifacts declared will be used (thanks to the include tag) plus an artifact baz of type source and ext jar (which is not declared in module bar module descriptor).<br class="xooki-br"/><hr/><div class='toc-title toc-title-7'>conf</div><br class="xooki-br"/><b>Tag:</b> conf <b>Parent:</b> <a href="../ivyfile/dependency-artifact.html">artifact</a><br class="xooki-br"/><br class="xooki-br"/>Specify a configuration in which the enclosing artifact specification should be included.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be included</td>
        <td>Yes</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-6'>exclude</div><br class="xooki-br"/><b>Tag:</b> exclude <b>Parent:</b> <a href="../ivyfile/dependency.html">dependency</a><br class="xooki-br"/><br class="xooki-br"/>This feature gives you more control on a dependency for which you do not control its ivy file. <br class="xooki-br"/>It enables to restrict the artifacts required, by excluding artifacts being published by the dependency or any of its transitive dependencies, <br class="xooki-br"/>even if configuration does not a good separation of published artifacts<br class="xooki-br"/><br class="xooki-br"/>The same principle concerning configuration as for include applies to this exclude feature (see the <a href="ivyfile/dependency-include.html">include</a> feature).<br class="xooki-br"/><br class="xooki-br"/>Note that exclusion is always done AFTER inclusion has been done.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> This exclude feature can also be used not only to exclude artifacts but also to exclude whole modules. Indeed when you exclude artifacts, it doesn't avoid ivy to search for the module itself, and to resolve the dependencies of the module. But you can also exclude the whole module, which means that the module will not be downloaded at all, and so its own dependencies will not be resolved. For sure, this is usually done to exclude not a direct dependency but an indirect one. To exclude a whole module, you just have to not specify any artifact name, type and ext in your exclude rule. For instance:
<pre>
&lt;dependency name="A" rev="1.0"&gt;<br class="xooki-br"/>  &lt;exclude module="B"/&gt;<br class="xooki-br"/>&lt;/dependency&gt;
</pre>

<span class="since">since 2.0</span> A <a href="ivyfile/exclude.html">module wide exclude</a> can also be used to exclude dependencies for the whole module (and not only in the context of one dependency as it is the case here).<br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the organisation of the dependency module or artifact to exclude, or a regexp matching this organisation <span class="since">since 1.3</span></td>
        <td>No, defaults to *</td></tr>
    <tr><td>module</td><td>the name of the dependency module or the artifact to exclude, or a regexp matching this module name <span class="since">since 1.3</span></td>
        <td>No, defaults to *</td></tr>
    <tr><td>name</td><td>the name of an artifact of the dependency module to add to the exclude list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to *</td></tr>
    <tr><td>type</td><td>the type of the artifact of the dependency module to add to the exclude list, or a regexp matching this name</td>
        <td>No, defaults to *</td></tr>
    <tr><td>ext</td><td>the extension of the artifact of the dependency module to add to the exclude list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to type</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules to excludes <span class="since">since 1.3</span></td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
    <tr><td>conf</td><td>comma separated list of the master configurations in which this artifact should be excluded.<br class="xooki-br"/>    '*' wildcard can be used to designate all configurations of this module</td>
        <td>No, defaults to '*', unless nested conf are specified</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/artifact-exclude-conf.html">conf</a></td><td>configuration in which the artifact should be excluded</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-7'>conf</div><br class="xooki-br"/><b>Tag:</b> conf <b>Parent:</b> <a href="../ivyfile/artifact-exclude.html">artifact</a><br/>
<br/>
Specify a configuration in which the enclosing artifact exclusion should be included.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be excluded</td>
        <td>Yes</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-6'>include</div><br class="xooki-br"/><b>Tag:</b> include <b>Parent:</b> <a href="../ivyfile/dependency.html">dependency</a><br class="xooki-br"/><br class="xooki-br"/>This feature gives you more control on a dependency for which you do not control its ivy file. <br class="xooki-br"/>It enables to restrict the artifacts required by including only the artifacts given here, even if configuration does not a good separation of published artifacts.<br class="xooki-br"/><br class="xooki-br"/>Each artifact restriction can be given in the context of particular master configurations. By default, if no configuration is specified, artifacts restriction apply to all master configurations. But you can specify that a restriction applies only to one or several master configurations, using either inline or nested conf specification. In this case, do not forget that if you do not specify any restriction for a particular configuration, then no restriction will apply for this configuration and it will be resolved not taking into account any restriction.<br class="xooki-br"/><br class="xooki-br"/>For instance, imagine you have A, B & C master configurations. If you restrict to art1 in A & B and art2 in A, then C will not be restricted at all, and will thus get all artifacts of all dependency configurations if you do not specify a configuration mapping. To prevent this, you have to specify a configuration mapping for the dependency, mapping only A & B to some or all dependency configurations.<br class="xooki-br"/><br class="xooki-br"/>Example:
<pre>
&lt;dependency org="yourorg" name="yourmodule9" rev="9.1" conf="A,B-&gt;default"&gt;<br class="xooki-br"/>  &lt;include name="art1" type="jar" conf="A,B"/&gt;<br class="xooki-br"/>  &lt;include name="art2" type="jar" conf="A"/&gt;<br class="xooki-br"/>&lt;/dependency&gt;		
</pre>

<h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of an artifact of the dependency module to add to the include list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>type</td><td>the type of the artifact of the dependency module to add to the include list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to .*</td></tr>
    <tr><td>ext</td><td>the extension of the artifact of the dependency module to add to the include list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to type</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules to include <span class="since">since 2.0</span></td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
    <tr><td>conf</td><td>comma separated list of the master configurations in which this artifact should be included.<br class="xooki-br"/>    '*' wildcard can be used to designate all configurations of this module</td>
        <td>No, defaults to '*', unless nested conf are specified</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/dependency-include-conf.html">conf</a></td><td>configuration in which the artifact should be included</td>
        <td>0..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-7'>conf</div><br class="xooki-br"/><b>Tag:</b> conf <b>Parent:</b> <a href="../ivyfile/dependency-include.html">include</a><br class="xooki-br"/><br class="xooki-br"/>Specify a configuration in which the enclosing artifact inclusion should be included.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the master configuration in which the enclosing artifact should be included</td>
        <td>Yes</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>exclude</div><br class="xooki-br"/><b>Tag:</b> exclude <b>Parent:</b> <a href="../ivyfile/dependencies.html">dependencies</a><br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> This feature gives you more control on a dependency for which you do not control its ivy file. <br class="xooki-br"/>It allows to exclude artifacts, modules or organizations from the list of dependencies for the whole module.<br class="xooki-br"/><br class="xooki-br"/>It is very similar to the <a href="ivyfile/artifact-exclude.html">dependency exclude</a> element, except that it applies to a whole module, which can be very useful when a lot of dependencies transitively bring a module you don't want.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the organization of the dependency module or artifact to exclude, or a regexp matching this organization</td>
        <td>No, defaults to *</td></tr>
    <tr><td>module</td><td>the name of the dependency module or the artifact to exclude, or a regexp matching this module name</td>
        <td>No, defaults to *</td></tr>
    <tr><td>artifact</td><td>the name of an artifact of the dependency module to add to the exclude list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to *</td></tr>
    <tr><td>type</td><td>the type of the artifact of the dependency module to add to the exclude list, or a regexp matching this name</td>
        <td>No, defaults to *</td></tr>
    <tr><td>ext</td><td>the extension of the artifact of the dependency module to add to the exclude list, or an expression matching this name (see matcher attribute below)</td>
        <td>No, defaults to type</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules to excludes</td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
    <tr><td>conf</td><td>comma separated list of the master configurations in which this artifact should be included.<br class="xooki-br"/>    '*' wildcard can be used to designate all configurations of this module</td>
        <td>No, defaults to '*', unless nested conf are specified</td></tr>
</tbody>
</table><hr/><div class='toc-title toc-title-5'>override</div><br class="xooki-br"/><b>Tag:</b> override <b>Parent:</b> <a href="../ivyfile/dependencies.html">dependencies</a><br/>
<br/>
<span class="since">(since 2.0)</span>

Specify an override mediation rule, overriding the revision and/or branch requested for a transitive dependency.<br class="xooki-br"/><br class="xooki-br"/>This can be useful when a direct dependency is bringing a transitive dependency for which you want to change the revision, without actually declaring a dependency on it (because the module doesn't actually depend on it) and without using conflict management for this purpose (maybe because there is no conflict at all, or because you want to by pass conflict management for this particular transitive dependency).<br class="xooki-br"/><br class="xooki-br"/>Overriding is done before any else, in a phase called dependency descriptor mediation. The transitive dependency then behave exactly as if it were declared with the new value.<br class="xooki-br"/><br class="xooki-br"/>Note that even though no attribute is required, it makes no sense to set no attributes at all. It would mean that overriding is triggered for all transitive dependencies, but doesn't override anything. Most of the time, at least org or module should be set to override only a subset of transitive dependencies, and at least branch or rev should be set to actually override something.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the name, or an expression matching the name of organisation to which overriding should be applied (see matcher attribute below)</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>module</td><td>the name, or an expression matching the name of module to which overriding should be applied (see matcher attribute below)</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>branch</td><td>the branch to set for all the overriden dependency descriptors</td>
        <td>No, by default branch is not overriden</td></tr>
    <tr><td>rev</td><td>the revision to set for all the overriden dependency descriptors</td>
        <td>No, by default revision is not overriden</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules for which the conflict manager should be used</td>
        <td>No, defaults to exact</td></tr>
</tbody>
</table>
<hr/><div class='toc-title toc-title-5'>conflict</div><br class="xooki-br"/><b>Tag:</b> conflict <b>Parent:</b> <a href="../ivyfile/dependencies.html">dependencies</a><br/>
<br/>
<span class="since">(since 2.0)</span>

Specify a a conflict manager for one or several dependencies.<br class="xooki-br"/>The way to specify a conflict manager is by giving indication to which dependencies the conflict manager applies (by giving organisation and module names or name regexp), and then specifying the conflict manager, either by giving its name or by specifying a fixed revision list, in which case a fixed conflicts manager is used.<br class="xooki-br"/><br class="xooki-br"/>The list of built-in conflict managers available is listed on the <a href="settings/conflict-managers.html">conflict manager configuration page</a>.<br class="xooki-br"/><br class="xooki-br"/>Conflicts manager are used during the resolve operation, i.e. when ivy analyse the graph of dependencies and download corresponding ivy files and artifacts. The fact to manage conflict at resolve time enables to minimize downloads: when a module is evicted by a conflict manager, it is not downloaded.<br class="xooki-br"/><br class="xooki-br"/>There are two things optimized during conflict resolution: download of artifacts and download of ivy files. The first is always ensured by ivy, i.e. artifacts of a module evicted will never be downloaded. The second is not as simple to handle because to know what are the conflicts ivy needs to know the dependency graph, and to know the dependency graph, it has to download ivy files. But ivy is highly optimized on this too, and it tries to evict modules as soon as possible.<br class="xooki-br"/>That's why the order of dependencies is important for download optimization. Indeed ivy traverses the dependency graph in the order in which dependencies are declared in the ivy files, and each time it encounters a dependency on a module, it first check if there is a conflict on this module, and if this is the case, it asks the conflict manager to resolve the conflict. Then if the module is evicted, it does not download its ivy file, and the whole branch is not traversed, which can saves a lot of time.<br class="xooki-br"/><br class="xooki-br"/>If no specific conflict manager is defined, a default conflict manager is used for all modules.<br class="xooki-br"/> <br class="xooki-br"/>The current default conflict manager is the "latest-revision" conflict manager.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the name, or an expression matching the name of organisation to which this conflict manager should apply (see matcher attribute below)</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>module</td><td>the name, or an expression matching the name of module to which this conflict manager should apply (see matcher attribute below)</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>manager</td><td>the name of the conflict manager to use</td>
        <td rowspan="2">Exactly one of two</td></tr>
    <tr><td>rev</td><td>a comma separated list of revisions this conflict manager should select</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules for which the conflict manager should be used</td>
        <td>No, defaults to exact</td></tr>
</tbody>
</table>
<hr/><div class='toc-title toc-title-4'>conflicts</div><br class="xooki-br"/><b>Tag:</b> conflicts <b>Parent:</b> <a href="../ivyfile.html">ivy-module</a><br/><br/>

<span class="since">(since 2.0)</span> the conflicts section is deprecated.  Use the <a href="ivyfile/conflict.html">conflict</a> instead.<br class="xooki-br"/><br class="xooki-br"/>Container for conflict manager elements, used to indicate how conflicts should be resolved<br class="xooki-br"/>for this module. <br/><br/>

The list of built-in conflict managers available is listed on the <a href="settings/conflict-managers.html">conflict manager configuration page</a>.<br/><br/>

Conflicts manager are used during the resolve operation, i.e. when ivy analyse the graph of dependencies<br class="xooki-br"/>and download corresponding ivy files and artifacts. The fact to manage conflict at resolve time<br class="xooki-br"/>enables to minimize downloads: when a module is evicted by a conflict manager, it is not downloaded.<br/><br/>

There are two things optimized during conflict resolution: download of artifacts and download<br class="xooki-br"/>of ivy files. The first is always ensured by ivy, i.e. artifacts of a module evicted will never<br class="xooki-br"/>be downloaded. The second is not as simple to handle because to know what are the conflicts<br class="xooki-br"/>ivy needs to know the dependency graph, and to know the dependency graph, it has to download<br class="xooki-br"/>ivy files. But ivy is highly optimized on this too, and it tries to evict modules as soon as possible.<br/>
That's why the order of dependencies is important for download optimization. Indeed ivy<br class="xooki-br"/>traverses the dependency graph in the order in which dependencies are declared in the ivy files, <br class="xooki-br"/>and each time it encounters a dependency on a module, it first check if there is a conflict on this module, <br class="xooki-br"/>and if this is the case, it asks the conflict manager to resolve the conflict. Then if the module is evicted,<br class="xooki-br"/>it does not download its ivy file, and the whole branch is not traversed, which can saves<br class="xooki-br"/>a lot of time.<br/><br/>

If this container is not present, a default conflict manager is used for all modules. <br class="xooki-br"/>The current default conflict manager is the "latest-revision" conflict manager.<br class="xooki-br"/><h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/manager.html">manager</a></td><td>declares a conflict manager for this module</td>
        <td>1..n</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-5'>manager</div><br class="xooki-br"/><b>Tag:</b> manager <b>Parent:</b> <a href="../ivyfile/conflicts.html">conflicts</a><br/>
<br/>
<span class="since">(since 2.0)</span> the conflicts section is deprecated.  Use the <a href="ivyfile/conflict.html">conflict</a> instead.<br class="xooki-br"/><br class="xooki-br"/>Specify a a conflict manager for one or several dependencies.<br/>
The way to specify a conflict manager is by giving indication to which dependencies<br class="xooki-br"/>the conflict manager applies (by giving organisation and module names or name regexp), <br class="xooki-br"/>and then specifying the conflict manager, either by giving its name or by<br class="xooki-br"/>specifying a fixed revision list, in which case a fixed conflicts manager is used.<br/><br/>

See <a href="../ivyfile/conflicts.html">Conflicts Manager</a> for details on conflicts manager in general.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ivy-attributes">
<thead>
    <tr><th class="ivy-att">Attribute</th><th class="ivy-att-desc">Description</th><th class="ivy-att-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>org</td><td>the name, or an expression matching the name of organisation to which this conflict manager should apply (see matcher attribute below)</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>module</td><td>the name, or an expression matching the name of module to which this conflict manager should apply (see matcher attribute below)</td>
        <td>No, defaults to * (match all)</td></tr>
    <tr><td>name</td><td>the name of the conflict manager to use</td>
        <td rowspan="2">Exactly one of two</td></tr>
    <tr><td>rev</td><td>a comma separated list of revisions this conflict manager should select</td></tr>
    <tr><td>matcher</td><td>the <a href="../concept.html#matcher">matcher</a> to use to match the modules for which the conflict manager should be used <span class="since">since 1.3</span></td>
        <td>No, defaults to exactOrRegexp in pre 1.3 ivy files, and exact in 1.3 and superior</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-3'>Ant Tasks</div><br class="xooki-br"/>The main and most frequent way to use ivy is from an ant build file. However, ivy can also be called as a standalone application<br class="xooki-br"/><br class="xooki-br"/>If you use ant version <b>1.6.0</b> or superior, you just have to add ivy namespace to your project (<pre>xmlns:ivy="antlib:org.apache.ivy.ant"</pre> attribute of your project tag), and you can call ivy tasks.<br class="xooki-br"/><br class="xooki-br"/>If you want to make your build handle ivy.jar in either ant lib dir or a local lib dir, you can use a taskdef like this:
<pre>
&lt;path id="ivy.lib.path"&gt;<br class="xooki-br"/>    &lt;fileset dir="path/to/dir/with/ivy/jar" includes="*.jar"/&gt;<br class="xooki-br"/>&lt;/path&gt;<br class="xooki-br"/>&lt;taskdef resource="org/apache/ivy/ant/antlib.xml"<br class="xooki-br"/>         uri="antlib:org.apache.ivy.ant" classpathref="ivy.lib.path"/&gt;
</pre>
Combined with the antlib definition in the project namespace, it will load Ivy classes either from your ant lib or a local directory (path/to/dir/with/ivy/jar in this example).<br class="xooki-br"/><br class="xooki-br"/>If you use ant <b>1.5.1</b> or superior, you have to define the tasks you use in your build file. For instance:
<pre>
  &lt;taskdef name="ivy-configure" classname="org.apache.ivy.ant.IvyConfigure"/&gt;<br class="xooki-br"/>  &lt;taskdef name="ivy-resolve" classname="org.apache.ivy.ant.IvyResolve"/&gt;<br class="xooki-br"/>  &lt;taskdef name="ivy-retrieve" classname="org.apache.ivy.ant.IvyRetrieve"/&gt;<br class="xooki-br"/>  &lt;taskdef name="ivy-deliver" classname="org.apache.ivy.ant.IvyDeliver"/&gt; <br class="xooki-br"/>  &lt;taskdef name="ivy-publish" classname="org.apache.ivy.ant.IvyPublish"/&gt;
</pre>
<em>Note: the tasks listed above are non exhaustive. For a complete list of tasks with the corresponding classes, see the <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/ant/antlib.xml">antlib.xml</a> file in svn or the version you use.</em><br class="xooki-br"/><br class="xooki-br"/>Then you can use the tasks, but check their name, following samples assume you use the ivy namespace (ivy:xxx tasks), whereas with ant 1.5 you cannot use namespace, and should therefore use ivy-xxx tasks if you have followed the taskdefs above.<br class="xooki-br"/><br class="xooki-br"/>If you use an ant version lower than 1.5.1, you can not use the ivy tasks... you should then call ivy as any external program.<br class="xooki-br"/><h1>Calling ivy from ant: first steps</h1>
Once your build file is ok to call ivy tasks, the simplest way to use ivy is to call the ivy retrieve task with no parameters:
<pre>
&lt;ivy:retrieve /&gt;
</pre>
This calls ivy with default values, which might be ok in several projects. In fact, it is equivalent to:
<pre>
&lt;target name="resolve"&gt;<br class="xooki-br"/>    &lt;ivy:configure /&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;ivy:resolve file="${ivy.dep.file}" conf="${ivy.configurations}" /&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;ivy:retrieve pattern="${ivy.retrieve.pattern}" conf="${ivy.configurations}" /&gt;<br class="xooki-br"/>&lt;/target&gt;
</pre>

Those 3 tasks follow the 3 main steps of the ivy retrieving dependencies process:
<ul>
<li>First the configure task tells it how it can find dependencies giving it a path to an <a href="settings.html">xml settings file</a>.</li> 
<li>Then the resolve task actually resolves dependencies described by an <a href="ivyfile.html">ivy file</a>, and puts those dependencies in the ivy cache (a directory configured in the settings file).</li>
<li>Finally the retrieve task copies dependencies from the cache to anywhere you want in your file system. You can then use those dependencies to make your classpath with standard ant paths.</li>
</ul>

To understand more accurately the behaviour of ivy tasks, one should know that a property file is loaded in ant by ivy at the beginning of the configure call. This property file contains the following properties:
<pre>
ivy.project.dir = ${basedir}<br class="xooki-br"/>ivy.lib.dir = ${ivy.project.dir}/lib<br class="xooki-br"/>ivy.build.artifacts.dir = ${ivy.project.dir}/build/artifacts<br class="xooki-br"/>ivy.distrib.dir = ${ivy.project.dir}/distrib<br class="xooki-br"/>	<br class="xooki-br"/>ivy.resolver.default.check.modified = false<br class="xooki-br"/>ivy.default.always.check.exact.revision = true<br class="xooki-br"/><br class="xooki-br"/>ivy.configurations = *<br class="xooki-br"/>ivy.resolve.default.type.filter = *<br class="xooki-br"/>ivy.status = integration<br class="xooki-br"/>ivy.dep.file = ivy.xml<br class="xooki-br"/>ivy.settings.file = ivysettings.xml<br class="xooki-br"/>ivy.retrieve.pattern = ${ivy.lib.dir}/[artifact]-[revision].[ext]<br class="xooki-br"/>ivy.deliver.ivy.pattern = ${ivy.distrib.dir}/[type]s/[artifact]-[revision].[ext]<br class="xooki-br"/>ivy.publish.src.artifacts.pattern = ${ivy.distrib.dir}/[type]s/[artifact]-[revision].[ext]<br class="xooki-br"/><br class="xooki-br"/>ivy.report.output.pattern = [organisation]-[module]-[conf].[ext]<br class="xooki-br"/><br class="xooki-br"/>ivy.buildlist.ivyfilepath = ivy.xml<br class="xooki-br"/><br class="xooki-br"/>ivy.checksums=sha1,md5
</pre>
<em>For the latest version of these properties, you can check the <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/core/settings/ivy.properties">svn version</a>.</em><br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> After calling the first Ivy task, the property ivy.version will be available and contains the version of the used Ivy library. <br class="xooki-br"/><br class="xooki-br"/><h1>Ivy tasks attributes : generalities</h1>
Some tasks attributes values may be given through different places. The three possible places are :<br class="xooki-br"/><ol>
<li>task attribute</li>
<li>ivy instance</li>
<li>project property</li>
</ol>
The places are queried in this order, so anything set in task attribute will overwrite what would have been found in ivy instance, for example.<br class="xooki-br"/><br class="xooki-br"/>The ivy instance considered here is an instance of the class Ivy, which is setup by a call to the configure task, and then reused for other tasks. Because most of the tasks need an ivy instance, they first check if one is available (i.e. configure has been called), and if none is available, then a default configure is called and the resulting ivy instance is used in the remaining tasks (unless another configure is called).<br class="xooki-br"/><br class="xooki-br"/>It isn't generally necessary to understand this, but it can lead to some issues if you forget to call configure before another task and if the configure step was required in your environment.<br class="xooki-br"/><br class="xooki-br"/><h1>Usual cycle of main tasks</h1>
<center><img src="images/main-tasks.png" /></center>
<h1>Example</h1>
Here is a more complete example of build file using ivy:<br class="xooki-br"/>
<pre>
&lt;project xmlns:ivy="antlib:org.apache.ivy.ant" name="sample" default="resolve"&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="resolve"&gt;<br class="xooki-br"/>        &lt;ivy:configure file="../ivysettings.xml" /&gt;<br class="xooki-br"/>        <br class="xooki-br"/>        &lt;ivy:resolve file="my-ivy.xml" conf="default, myconf" /&gt;<br class="xooki-br"/>        <br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/>    <br class="xooki-br"/>    &lt;target name="retrieve-default" depends="resolve"&gt;<br class="xooki-br"/>        &lt;ivy:retrieve pattern="lib/default/[artifact]-[revision].[ext]" conf="default" /&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="retrieve-myconf" depends="resolve"&gt;<br class="xooki-br"/>        &lt;ivy:retrieve pattern="lib/myconf/[artifact]-[revision].[ext]" conf="myconf" /&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="retrieve-all" depends="resolve"&gt;<br class="xooki-br"/>        &lt;ivy:retrieve pattern="lib/[conf]/[artifact]-[revision].[ext]" conf="*" /&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="deliver" depends="retrieve-all"&gt;<br class="xooki-br"/>        &lt;ivy:deliver deliverpattern="distrib/[artifact]-[revision].[ext]"<br class="xooki-br"/>                     pubrevision="1.1b4" pubdate="20050115123254" status="milestone" /&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/><br class="xooki-br"/>    &lt;target name="publish" depends="deliver"&gt;<br class="xooki-br"/>        &lt;ivy:publish resolver="internal" <br class="xooki-br"/>                     artifactspattern="distrib/[artifact]-[revision].[ext]" <br class="xooki-br"/>                     pubrevision="1.1b4" /&gt;<br class="xooki-br"/>    &lt;/target&gt;<br class="xooki-br"/>&lt;/project&gt;
</pre>

All ivy tasks are documented in the following pages.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>artifactproperty</div>
<div class="since">since 1.1</div>
Sets an ant property for each dependency artifacts previously resolved.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> This is a <a href="use/postresolvetask.html">post resolve task</a>, with all the behaviour and attributes common to all post resolve tasks.<br class="xooki-br"/><br class="xooki-br"/>Please prefer the use of retrieve + standard ant path creation, which make your build more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).<br class="xooki-br"/><br class="xooki-br"/>The property name and value are generated using the classical pattern concept, all artifact tokens and ivy variables being available.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> This tag will follow the ant usual behavior for properties.  If a property of the same name already exist, it's value will be unchanged.  This behavior can be changed using the 'overwrite' attribute.<br class="xooki-br"/><i>WARNING : Before 2.0, the behavior was to overwrite the properties.  Since 2.0, the default is to not overwrite to properties</i><br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>

<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>a pattern used to generate the name of the properties to set</td>
        <td>Yes</td></tr>
    <tr><td>value</td><td>a pattern used to generate the value of the properties to set</td>
        <td>Yes</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations for which properties should be set</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <b>(since 2.0)</b></td><td>No, 'ivy.instance' is taken by default.</td></tr>
    <tr><td>overwrite</td><td>Overwrite the value of the property if it already exist <b>(since 2.0)</b>.  Before 2.0, the properties were always overwritten.</td><td>No, 'false' by default.</td></tr>
</tbody>
</table>

<h1>Example</h1>
Suppose we have one dependency called <i>mydep</i> in revision 1.0 publishing two artifacts: <i>foo.jar</i> and <i>bar.jar</i>.<br class="xooki-br"/>Then:
<pre>
&lt;artifactproperty conf="build" <br class="xooki-br"/>       name="[module].[artifact]-[revision]" <br class="xooki-br"/>       value="${cache.dir}/[module]/[artifact]-[revision].[ext]"/&gt;
</pre>
will set two properties:
<pre>
mydep.foo-1.0 = my/cache/dir/mydep/foo-1.0.jar<br class="xooki-br"/>mydep.bar-1.0 = my/cache/dir/mydep/bar-1.0.jar
</pre>

	<hr/><div class='toc-title toc-title-4'>artifactreport</div><br class="xooki-br"/><span class="since">since 1.4</span>
The artifactreport task generates an xml report of all artifacts dependencies resolved by the last <a href="../use/resolve.html">resolve</a> task call during the same build.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> This is a <a href="use/postresolvetask.html">post resolve task</a>, with all the behaviour and attributes common to all post resolve tasks.<br class="xooki-br"/><br class="xooki-br"/>This report is different from the standard <a href="../use/report.html">report</a> which reports all modules and artifacts, whle this report is much simpler and focuses only on artifacts, and gives more information on artifacts, such as the original location and the retrieve location. <br class="xooki-br"/><br class="xooki-br"/>It is thus easy to use to generate things like a classpath file for an IDE.<br class="xooki-br"/><br class="xooki-br"/>See this <a href="http://www.jaya.free.fr/ivy/doc/articles/ease-multi-module.html">article by Johan Stuyts</a> (who contributed this task) to see how he uses this task.<br class="xooki-br"/><br class="xooki-br"/>Here is an example of generate file:
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="xooki-br"/>&lt;modules&gt;<br class="xooki-br"/>  &lt;module organisation="hippo" name="sant-classes" rev="1.01.00b04-dev" status="integration"&gt;<br class="xooki-br"/>    &lt;artifact name="sant-classes-src" ext="zip" type="zip"&gt;<br class="xooki-br"/>      &lt;origin-location is-local="true"&gt;<br class="xooki-br"/>        C:/home/jstuyts/data/ivy/local/hippo/sant-classes/1.01.00b04-dev/sant-classes-src-1.01.00b04-dev.zip&lt;/origin-location&gt;<br class="xooki-br"/>      &lt;cache-location&gt;<br class="xooki-br"/>        C:/home/jstuyts/data/ivy/cache/hippo/sant-classes/zips/sant-classes-src-1.01.00b04-dev.zip&lt;/cache-location&gt;<br class="xooki-br"/>      &lt;retrieve-location&gt;lib/test/sant-classes-src-1.01.00b04-dev.zip&lt;/retrieve-location&gt;<br class="xooki-br"/>    &lt;/artifact&gt;<br class="xooki-br"/>    &lt;artifact name="sant-classes-unoptimized" ext="jar" type="jar"&gt;<br class="xooki-br"/>      &lt;origin-location is-local="true"&gt;<br class="xooki-br"/>        C:/home/jstuyts/data/ivy/local/hippo/sant-classes/1.01.00b04-dev/sant-classes-unoptimized-1.01.00b04-dev.jar&lt;/origin-location&gt;<br class="xooki-br"/>      &lt;cache-location&gt;<br class="xooki-br"/>        C:/home/jstuyts/data/ivy/cache/hippo/sant-classes/jars/sant-classes-unoptimized-1.01.00b04-dev.jar&lt;/cache-location&gt;<br class="xooki-br"/>      &lt;retrieve-location&gt;lib/test/sant-classes-unoptimized-1.01.00b04-dev.jar&lt;/retrieve-location&gt;<br class="xooki-br"/>    &lt;/artifact&gt;<br class="xooki-br"/>  &lt;/module&gt;<br class="xooki-br"/>  &lt;module organisation="testng" name="testng" rev="4.6.1-jdk15" status="release"&gt;<br class="xooki-br"/>    &lt;artifact name="testng" ext="jar" type="jar"&gt;<br class="xooki-br"/>      &lt;origin-location is-local="false"&gt;<br class="xooki-br"/>        <a href="http://repository.hippocms.org/maven/testng/jars/testng-4.6.1-jdk15.jar&lt;/origin-location&gt">http://repository.hippocms.org/maven/testng/jars/testng-4.6.1-jdk15.jar&lt;/origin-location&gt</a>;<br class="xooki-br"/>      &lt;cache-location&gt;C:/home/jstuyts/data/ivy/cache/testng/testng/jars/testng-4.6.1-jdk15.jar&lt;/cache-location&gt;<br class="xooki-br"/>      &lt;retrieve-location&gt;lib/test/testng-4.6.1-jdk15.jar&lt;/retrieve-location&gt;<br class="xooki-br"/>    &lt;/artifact&gt;<br class="xooki-br"/>  &lt;/module&gt; 
</pre>

<h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>tofile</td><td>the file to which the report should be written</td>
        <td>Yes</td></tr>
    <tr><td>pattern</td><td>the retrieve pattern to use to fill the retrieve location information about the artifacts</td>
        <td>No. Defaults to ${ivy.retrieve.pattern}.</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to use to generate the report</td>
        <td>No. Defaults to the configurations resolved by the last resolve call</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <b>(since 2.0)</b></td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy:artifactreport tofile="${basedir}/path/to/myreport.xml" /&gt;
</pre>
Generates the artifact report for all configurations resolved during the last resolve call (in the same build).<br class="xooki-br"/>
<pre>
&lt;ivy:artifactreport tofile="${basedir}/path/to/myreport.xml" conf="default"/&gt;
</pre>
Generates the artifact report for only the default configuration resolved during the last resolve call.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>buildlist</div><br class="xooki-br"/>The buildlist task enable to obtain a filelist of files (usually build.xml files) ordered according to ivy dependency information from the least dependent to the most one, or the inverse. (<span class="since">since 1.2</span>)<br class="xooki-br"/><br class="xooki-br"/>This is particularly useful combined with subant, to build a set of interelated projects being sure that a dependency will be built before any module depending on it.<br class="xooki-br"/><br class="xooki-br"/>When the ivy.xml of the modules that you want to order doesn't contains a <a href="../ivyfile/info.html">revision</a> numbers, the rev attributes declared in the dependency is not used.<br class="xooki-br"/>When the ivy.xml of the modules that you want to order contains a <a href="../ivyfile/info.html">revision</a> numbers, the revision numbers are used.    If the revision number doesn't match a dependency description a warning is logged and the modules is considered as different modules.  <br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> A root attribute can also be used to include, among all the modules found, only the one that are dependencies (either direct or transitive) of a root module. This can also be used with the excluderoot attribute, which when set to true will exclude the root itself from the list.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4.1</span> A leaf attribute can also be used to include, among all the modules found, only the one that have dependencies (either direct or transitive) on a leaf module. This can also be used with the excludeleaf attribute, which when set to true will exclude the leaf itself from the list.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> The ivy.sorted.modules property is set in the ant at the end of the task with a comma separated list of ordered modules. This can be useful for debug or information purpose.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> The root and leaf attributes can be a delimited list of modules to use as roots.  These modules, and all their dependencies will be included in the build list.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> By default, all the modules included in a circular dependency are grouped together so that any dependency of any module in the loop will apear before the modules in the loop.  This garantee that if there is a depedendency path between a module A and a module B (but no dependency path from B to A), B will alway apear before A even if A is included in a loop in the provided set of modules to sort.<br class="xooki-br"/>Note that circular dependency can also trigger a failure depending on the value configured in the circularDependencyStrategy of your <a href="../settings/conf.html#circularDependencyStrategy">settings</a><br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> When you are specifying root or leaf modules you can limit the resulting list to only direct dependencies of the roots modules or to modules that directly depends on your leaf modules.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> You can also specify a restartFrom modules.  The difference with root or leaf,  is that you get a list starting at the restartFrom module followed by all the modules that would be after if the parameter would not be there (even if there is no dependency between the restartFrom and the following module).<br class="xooki-br"/><br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>reference</td><td>the reference of the path to set</td>
        <td>Yes</td></tr>
    <tr><td>ivyfilepath</td><td>the relative path from files to order to corresponding ivy files</td><td>No. Defaults to ${ivy.buildlist.ivyfilepath}</td></tr>
    <tr><td>root</td><td><span class="since">since 2.0</span> the names of the modules which should be considered as the root of the buildlist. <br/><span class="since">since 1.3</span> Was limited to only one module name before 2.0.</td><td>No. Defaults to no root (all modules are used in the build list)</td></tr>
    <tr><td>excluderoot</td><td><span class="since">since 1.3</span> true if the root defined should be excluded from the list</td><td>No. Defaults to false</td></tr>
    <tr><td>leaf</td><td><span class="since">since 2.0</span> the names of the modules which should be considered as the leaf of the buildlist. <br/><span class="since">since 1.4.1</span> Was limited to only one module name before 2.0.</td><td>No. Defaults to no leaf (all modules are used in the build list)</td></tr>
  <tr><td>onlydirectdep</td><td><span class="since">since 2.0</span> true if the<br class="xooki-br"/>resulting list should be restricted to direct dependencies of root modules or modules that directly depends on the leaf modules.<br/>
This field is ignored when neither root neither leaf is filled.<br class="xooki-br"/>     </td><td>No. Defaults to no false</td></tr>
    <tr><td>delimiter</td><td><span class="since">since 2.0</span> delimiter to use when specifying multiple module names in the root and leaf properties.</td><td>No. Defaults to the comma (,) character.</td></tr>
    <tr><td>excludeleaf</td><td><span class="since">since 1.4.1</span> true if the leaf defined should be excluded from the list</td><td>No. Defaults to false</td></tr>
    <tr><td>haltonerror</td><td>true to halt the build when an invalid ivy file is encountered, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>skipbuildwithoutivy</td><td>Deprecated, use onMissingDescriptor instead. true to skip files of the fileset with no corresponding ivy file, false otherwise. If false the file with no corresponding ivy file will be considered as independent of the other and put at the beginning of the built filelist.</td><td>No. Defaults to false</td></tr>
    <tr><td>onMissingDescriptor</td><td><span class="since">since 2.0</span> Specify the action to take when no module descriptor file is found for a file of the fileset. Possible values are:<br class="xooki-br"/>    <ul>
    <li>head</li>put at the head of the built filelist.<br class="xooki-br"/>    <li>tail</li>put at the tail of the built filelist.<br class="xooki-br"/>    <li>skip</li>skip the file, which won't be put in the build filelist at all.<br class="xooki-br"/>    <li>warn</li>warn and put at the head of the build filelist.<br class="xooki-br"/>    <li>fail</li>halt the build with a failure.<br class="xooki-br"/>    </ul>
    </td><td>No. Defaults to 'head'</td></tr>
    <tr><td>reverse</td><td>true to obtain the list in the reverse order, i.e. from the most dependent to the least one</td><td>No. Defaults to default false</td></tr>
    <tr><td>restartFrom</td><td><span class="since">since 2.0</span> The name of the module which should be considered as the starting point in the buildlist. This allows for the build to be started at any point in the dependency chain. <br/></td><td>No. Defaults to '*' meaning no restart point (all modules are used in the build list).</td></tr>
    <tr><td>settingsRef</td><td><span class="since">since 2.0</span> A reference to the ivy settings that must be used by this task</td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>

<h2>Parameters specified as nested elements</h2>
<h3>fileset</h3>
FileSets are used to select sets of files to order.<br class="xooki-br"/><h1>Examples</h1>
<pre>
    &lt;ivy:buildlist reference="build-path"&gt;<br class="xooki-br"/>      &lt;fileset dir="projects" includes="**/build.xml"/&gt;<br class="xooki-br"/>    &lt;/ivy:buildlist&gt;
</pre>
Builds a list of build.xml files sorted according to the ivy.xml files found at the same level (the default value for ivyfilepath is ivy.xml).<br class="xooki-br"/><br class="xooki-br"/>This list can then be used like that:
<pre>
    &lt;subant target="build" buildpathref="build-path" /&gt;
</pre>

<hr/>
<pre>
    &lt;ivy:buildlist reference="build-path" ivyfilepath="ivy/ivy.xml" reverse="true"&gt;<br class="xooki-br"/>      &lt;fileset dir="projects" includes="**/build.xml"/&gt;<br class="xooki-br"/>    &lt;/ivy:buildlist&gt;
</pre>
Builds a list of build.xml files sorted according to the ivy.xml files found in an ivy directory relative to those build files. The list is sorted from the most dependent to the least one.<br class="xooki-br"/><hr/>
<pre>
    &lt;ivy:buildlist reference="build-path" ivyfilepath="ivy/ivy.xml" root="myapp"&gt;<br class="xooki-br"/>      &lt;fileset dir="projects" includes="**/build.xml"/&gt;<br class="xooki-br"/>    &lt;/ivy:buildlist&gt;
</pre>
Builds a list of build.xml files sorted according to the ivy.xml files found in an ivy directory relative to those build files. Only build.xml files of modules which are dependencies of myapp (either direct or transitive) are put in the result list.<br class="xooki-br"/><hr/>
<pre>
    &lt;ivy:buildlist reference="build-path" ivyfilepath="ivy/ivy.xml" leaf="mymodule"&gt;<br class="xooki-br"/>      &lt;fileset dir="projects" includes="**/build.xml"/&gt;<br class="xooki-br"/>    &lt;/ivy:buildlist&gt;
</pre>
Builds a list of build.xml files sorted according to the ivy.xml files found in an ivy directory relative to those build files. Only build.xml files of modules which have dependencies (direct or transitive) on mymodule are put in the result list.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>buildobr</div><br class="xooki-br"/><span class="since">since 2.3</span> From a bunch of jar artifacts, generate an OBR (OSGi Bundle Repository) descriptor. It could be then used by the <a href="../resolver/obr.html">obr resolver</a>.<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>out</td><td>the location of the descriptor file to generate</td><td>Yes</td></tr>
    <tr><td>resolverName</td><td>the name of the resolver from which the jars should be to gathered</td><td>No</td></tr>
    <tr><td>cacheName</td><td>the name of the cache from which the jars should be to gathered</td><td>No</td></tr>
    <tr><td>baseDir</td><td>the folder into whicch the jars should be gather recursively</td><td>No</td></tr>
    <tr><td>encoding</td><td>The encoding of the resulting xml file</td><td>No. Defaults to <tt>UTF-8</tt></td></tr>
    <tr><td>indent</td><td>Specify if the xml result file should be indented</td><td>No. Defaults to <tt>true</tt></td></tr>
    <tr><td>quiet</td><td>Log as debug rather than warning the rejected jars as they are illformed</td><td>No. Defaults to <tt>false</tt></td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
    &lt;ivy:buildobr baseDir="${eclipse.home}" out="${basedir}/target/repo-eclipse.xml" indent="true" /&gt;
</pre>
Builds an indented OBR descriptor from an Eclipse install, with their path relative to the Eclipse install.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
    &lt;ivy:configure file="ivysettings.xml" /&gt;<br class="xooki-br"/>    &lt;ivy:buildobr resolverName="my-file-resolver" out="${basedir}/target/repo-eclipse.xml" /&gt;
</pre>
Configure an Ivy settings and builds an OBR descriptor from jars resolved by the defined resolver.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
    &lt;ivy:configure file="ivysettings.xml" /&gt;<br class="xooki-br"/>    &lt;ivy:buildobr cacheName="my-cache" out="${basedir}/target/repo-eclipse.xml" /&gt;
</pre>
Configure an Ivy settings and builds an OBR descriptor from jars contained in the defined cache.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>buildnumber</div><br class="xooki-br"/><span class="since">since 1.4</span>
The buildnumber task is similar to the ant buildnumber task, except that it uses ivy repository to find what is the latest version and calculate a new one for you.<br class="xooki-br"/><br class="xooki-br"/>When called it sets four properties according to what has been found.<br class="xooki-br"/>These properties are:
<ul>
<li>ivy.revision</li> the last revision found in the repository
<li>ivy.new.revision</li> the new revision calculated from the last one (see below)
<li>ivy.build.number</li> the build number found in the repository
<li>ivy.new.build.number</li> the new build number calculated from the last one, usually with +1
</ul>

build numbers are always numbers (composed of digit characters only).<br class="xooki-br"/>ivy.revision can be not set if no revision was found<br class="xooki-br"/>ivy.build.number can be not set if no revision was found or if no number was found in it<br class="xooki-br"/>ivy.new.build.number can be not set if the default new revision to use when no revision is found do not contain any number<br class="xooki-br"/><br class="xooki-br"/>The new revision is calculated using a somewhat complex to explain but very easy to use algorithm, depending on which latest version you asked.<br class="xooki-br"/><br class="xooki-br"/>Indeed you can ask for a new revision based upon the latest found for a particular prefix (the revision asked), then the new revision will be the one immediately after with only the prefix in common. If no prefix is set the very latest version is searched.<br class="xooki-br"/><br class="xooki-br"/>Examples (suppose the latest version of the module is 1.3.1):
<table>
<tr><th>revision asked</th><th>ivy.revision</th><th>ivy.new.revision</th><th>ivy.build.number</th><th>ivy.new.build.number</th></tr>
<tr><td>1.3</td><td>1.3.1</td><td>1.3.2</td><td>1</td><td>2</td></tr>
<tr><td>1</td><td>1.3.1</td><td>1.4</td><td>3</td><td>4</td></tr>
<tr><td>2</td><td>not set</td><td>2.0</td><td>not set</td><td>0</td></tr>
<tr><td></td><td>1.3.1</td><td>1.3.2</td><td>1</td><td>2</td></tr>
</table>
Note that when asking for revision 1, you can get a revision 10.0. To avoid that you can use 1. as revision asked, but in this case ivy won't find revision 1 if its the latest one, and it will thus give 1.0 as new revision. The solution to this problem is to use versions with always the same number of parts (for instance 1.0.0 instead of 1).<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the organisation of the module for which a new build number should be calculated</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the module for which a new build number should be calculated</td>
        <td>Yes</td></tr>
    <tr><td>branch</td><td>the branch of the module for which a new build number should be calculated</td>
        <td>No, defaults to the default branch for this module</td></tr>
    <tr><td>revision</td><td>the revision prefix for which a new build number should be calculated</td>
        <td>No, defaults to no prefix (will find the latest version)</td></tr>
    <tr><td>default</td><td>the default revision to assume when no revision prefix is asked and no revision is found</td>
        <td>No, defaults to 0</td></tr>
    <tr><td>defaultBuildNumber</td><td>the default build number to use for the first revision</td>
        <td>No, defaults to 0</td></tr>
    <tr><td>revSep</td><td>the revision separator to use when no matching revision is found, to separate the revision prefix from the build number</td>
        <td>No, defaults to '.'</td></tr>
    <tr><td>prefix</td><td>the prefix to use for the property names set (will be <i>prefix</i>.revision, <i>prefix</i>.new.revision, ...)</td>
        <td>No, defaults to ivy</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span>.</td><td>No, 'ivy.instance' is taken by default.</td></tr>
    <tr><td>resolver</td><td>the name of the resolver to use for build number calculation <span class="since">(since 2.1)</span></td>
        <td>No, all available resolvers will be used by default.</td></tr>
</tbody>
</table>
<h1>Examples</h1>
Here is how it can be used (suppose 1.3.1 is the latest version of ivy in the repository):
<pre>
&lt;ivy:buildnumber organisation="apache" module="ivy" /&gt;
</pre>
will set 1.3.1 as revision, 1.3.2 as new revision, 1 as build number and 2 as new build number<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:buildnumber organisation="apache" module="ivy" revision="1.3" /&gt;
</pre>
will set 1.3.1 as revision, 1.3.2 as new revision, 1 as build number and 2 as new build number<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:buildnumber organisation="apache" module="ivy" revision="1.2" /&gt;
</pre>
will set 1.2 as revision, 1.2.1 as new revision, no build number and 1 as new build number<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:buildnumber organisation="apache" module="ivy" revision="1." /&gt;
</pre>
will set 1.3.1 as revision, 1.4 as new revision, 3 as build number and 4 as new build number<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:buildnumber organisation="apache" module="ivy" revision="3." /&gt;
</pre>
will set no revision, 3.0 as new revision, no build number and 0 as new build number<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:buildnumber organisation="apache" module="ivy" revision="1.4-RC" defaultBuildNumber="1" revSep=""/&gt;
</pre>
If called while no release candidate is in the repository, will set ivy.revision to 1.4-RC1. Then it will increment each time, 1.4-RC2, 1.4-RC3, and so on.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>cachefileset</div><br class="xooki-br"/>Constructs an ant fileset consisting of artifacts in ivy cache for a configuration (<span class="since">since 1.2</span>).<br/><br/>
This is a <a href="../use/postresolvetask.html">post resolve task</a>, with all the behaviour and attributes common to all post resolve tasks. Note that this task<br class="xooki-br"/>does not rely on retrieve, because built fileset is made of artifacts direcly in ivy cache.<br/><br/>
Please prefer the use of retrieve + standard ant path creation, which make your build<br class="xooki-br"/>more independent from ivy (once artifacts are properly retrieved, ivy is not required any more).<br/><br/>
Built fileset is registered in ant with a given id, and can thus be used like any other ant fileset using<br class="xooki-br"/>refid.<br class="xooki-br"/>  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>setid</td><td>the id to reference the built fileset</td>
        <td>Yes</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to put in the created path</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>type</td><td>comma separated list of artifact types to accept in the path, * for all</td><td>No. Defaults to *</td></tr>
    <tr><td>settingsRef</td><td><span class="since">(since 2.0)</span> A reference to the ivy settings that must be used by this task</td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-4'>cachepath</div><br class="xooki-br"/>Constructs an ant path consisting of artifacts in ivy cache (or origin location with depending on useOrigin setting) for a resolved module configuration.<br class="xooki-br"/><br class="xooki-br"/>This is a <a href="use/postresolvetask.html">post resolve task</a>, with all the behaviour and attributes common to all post resolve tasks.<br class="xooki-br"/><br class="xooki-br"/>If you want to make your build more independent from Ivy, you could consider using the <a href="use/retrieve.html">retrieve task</a>. Once the artifacts are properly retrieved, you can use standard Ant path creation which makes Ivy not necessary any more.<br class="xooki-br"/><br class="xooki-br"/>Built path is registered in ant with a given id, and can thus be used like any other ant path using refid.<br class="xooki-br"/>  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>pathid</td><td>the id to reference the built path</td>
        <td>Yes</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to put in the created path</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>type</td><td>comma separated list of artifact types to accept in the path, * for all (<span class="since">since 1.2</span>)</td><td>No. Defaults to *</td></tr>
    <tr><td>settingsRef</td><td><span class="since">(since 2.0)</span> A reference to the ivy settings that must be used by this task</td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;cachepath pathid="default.classpath" conf="default" /&gt;
</pre>
Construct an ant path composed of all artifacts being part of the default configuration obtained through the last resolve call.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;cachepath pathid="default.classpath" conf="default" useOrigin="true" /&gt;
</pre>
Same as before but will use the original location for local artifacts, and the cache location for other artifacts.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:cachepath organisation="emma" module="emma" revision="2.0.4217" inline="true" conf="ant" pathid="emma.classpath"/&gt;<br class="xooki-br"/>&lt;taskdef resource="emma_ant.properties" classpathref="emma.classpath" /&gt; 
</pre>
Resolves the emma module in version 2.0.4217, constructs an ant path with the corresponding artifacts, and then define the emma tasks using this path.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>cleancache</div><br class="xooki-br"/><span class="since">since 2.0</span>
Cleans the Ivy cache.<br class="xooki-br"/><br class="xooki-br"/>This task is roughly equivalent to:
<pre>
&lt;delete dir="${ivy.cache.dir}" /&gt;
</pre>
Using the regular Ant delete task is more flexible, since it allows to specify the files to delete. But it requires an Ivy settings to be loaded, and settings scoping is possible only by using suffixed ant property for the cache directory. <br class="xooki-br"/><br class="xooki-br"/>This task loads the Ivy settings as any other post settings task, and allows easy scoping with the attribute settingsRef.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task</td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy:cleancache /&gt;
</pre>
Cleans the cache directory as defined in the loaded settings (by default ~/.ivy2/cache)<br class="xooki-br"/>
<pre>
&lt;ivy:cleancache settingsRef="mysettings"/&gt;
</pre>
Cleans the cache directory as defined in the loaded settings identified as 'mysettings'<hr/><div class='toc-title toc-title-4'>configure</div><br class="xooki-br"/>The configure task is used to configure ivy with an xml settings file.<br/><br/>
See <a href="settings.html">Settings Files</a> for details about the settings file itself.<br/><br/>

<span class="since">since 2.0</span> The file loaded used to be called configuration file in versions prior to 2.0. The name 'settings' and the use of the ivy.settings.file is new to 2.0.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.0</span> It is also possible to configure Ivy with the <a href="use/settings.html">settings</a> declaration. The difference with this task is that when using the settings declaration, the configuration of Ivy will be done when the settings are first needed (for instance when you do a resolve), while the configure task will perform a configuration of Ivy instantly, which makes it easier to see the problem if something goes wrong.<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>settingsId</td><td>The settings id useable in the settingsRef attributes of the ivy task that needs a setting.  Note that the ivy tasks will search by default for the settings with the id "ivy.instance", which is the default value.</td><td>No, defaults to "ivy.instance"</td></tr>
    <tr><td>file</td><td>path to the settings file to use</td>
        <td rowspan="2">No. If a file is provided, url is ignored. If none are provided, then it attempts to find a file at ${ivy.settings.file}, and if this file does not exist, it uses ${ivy.settings.url} <span class="since">(since 2.3)</span> or a <a href="../samples/ivysettings-default.xml">default settings file</a></td></tr>
    <tr><td>url</td><td>url of the settings file to use</td></tr>
    <tr><td>override</td><td>Specify what to do when another settings with the same id has already been loaded.<ul><li>true</li> the current settings will take precedence over any previously defined setting with this id<li>false</li> the current settings will not override a previously defined setting with this id<li>notallowed</li>an error is raised if a settings has already been defined with this id</ul></td><td>No, defaults to "notallowed"</td></tr>
    <tr><td>host</td><td>http authentication host</td><td rowspan="4">No, unless authentication is required</td></tr>
    <tr><td>realm</td><td>http authentication realm</td></tr>
    <tr><td>username</td><td>http authentication user name</td></tr>
    <tr><td>passwd</td><td>http authentication password</td></tr>
</tbody>
</table>
<h2>HTTP Authentication</h2>
If any of the url you use in ivy (especially in dependency resolvers) need http<br class="xooki-br"/>authentication, then you have to provide the host, realm, username and passwd<br class="xooki-br"/>attributes of the configure task. These settings will then be used in any<br class="xooki-br"/>further call to ivy tasks.<br/><br/>

<b>Since 1.4:</b><br class="xooki-br"/>It's also possible to configure authentication settings for multiple urls. This can be done with the <credentials> subelements. See the examples for more details.<br class="xooki-br"/><br class="xooki-br"/><h2>Examples</h2>
<h3>Simplest settings</h3>
<pre>&lt;ivy:configure /&gt;</pre>
Use either ${ivy.settings.file} if it exists, or the <a href="../samples/ivysettings-default.xml">default settings file</a><br class="xooki-br"/><h3>Configure with a file</h3>
<pre>&lt;ivy:configure file="myconffile.xml" /&gt;</pre>
<h3>Configure with an url</h3>
<pre>&lt;ivy:configure url="<a href="http://mysite.com/myconffile.xml">http://mysite.com/myconffile.xml</a>" /&gt;</pre>
<h3>Configure multiple URLs which require autentication</h3>
<pre>
&lt;ivy:configure file="path/to/my/ivysettings.xml"&gt;<br class="xooki-br"/>  &lt;credentials host="myhost.com" realm="My Realm" username="myuser" passwd="mypasswd" /&gt;<br class="xooki-br"/>  &lt;credentials host="yourhost.com" realm="Your Realm" username="myuser" passwd="myotherpasswd" /&gt;<br class="xooki-br"/>&lt;/ivy:configure&gt; 
</pre>
	<hr/><div class='toc-title toc-title-4'>convertmanifest</div><br class="xooki-br"/><span class="since">since 2.3</span> Convert a MANIFEST.MF into an ivy.ml file<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>manifest</td><td>the location of the MANIFEST.MF to convert</td><td>Yes</td></tr>
    <tr><td>ivyFile</td><td>the location of the ivy.xml file to generate</td><td>Yes</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
    &lt;ivy:convertmanifest manifest="META-INF/MANIFEST.MF" ivyFile="ivy.xml" /&gt;
</pre>
Just converts a manifest into an ivy.xml file.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>convertpom</div><br class="xooki-br"/><span class="since">since 2.1</span> Convert pom.xml into an ivy.xml<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>pomFile</td><td>the location of the pom.xml to convert</td><td>Yes</td></tr>
    <tr><td>ivyFile</td><td>the location of the ivy.xml to generate</td><td>Yes</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
    &lt;ivy:convertpom pomFile="pom.xml" ivyFile="ivy.xml" /&gt;
</pre>
Just convert an pom.xml file into an ivy.xml.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>deliver</div><br class="xooki-br"/>Deliver a resolved descriptor of the current module, and possibly perform a recursive delivery of dependencies.<br class="xooki-br"/><br class="xooki-br"/>This task does two main things:<br class="xooki-br"/><h2>Generate a resolved ivy file</h2>
This task generates a resolved descriptor of the current module, based upon the last resolve done. The resolved ivy file contains updated information about the delivered module, such as revision and status.<br class="xooki-br"/><br class="xooki-br"/>Moreover, all included configurations' files are included in the ivy file, and variables are replaced by their values.<br class="xooki-br"/><br class="xooki-br"/>Finally, in the resolved ivy file, dynamic revisions are replaced by the static ones that have been found during the resolve step, so the ivy file can be used later safely to obtain the same dependencies (providing that a revision uniquely identifies a module, which should be the case for proper ivy use).<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.3</span> The replacement of dynamic revisions by static ones can be turned off, so that dynamic revisions are kept in the ivy file. This is an exception to the recommended standard that published module descriptors be fully resolved, so use it with caution.<br class="xooki-br"/><br class="xooki-br"/><h2>do recursive delivery</h2>
This is done only if a deliver target is given to the deliver task.<br class="xooki-br"/><br class="xooki-br"/>If a deliver target is set, then it is called (via an antcall) for each dependency which has not a suffisant status compared to the deliver status set for this task. This means that if you deliver an integration revision, no recursive delivery will be done.<br class="xooki-br"/><br class="xooki-br"/>If you deliver a milestone or a release revision, deliver target will be called with each integration dependency. <br class="xooki-br"/><br class="xooki-br"/>The deliver target is called with the following properties available:
<ul>
  <li>dependency.name</li>
the name of the dependency to recursively deliver<br class="xooki-br"/>  <li>dependency.published.status</li>
the status to which the dependency should be delivered<br class="xooki-br"/>  <li>dependency.published.version</li>
the revision to which the dependency should be delivered<br class="xooki-br"/>  <li>dependency.version</li>
the revision of the dependency that should be delivered (the one that was retrieved during last resolve)
</ul>
Both <pre>dependency.published.status</pre> and <pre>dependency.published.version</pre> can be either asked to the user through ant input tasks (default behaviour), or be always the same for the whole recursive delivery process if the following properties are set:
<ul>
<li>recursive.delivery.status</li>set to the status to which all dependencies requiring to be delivered will be
<li>recursive.delivery.version</li>set to the version to which all dependencies requiring to be delivered will be
</ul>

Usually the deliver target itself triggers an another ant build (using ant task) even if this is up to you to decide.<br class="xooki-br"/><br class="xooki-br"/>The delivered ivy file will update its dependency revisions with those given here.  <br class="xooki-br"/><br class="xooki-br"/><h2>deliver and publish</h2>
The deliver task is most of the time not called explicitly, but rather called automatically by the <a href="use/publish.html">publish</a> task. So, when shall the deliver task be called explictly? When you actually need to separate what is performed by the deliver task (see above), from what is performed by the publish task, i.e. upload a module to a repository.<br class="xooki-br"/><br class="xooki-br"/>And this can be particularly useful if you want to process the generated ivy file before uploading it (if you want to add automatically more information like an SCM tag used, the user who performed the release, ...).<br class="xooki-br"/><br class="xooki-br"/>It can also be useful if you want to trigger a recursive delivery and then ensure that you get the recursively delivered modules as dependencies. In this case your build order may look like this:<br class="xooki-br"/>- ivy:configure<br class="xooki-br"/>- ivy:resolve<br class="xooki-br"/>- ivy:deliver with recursive delivery<br class="xooki-br"/>- ivy:resolve again with the ivy file generated by the recursive delivery<br class="xooki-br"/>- do your build stuff (compile, jar, whatever)<br class="xooki-br"/>- ivy:publish <br class="xooki-br"/>  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>deliverpattern</td><td>the pattern to use for ivy file delivery</td>
        <td>No. Defaults to ${ivy.deliver.ivy.pattern}</td></tr>
    <tr><td>pubrevision</td><td>the revision to use for the publication</td>
        <td>No. Defaults to ${ivy.deliver.revision} if set, or the revision resolved if set, or a timestamp</td></tr>
    <tr><td>pubbranch</td><td>the branch to use for the publication</td>
        <td>No. Defaults to ${ivy.deliver.branch} if set, or the branch resolved if set, or nothing (branch info won't be updated)</td></tr>
    <tr><td>pubdate</td><td>the publication date to use for the publication. This date should be either 'now', or a date given with the following pattern: yyyyMMddHHmmss</td>
        <td>No. Defaults to 'now'</td></tr>
    <tr><td>status</td><td>the status to use for the publication</td>
        <td>No. Defaults to ${ivy.status}</td></tr>
    <tr><td>delivertarget</td><td>the target to call for recursive delivery</td>
        <td>No. No recursive delivery is done by default</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>replacedynamicrev</td><td>true to replace dynamic revisions by static ones in the delivered file, false to avoid this replacement <span class="since">(since 1.3)</span></td>
        <td>No. Defaults to true</td></tr>
    <tr><td>replaceForcedRev</td><td>true to replace revisions (static or dynamic) by the revision of the resolver in <a href="../settings/resolvers.html#common">forced mode</a>, false to avoid this replacement <span class="since">(since 2.2)</span></td>
        <td>No. Defaults to false</td></tr>
    <tr><td>merge</td><td>if a descriptor <a href="../ivyfile/extends.html">extends</a> a parent, merge the inherited information directly into the delivered descriptor.  The <i>extends</i> element itself will be commented out in the delivered descriptor. <span class="since">(since 2.2)</span></td>
        <td>No. Defaults to true.</td></tr>
	<tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td>
		<td>No, 'ivy.instance' is taken by default.</td></tr>    
	<tr><td>conf</td><td>comma-separated list of configurations to include in the delivered file. Accepts wildcards. <span class="since">(since 2.0)</span></td>
        <td>No. Defaults to all configurations</td></tr>
	<tr><td>generateRevConstraint</td><td>true to automatically generate a 'revConstraint' attribute in the deliverd file (see the <a href="ivyfile/dependency.html">dependency</a> page for more info about this attribute), false to never generate this attribute <span class="since">(since 2.1.0)</span></td>
        <td>No. Defaults to true</td></tr>
</tbody>
</table>

<h1>Example</h1>
Deliver an ivy file without the private configurations:
<pre>
&lt;deliver conf="*(public)" /&gt; 
</pre>
<hr/><div class='toc-title toc-title-4'>findrevision</div><br class="xooki-br"/><span class="since">since 1.4</span>
Finds the latest revision of a module matching a given version constraint.<br class="xooki-br"/><br class="xooki-br"/>A version constraint is what is used when declaring a <a href="../ivyfile/dependency.html">dependency</a> on a module.<br class="xooki-br"/>If the module is not found the property is not set.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the organisation of the module to find</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the the name of the module to find</td>
        <td>Yes</td></tr>
    <tr><td>branch</td><td>the branch of the module to find</td>
        <td>No, defaults to the default branch for the given module</td></tr>
    <tr><td>revision</td><td>the revision constraint to apply</td>
        <td>Yes</td></tr>
    <tr><td>property</td><td>the property to set with the found revision</td>
        <td>No, defaults to ivy.revision</td></tr>
<tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy:findrevision organisation="apache" module="ivy" revision="latest.integration"/&gt;
</pre>
finds the latest version of ivy available in the repository and sets the property ivy.revision according to what was found.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:findrevision organisation="apache" module="ivy" revision="1.0+"/&gt;
</pre>
same as above but only with 1.0 sub versions.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>info</div><br class="xooki-br"/><span class="since">since 1.4</span>
The info task ease the access to some essential data contained in an ivy file without performing a dependency resolution.<br class="xooki-br"/><br class="xooki-br"/>The information is retrieved by setting ant properties:
<table class="ant">
<thead>
    <tr><th class="ant-prop">Property</th><th class="ant-desc">Description</th></tr>
</thead>
<tbody>
<tr><td>ivy.organisation</td><td>The organisation of the module, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed.</td></tr>
<tr><td>ivy.module</td><td>The name of the module, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed.</td></tr>
<tr><td>ivy.branch</td><td>The branch of the module if any, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed.</td></tr>
<tr><td>ivy.revision</td><td>The revision of the module, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed.</td></tr>
<tr><td>ivy.status</td><td>The status of the module, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed.</td></tr>
<tr><td>ivy.publication</td><td>The publication time of the module, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed. <span class="since">(Since 2.2)</span></td></tr>
<tr><td>ivy.extra.<i>[any extra attribute]</i></td><td>Corresponding extra attribute value, as found in the <a href="../ivyfile/info.html">info</a> tag of the ivy file parsed</td></tr>
<tr><td>ivy.configurations</td><td>A comma separated list of configurations of the module, as declared in the <a href="../ivyfile/configurations.html">configurations</a> section</td></tr>
<tr><td>ivy.public.configurations</td><td>A comma separated list of public configurations of the module, as declared in the <a href="../ivyfile/configurations.html">configurations</a> section</td></tr>
<tr><td>ivy.configuration.<i>[config name]</i>.desc</td><td>For each configuration with a description, a property is created containing this description. <span class="since">(Since 2.2)</span></td></tr>
<tr><td>ivy.artifact.<i>[index]</i>.name</td><td>For each published artifact, a property is created containing its name. <span class="since">(Since 2.2)</span></td></tr>
<tr><td>ivy.artifact.<i>[index]</i>.type</td><td>For each published artifact, a property is created containing its type. <span class="since">(Since 2.2)</span></td></tr>
<tr><td>ivy.artifact.<i>[index]</i>.ext</td><td>For each published artifact, a property is created containing its ext. <span class="since">(Since 2.2)</span></td></tr>
<tr><td>ivy.artifact.<i>[index]</i>.conf</td><td>For each published artifact, a property is created containing its conf. <span class="since">(Since 2.2)</span></td></tr>
<tr><td>ivy.artifact.<i>[index]</i>.extra.<i>[any extra attribute]</i></td><td>For each extra attribute of the published artifact, a property is created containing its name. <span class="since">(Since 2.2)</span></td></tr>
</tbody>
</table>
<br/>
<span class="since">since 2.0</span>

Since Ivy 2.0 this task has been enhanced to allow you to retrieve information about ivy modules in a repository.  Instead of specifying a local ivy file you may specify the organisation, module, revision pattern and (optionally) the branch of the ivy module in the repository you wish to retrieve the information for.<br class="xooki-br"/><br class="xooki-br"/>The revision pattern is what is used when declaring a <a href="../ivyfile/dependency.html">dependency</a> on a module, identical to how the <a href="findrevision.html">findrevision</a> task works.  In fact this task can now be used in place of the findrevision task.<br class="xooki-br"/><br class="xooki-br"/>If no matching module is found then no property values are set.<br class="xooki-br"/><br class="xooki-br"/>You may now also set the property attribute to change the first part of the property names that are set by this task e.g. if you set the property attribute to 'mymodule' this task will set the ant properties <i>mymodule.organisation</i>, <i>mymodule.module</i>, <i>mymodule.revision</i> etc.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.2</span>

Since Ivy 2.2 this task has been enhanced to also retrieve detailed information about the module's published artifacts, as well as the publication time.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>the ivy file to parse</td>
        <td>Yes, if you wish to parse an ivy file.<br/>No, if you are retrieving information about a module from an ivy repository.</td></tr>
    <tr><td>organisation</td><td>the organisation of the module to find <span class="since">(since 2.0)</span></td>
        <td>No, if you wish to parse an ivy file.<br/>Yes, if you are retrieving information about a module from an ivy repository.</td></tr>
    <tr><td>module</td><td>the the name of the module to find <span class="since">(since 2.0)</span></td>
        <td>No, if you wish to parse an ivy file.<br/>Yes, if you are retrieving information about a module from an ivy repository.</td></tr>
    <tr><td>branch</td><td>the branch of the module to find <span class="since">(since 2.0)</span></td>
        <td>No, defaults to the default branch for the given module if you are retrieving information about a module from an ivy repository.</td></tr>
    <tr><td>revision</td><td>the revision constraint to apply <span class="since">(since 2.0)</span></td>
        <td>No, if you wish to parse an ivy file.<br/>Yes, if you are retrieving information about a module from an ivy repository.</td></tr>
    <tr><td>property</td><td>the name to use as the base of the property names set by this task <span class="since">(since 2.0)</span></td>
        <td>No, will default to 'ivy' if not set.</td></tr>
	<tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr></tbody>
</table>
<h1>Examples</h1>
Given this ivy.xml file:
<pre>
&lt;ivy-module version="1.0" xmlns:e="<a href="http://ant.apache.org/ivy/extra">http://ant.apache.org/ivy/extra</a>"&gt;<br class="xooki-br"/>	&lt;info organisation="apache"<br class="xooki-br"/>	       module="info-all"<br class="xooki-br"/>	       branch="trunk"<br class="xooki-br"/>	       revision="1.0"<br class="xooki-br"/>	       status="release"<br class="xooki-br"/>	       e:myextraatt="myvalue"<br class="xooki-br"/>	/&gt;<br class="xooki-br"/>	&lt;configurations&gt;<br class="xooki-br"/>		&lt;conf name="default" /&gt;<br class="xooki-br"/>		&lt;conf name="test" /&gt;<br class="xooki-br"/>		&lt;conf name="private" visibility="private"/&gt;<br class="xooki-br"/>	&lt;/configurations&gt;<br class="xooki-br"/>	&lt;publications&gt;<br class="xooki-br"/>		&lt;artifact name="thing1" type="jar" ext="jar" conf="default" e:data="main"/&gt;<br class="xooki-br"/>		&lt;artifact name="thing2" type="jar" ext="jar" conf="default" e:data="client"/&gt;<br class="xooki-br"/>	&lt;/publications&gt;<br class="xooki-br"/>	&lt;dependencies&gt;<br class="xooki-br"/>		&lt;dependency org="org1" name="mod1.2" rev="2.0"/&gt;<br class="xooki-br"/>	&lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
<pre>
&lt;ivy:info file="${basedir}/path/to/ivy.xml" /&gt;
</pre>
Parses ${basedir}/path/to/ivy.xml and set properties as described above accordingly:
<pre>
ivy.organisation=apache<br class="xooki-br"/>ivy.module=info-all<br class="xooki-br"/>ivy.branch=trunk<br class="xooki-br"/>ivy.revision=1.0<br class="xooki-br"/>ivy.status=release<br class="xooki-br"/>ivy.extra.myextraatt=myvalue<br class="xooki-br"/>ivy.configurations=default, test, private<br class="xooki-br"/>ivy.public.configurations=default, test<br class="xooki-br"/>ivy.artifact.1.name=thing1<br class="xooki-br"/>ivy.artifact.1.type=jar<br class="xooki-br"/>ivy.artifact.1.ext=jar<br class="xooki-br"/>ivy.artifact.1.conf=default<br class="xooki-br"/>ivy.artifact.1.extra.data=main<br class="xooki-br"/>ivy.artifact.2.name=thing2<br class="xooki-br"/>ivy.artifact.2.type=jar<br class="xooki-br"/>ivy.artifact.2.ext=jar<br class="xooki-br"/>ivy.artifact.2.conf=default<br class="xooki-br"/>ivy.artifact.2.extra.data=client
</pre>
Given the same ivy module in a repository:
<pre>
&lt;ivy:info organisation="apache" module="info-all" revision="1.0" /&gt;
</pre>
will set the exact same set of properties as above.  Using:
<pre>
&lt;ivy:info organisation="apache" module="info-all" revision="1.0" property="infotest"/&gt;
</pre>
will set:
<pre>
infotest.organisation=apache<br class="xooki-br"/>infotest.module=info-all<br class="xooki-br"/>infotest.branch=trunk<br class="xooki-br"/>infotest.revision=1.0<br class="xooki-br"/>infotest.status=release<br class="xooki-br"/>infotest.extra.myextraatt=myvalue<br class="xooki-br"/>infotest.configurations=default, test, private<br class="xooki-br"/>infotest.public.configurations=default, test<br class="xooki-br"/>infotest.artifact.1.name=thing1<br class="xooki-br"/>infotest.artifact.1.type=jar<br class="xooki-br"/>infotest.artifact.1.ext=jar<br class="xooki-br"/>infotest.artifact.1.conf=default<br class="xooki-br"/>infotest.artifact.1.extra.data=main<br class="xooki-br"/>infotest.artifact.2.name=thing2<br class="xooki-br"/>infotest.artifact.2.type=jar<br class="xooki-br"/>infotest.artifact.2.ext=jar<br class="xooki-br"/>infotest.artifact.2.conf=default<br class="xooki-br"/>infotest.artifact.2.extra.data=client
</pre>

	<hr/><div class='toc-title toc-title-4'>install</div><br class="xooki-br"/>Installs a module and all its dependencies in a resolver. <span class="since">since 1.3</span>

The module to install should be available in a resolver, and will be installed in another resolver which should support publish.<br class="xooki-br"/><br class="xooki-br"/>This is particularly useful for users who only have a private repository, and want to benefit from public repositories from time to time. In this case, when a module is missing in the private repository, a call to install let download the module from a public repository not usually used for dependency resolution, and install it and its dependencies in the private repository.<br class="xooki-br"/><br class="xooki-br"/>For more details about this task and its usage see the <a href="../tutorial/build-repository.html">build repository tutorial</a><br class="xooki-br"/>  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>from</td><td>the name of the resolver in which the module must be found</td>
        <td>Yes</td></tr>
    <tr><td>to</td><td>the name of the resolver in which the module must be installed</td>
        <td>Yes</td></tr>
    <tr><td>organisation</td><td>the name of the organisation of the module to install</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the name of the module to install</td>
        <td>Yes</td></tr>
    <tr><td>branch</td><td>the branch of the module to install <span class="since">since 2.0</span></td>
        <td>No, defaults to default branch with exact matcher, '*' with any other matcher</td></tr>
    <tr><td>revision</td><td>the revision of the module to install</td>
        <td>Yes</td></tr>
    <tr><td>type</td><td>the type(s) of artefact(s) to install.  You can give multiple values separated by commas</td>
        <td>No, defaults to '*' meaning all types</td></tr>
    <tr><td>conf</td><td>the configurations to install. Only the dependencies of the specified configurations will be installed. <span class="since">since 2.3</span></td>
        <td>No, defaults to '*' meaning all configurations</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>overwrite</td><td>true to override modules already present in the destination resolver, false otherwise</td>
        <td>No, defaults to false</td></tr>
    <tr><td>transitive</td><td>true to install the module and all its transitive dependencies, false to install only the module</td>
        <td>No, defaults to false</td></tr>
    <tr><td>matcher</td><td>the name of the matcher to use to find the modules to install</td>
        <td>No, defaults to exact</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td>
    	<td>No, 'ivy.instance' is taken by default.</td></tr>
    <tr><td>haltonfailure</td><td>true to fail build on unresolved dependencies <span class="since">since 2.0</span></td>
        <td>No, defaults to true</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy:install organisation="apache" module="commons-lang" revision="2.0" from="ivyrep" to="myfsresolver"/&gt;
</pre>
Installs the module commons-lang from apache in revision 2.0 in the resolver myfsresolver. The module is found in the resolver named 'ivyrep'.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>listmodules</div><br class="xooki-br"/><span class="since">since 1.4</span>
Finds the list of modules in the repository matching some criteria and set a corresponding list of properties in ant.<br class="xooki-br"/><br class="xooki-br"/>The criteria is set by given patterns matching the organisation, name branch and revision of the modules to find.<br class="xooki-br"/><br class="xooki-br"/>To know if a module matches the criteria ivy will use the configured <a href="../concept.html#matcher">pattern matcher</a>.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the pattern matching the organisation of the modules to list</td>
        <td>Yes</td></tr>
    <tr><td>module</td><td>the pattern matching the name of the modules to list</td>
        <td>Yes</td></tr>
    <tr><td>branch</td><td>the pattern matching the branch of the modules to list</td>
        <td>No, defaults to '*'</td></tr>
    <tr><td>revision</td><td>the pattern matching the revision of the modules to list</td>
        <td>Yes</td></tr>
    <tr><td>matcher</td><td>the name of the pattern matcher to use for matching the modules fields</td>
        <td>No. Defaults to exactOrRegexp.</td></tr>
    <tr><td>property</td><td>the pattern of the property to set when a module is found</td>
        <td>Yes</td></tr>
    <tr><td>value</td><td>The pattern of the value to set when a module is found</td><td>Yes</td></tr>
<tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr>
<tr><td>resolver</td><td>The name of the resolver to use for searching the modules <span class="since">(since 2.2.0)</span></td><td>No, all available resolvers will be used by default.</td></tr>
</tbody>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy:listmodules organisation="apache" module="ivy" revision="*" property="ivy.[revision]" value="found"/&gt;
</pre>
will find all revisions of the module ivy in the org apache, and create one property for each revision found, the name of the property depending on the revision, the value being always 'found'<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:listmodules organisation="*" module="ivy*" revision="1.0" matcher="glob" property="modules.[module]" value="[organisation]"/&gt;
</pre>
use the glob matcher to find all modules which name starts with ivy with revision 1.0, and sets for each a property with module name found  and organisation for value.<br class="xooki-br"/>Example:<br class="xooki-br"/>modules.ivy=apache<br class="xooki-br"/>modules.ivyde=apache<br class="xooki-br"/>modules.ivytools=ivytools<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>makepom</div><br class="xooki-br"/><span class="since">since 2.0</span>
The makepom task allows to convert an ivy file to a pom file.<br class="xooki-br"/><br class="xooki-br"/>An example of use is to publish an Ivy managed module to a maven 2 repository.<br class="xooki-br"/><br class="xooki-br"/><em>Note that all Ivy features are not supported by maven poms, so the converted pom may not resolve to the exact same dependencies as the original ivy file.</em><br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.2</span>
It is possible to specify a template file defining the structure of the generated POM. The following processing is done on this template:
<ul>
<li>properties like <i>${property.name}</i> are replaced if they are defined in Ant or by the ivy:makepom task (see below for the standard properties)</li>
<li>lines containg the string <i>SKIP_LINE</i> are skipped.</li>
<li>the defined dependencies will be added to the first <dependencies> element encountered in the pom template. If the template doesn't contain a <dependencies> element, it is generated a the end of the pom.
</ul>

The ivy:makepom task defines following properties that can be used in the template. <ul>
<li><b>ivy.pom.groupId</b>: defaults to the organisation as defined in the ivy.xml file</li>
<li><b>ivy.pom.artifactId</b>: defaults to the value of the 'atifactName' attribute of this task, or the name of the module as defined in the ivy.xml file</li>
<li><b>ivy.pom.packaging</b>: defaults to the value of the 'artifactPackaging' attribute of this task, or the extenstion of the artifact</li>
<li><b>ivy.pom.version</b>: defaults to the revision as defined in the ivy.xml file</li>
<li><b>ivy.pom.name</b>: defaults to 'SKIP_LINE'</li>
<li><b>ivy.pom.description</b>: defaults to the value of the 'description' attribute of this task, or 'SKIP_LINE' when not specified</li>
<li><b>ivy.pom.url</b>: defaults to the homepage as defined in the ivy.xml file</li>
<li><b>ivy.pom.license</b>: the content of the specified headerFile, or 'SKIP_LINE' if not specified</li>
<li><b>ivy.pom.header</b>: some Ivy information, or 'SKIP_LINE' if the 'printIvyInfo' attribute is set to false.</li>
</ul>
Note that each property can be given a value manually in the Ant build file. In that case, Ivy will use the value specified in the build file instead of the default value.<br class="xooki-br"/><br class="xooki-br"/>The default template that ships with Ivy looks like this:
<pre>
${ivy.pom.license}<br class="xooki-br"/>${ivy.pom.header}<br class="xooki-br"/>&lt;project xmlns="<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>" xmlns:xsi="<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>"<br class="xooki-br"/>    xsi:schemaLocation="<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/maven-v4_0_0.xsd">http://maven.apache.org/maven-v4_0_0.xsd</a>"&gt;<br class="xooki-br"/><br class="xooki-br"/>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br class="xooki-br"/>  &lt;groupId&gt;${ivy.pom.groupId}&lt;/groupId&gt;<br class="xooki-br"/>  &lt;artifactId&gt;${ivy.pom.artifactId}&lt;/artifactId&gt;<br class="xooki-br"/>  &lt;packaging&gt;${ivy.pom.packaging}&lt;/packaging&gt;<br class="xooki-br"/>  &lt;version&gt;${ivy.pom.version}&lt;/version&gt;<br class="xooki-br"/>  &lt;name&gt;${ivy.pom.name}&lt;/name&gt;<br class="xooki-br"/>  &lt;description&gt;${ivy.pom.description}&lt;/description&gt;<br class="xooki-br"/>  &lt;url&gt;${ivy.pom.url}&lt;/url&gt;<br class="xooki-br"/>&lt;/project&gt;
</pre>

<h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>ivyfile</td><td>the source ivy file to convert</td>
        <td>Yes</td></tr>
    <tr><td>pomfile</td><td>the destination pom file to write</td>
        <td>Yes</td></tr>
    <tr><td>templatefile</td><td>the template file to use when generating the pom <span class="since">(since 2.2)</span></td>
        <td>No, defaults to the internal template file.</td></tr>
    <tr><td>artifactName</td><td>The name of the artifact which is represented by the generated pom file. <span class="since">(since 2.2)</span></td>
        <td>No, defaults to the module name in the source ivy file.</td></tr>
    <tr><td>artifactPackaging</td><td>The packaging of the artifact which is represented by the generated pom file. <span class="since">(since 2.2)</span></td>
        <td>No, the artifact type is taken by default. Defaults to 'pom' if no such artifact is defined.</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to include in the generated pom. Wildcards are supported here. <span class="since">(since 2.2)</span></td>
        <td>No, defaults to all configurations.</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task</td>
        <td>No, 'ivy.instance' is taken by default.</td></tr>
    <tr><td>printIvyInfo</td><td>Add some information about Ivy to the generated POM. <span class="since">(since 2.2)</span></td>
        <td>No, defaults to 'true'.</td></tr>
    <tr><td>headerFile</td><td>the header of the generated pom file</td>
        <td>No</td></tr>
    <tr><td>description</td><td>The description that will be added to the generated pom. <span class="since">(since 2.2)</span></td>
        <td>No, defaults to no description.</td></tr>
</tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>mapping</td>
        <td>describes the mapping from an Ivy module configuration to a Maven POM scope.<br/>These elements takes two attributes: <ul><li>conf</li> the configuration to map<li>scope</li>the scope to which it should be mapped</ul></td>
        <td>0..n</td></tr>
    <tr><td>dependency</td>
        <td>describes extra dependencies that should be added to the generated Maven POM file.<br/>These elements takes the following attributes: <ul><li>group</li> the groupId. Default <i>organisation</i> as defined in <i>info</i><li>artifact</li> the name of the artifact<li>version</li> the version. Default <i>revision</i> as defined in <i>info</i><li>type <span class="since">(since 2.3)</span></li> the type<li>classifier <span class="since">(since 2.3)</span></li> the classifier<li>scope</li> the scope<li>optional</li> is the artifact optional. Default <i>false</i></ul></td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;ivy:makepom ivyfile="${basedir}/path/to/ivy.xml" pomfile="${basedir}/path/to/module.pom" conf="default,runtime"&gt;<br class="xooki-br"/>   &lt;mapping conf="default" scope="compile"/&gt;<br class="xooki-br"/>   &lt;mapping conf="runtime" scope="runtime"/&gt;<br class="xooki-br"/>   &lt;dependency group="com.acme" artifact="acme-logging" version="1.0" optional="true"/&gt;<br class="xooki-br"/>&lt;/ivy:makepom&gt;
</pre>
Converts ${basedir}/path/to/ivy.xml to a pom and writes the result to ${basedir}/path/to/module.pom. The configuration 'default' in the parsed ivy file will be mapped to the scope 'compile', the configuration 'runtime' will be mapped to 'runtime', and other configurations will be excluded.<br class="xooki-br"/><br class="xooki-br"/>The <i>com.acme.acme-logging</i> artifact with version 1.0 will be added as an optional dependency.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>post resolve tasks</div><br class="xooki-br"/>Several tasks in Ivy are considered as post resolve task and share a common behaviour and settings accordingly.<br class="xooki-br"/><br class="xooki-br"/>These tasks are:
<ul>
<li><a href="use/retrieve.html">retrieve</a></li>
<li><a href="use/cachefileset.html">cachefileset</a></li>
<li><a href="use/cachepath.html">cachepath</a></li>
<li><a href="use/artifactproperty.html">artifactproperty</a> <span class="since">(since 2.0)</span></li>
<li><a href="use/artifactreport.html">artifactreport</a> <span class="since">(since 2.0)</span></li>
</ul>

All these tasks will trigger automatically a resolve if:
<ul>
<li>none has already been called in the current build with the attribute keep set to true (see below)</li>
<li>organisation and module are not set</li>
</ul>

<span class="since">Since Ivy 1.4</span>, there are two ways to run a <a href="use/resolve.html">resolve</a>: with an ivy file, or with the inline mode.<br class="xooki-br"/>When you call resolve with an ivy file, the default for it is to keep the resolved data for use by the subsequent post resolve tasks. When you run an inline resolve, the default is not to keep the data. You can override this behaviour by setting the keep attribute as you like.<br class="xooki-br"/><br class="xooki-br"/>If you want to to reuse the resolved data obtained through a call to resolve in another build (i.e. not the current one), then you have to set the organisation and module attributes. This work only if the cache was not cleaned since your last resolve call. This does not work with inline calls, which must be performed in the same build.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>The attributes listed are then mostly used only if a resolve is triggered automatically.<br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>conf</td><td>a comma separated list of the configurations to retrieve or '*'.<br class="xooki-br"/><span class="since">Since 2.0</span> you can also use '*(public)' or '*(private)'.  Note that '*' is interpreted as '*(public)' when inline is true.</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or '*' if no resolve was explicitly called</td></tr>
    <tr><td>inline</td><td>true to use inline mode, false to resolve an ivy file <span class="since">(since 1.4)</span></td><td>No. defaults false</td></tr>
    <tr><td>organisation</td><td>the organisation of the module to retrieve. This usually doesn't need to be set since it defaults to the last resolved one, except for inline mode where it is required.</td><td>Yes in inline mode, otherwise no, it then defaults to last resolved module name</td></tr>
    <tr><td>module</td><td>the name of the module to retrieve. This usually doesn't need to be set since it defaults to the last resolved one, except for inline mode where it is required.</td><td>Yes in inline mode, otherwise no, it then defaults to last resolved module name</td></tr>
    <tr><td>revision</td><td>the revision constraint of the module to retrieve. Used only in inline mode. <span class="since">since 1.4</span></td><td>No. Defaults to latest.integration</td></tr>
    <tr><td>branch</td><td>the name of the branch to resolve in inline mode <span class="since">(since 2.1)</span></td><td>Defaults to no branch in inline mode, nothing in standard mode.</td></tr>
    <tr><td>changing</td><td>indicates that the module may change when resolving in inline mode. See <a href="../concept.html#change">cache and change management</a> for details. Ignored when resolving in standard mode. <span class="since">(since 2.2.0)</span></td><td>No. Defaults to false.</td></tr>
    <tr><td>transitive</td><td>true to resolve dependencies transitively, false otherwise <span class="since">since 1.4</span></td><td>No. Defaults to true</td></tr>
    <tr><td>resolveMode</td><td>the <a href="use/resolve.html">resolve mode</a> to use when an automatic resolve is triggered <span class="since">(since 2.1)</span></td><td>No. defaults to using the resolve mode set in the <a href="settings.html">settings</a></td></tr>
    <tr><td>keep</td><td>true to keep the results of the automatic resolve in memory, false to discard them. When this is false, the standard ivy properties won't be set and other postresolve-tasks (like retrieve and cachepath) won't be able to resuse the results of this resolve!</td><td>No. defaults to false for an inline resolve and to true in any other case</td></tr>
    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td><td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>refresh</td><td>true to force Ivy to resolve dynamic revision in this resolve process, false to use cached resolved revision <span class="since">since 2.1</span></td><td>No. defaults to false</td></tr>
    <tr><td>file</td><td>the file to resolve if a resolve is necessary <span class="since">since 2.0</span></td><td>No. Defaults to the previous resolved Ivy file or to ${ivy.dep.file}</td></tr>
	<tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr>
	<tr><td>resolveId</td><td>The id which was used for a previous resolve, or the resolveId if a new resolve is performed <span class="since">(since 2.0)</span></td><td>No, defaults to '[org]-[module]'.</td></tr>
    <tr><td>log</td><td>the log setting to use during the resolve process. <span class="since">(since 2.0)</span><br/>
Available options are:
<ul><li>default</li> the default log settings, where all usual messages are output to the console
<li>download-only</li> disable all usual messages but download ones. A resolve with everything in cache won't output any message.
<li>quiet</li> disable all usual messages, making the whole resolve process quiet unless errors occur
</ul></td><td>No, defaults to 'default'.</td></tr>
</tbody>
</table>

<h1>Child elements</h1>

<b><i>(Since 2.3)</i></b><br class="xooki-br"/><br class="xooki-br"/>These child elements are defining an inlined ivy.xml's <a href="../ivyfile/dependencies.html">dependencies</a> elements. Thus these child elements cannot be used together with the <i>inline</i> or <i>file</i> attributes.<br class="xooki-br"/>There is one important difference with the ivy.xml's <a href="../ivyfile/dependencies.html">dependencies</a>: there is no master configuration to handle here. There is actually only one, the one on which the resolve will run. So every attribute in <a href="../ivyfile/dependency.html">dependency</a>, <a href="../ivyfile/exclude.html">exclude</a>,  <a href="../ivyfile/override.html">override</a> or <a href="../ivyfile/conflict.html">conflict</a> which is about a master configuration is not supported. And every attribute about a mapping of a master configuration on a dependency configuration is now expecting only the dependency configuration. <br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Element</th><th class="ant-desc">Description</th><th class="ant-req">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/dependency.html">dependency</a></td><td>declares a dependency to resolve</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/exclude.html">exclude</a></td><td>excludes artifacts, modules or whole organizations from the set of dependencies to resolve</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/override.html">override</a></td><td>specify an override mediation rule, overriding the revision and/or branch requested for a transitive dependency <span class="since">since 2.0</span></td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/conflict.html">conflict</a></td><td>specify a a conflict manager for one or several dependencies <span class="since">since 2.0</span></td>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;ivy:cachepath organisation="emma" module="emma" revision="2.0.4217" inline="true" conf="ant" pathid="emma.classpath"/&gt;<br class="xooki-br"/>&lt;taskdef resource="emma_ant.properties" classpathref="emma.classpath" /&gt; 
</pre>
Resolves the emma module in version 2.0.4217, constructs an ant path with the corresponding artifacts, and then define the emma tasks using this path.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>publish</div><br class="xooki-br"/>Publishes the current module's <a href="../ivyfile/publications.html">artifacts</a> and the <a href="../ivyfile.html#resolved">resolved descriptor</a> (delivered ivy file).<br class="xooki-br"/><br class="xooki-br"/>This task is meant to publish the current module descriptor together with its declared publication artifacts to a repository.<br class="xooki-br"/><br class="xooki-br"/>All the artifacts must have been created <em>before</em> calling this task. It does not create the artifacts themselves, but expects to find them at the location indicated by the artifacts pattern.<br class="xooki-br"/><br class="xooki-br"/>The target repository is given through the name of a resolver declared in current ivy settings. See <a href="settings.html">Settings Files</a> for details about resolver supporting artifact publishing.<br class="xooki-br"/><br class="xooki-br"/>It also publishes the delivered ivy file (except if you don't want), and even deliver it, if it has not been done with a previous deliver call or if forcedeliver is set to true. That's why this task takes some parameters useful only for delivery. See the illustration below:<br class="xooki-br"/><br class="xooki-br"/><p><img alt="publish flowchart" src="../images/ivy-publish-fc.png" width="360" height="473"/></p>

<span class="since">since 1.4.1</span>
The source artifact pattern can be specified either as an attribute on the task (artifactspattern) or using a list of nested artifacts element (see examples below).<br class="xooki-br"/>  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>the name of the organisation of the module to publish</td><td>No. Defaults to ${ivy.organisation} or the last resolved module organisation.</td></tr>
    <tr><td>module</td><td>the name of the module to publish</td><td>No. Defaults to ${ivy.module} or the last resolved module name.</td></tr>
    <tr><td>revision</td><td>the revision of the module to publish and also the published revision unless pubrevision is set</td><td>No. Defaults to ${ivy.revision} or the last resolve module revision.</td></tr>
    <tr><td>artifactspattern</td><td>the pattern to use to find artifacts to publish</td>
        <td>No. Defaults to ${ivy.publish.src.artifacts.pattern}</td></tr>
    <tr><td>resolver</td><td>the name of the resolver to use for publication</td>
        <td>Yes</td></tr>
    <tr><td>pubrevision</td><td>the revision to use for the publication</td>
        <td>No. Defaults to the ${ivy.deliver.revision}</td></tr>
    <tr><td>pubbranch</td><td>the branch to use for the publication</td>
        <td>No. Defaults to the ${ivy.deliver.branch}</td></tr>
    <tr><td>forcedeliver</td><td>true to force the implicit call to deliver, false to do it only if the ivy file to publish doesn't exist yet <span class="since">(since 1.4)</span></td>
        <td>No. Defaults to false</td></tr>
    <tr><td>update</td><td>true to update ivy file metadata (revision, branch, publication date and status) before publishing, false otherwise. This is usually not necessary when using deliver before publish.</td>
        <td>No. Defaults to false</td></tr>
    <tr><td>merge</td><td>if this descriptor <a href="../ivyfile/extends.html">extends</a> a parent, merge the inherited information directly into this descriptor on publish.  The <i>extends</i> element itself will be commented out in the published descriptor. <span class="since">(since 2.2)</span></td>
        <td>No. Defaults to true</tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in <a href="settings.html">settings file</a>)</td></tr>
    <tr><td>replacedynamicrev</td><td>true to replace dynamic revisions by static ones in the delivered file, false to avoid this replacement <span class="since">(since 1.3)</span></td>
        <td>No. Defaults to true</td></tr>
    <tr><td>publishivy</td><td>True to publish delivered ivy file, false otherwise</td>
        <td>No. Defaults to true</td></tr>
    <tr><td>conf</td><td>A comma separated list of configurations to publish  <span class="since">(since 1.4.1)</span>. Accepts wildcards <span class="since">(since 2.2)</span>.</td>
        <td>No. Defaults to all configurations</td></tr>
    <tr><td>overwrite</td><td>True to overwrite files in repository if the revision already exist, false to let it as is</td>
        <td>No. Defaults to false</td></tr>
    <tr><td>warnonmissing</td><td>True to warn when artifacts to be published are missing</td>
        <td>No. Defaults to true</td></tr>
    <tr><td>haltonmissing</td><td>True to halt build when artifacts to be published are missing</td>
        <td>No. Defaults to true</td></tr>
    <tr><td>srcivypattern</td><td>the pattern to use to find ivy file to publish, and even deliver if necessary <span class="since">(since 1.2)</span></td>
        <td>No. Defaults to the value of artifactspattern</td></tr>
    <tr><td>pubdate</td><td>the publication date to use for the delivery, if necessary. This date should be either 'now', or a date given with the following pattern: yyyyMMddHHmmss</td>
        <td>No. Defaults to 'now'</td></tr>
    <tr><td>status</td><td>the status to use for the delivery, if necessary</td>
        <td>No. Defaults to ${ivy.status}</td></tr>
    <tr><td>delivertarget</td><td>the target to call for recursive delivery</td>
        <td>No. No recursive delivery is done by default</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr></tbody>
</table>
<h1>Child elements</h1>
<table class="ivy-children">
<thead>
    <tr><th class="ivy-chld">Element</th><th class="ivy-chld-desc">Description</th><th class="ivy-chld-card">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td>artifact</td>
        <td>Describe additional artifacts to publish<br/>These elements can have any attribute: standard artifact attributes and (since 2.2) extra attributes are supported.</td>
        <td>0..n</td></tr>
    <tr><td>artifacts</td>
        <td>Specify the pattern used to find the artifact.<br/>These elements have a <i>pattern</i> attribute containing the pattern used to find the artifact.</td>
        <td>0..n</td></tr>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;ivy:publish resolver="local" pubrevision="1.0"&gt;<br class="xooki-br"/>   &lt;artifacts pattern="build/artifacts/jars/[artifact].[ext]" /&gt;<br class="xooki-br"/>   &lt;artifacts pattern="build/artifacts/zips/[artifact].[ext]" /&gt;<br class="xooki-br"/>&lt;/ivy:publish&gt;
</pre>
Publishes the last resolved module in the local resolver with revision 1.0, looking for artifacts in directories <i>build/artifacts/jars</i> and <i>build/artifacts/zips</i>.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>repreport</div><br class="xooki-br"/>Generates reports about dependencies among several modules in the repository (repreport stands for repository report).<span class="since">since 1.4</span>

This task is similar to the <a href="use/report.html">report</a> task, except that instead of working on a single module you just resolved, it works with a set of modules in your repository.<br class="xooki-br"/><br class="xooki-br"/>Note that the set of modules for which you generate the report is determined by setting organisation module and revision and using a matcher, but also by the dependencies of these modules. No dependency is excluded.<br class="xooki-br"/><br class="xooki-br"/>Usually the most useful report is a graph, you can generate either a graphml file that you can then easily <a href="../yed.html">layout using yEd</a>, or a dot file which is the format recognized by graphviz, which is a free tool which does automatic graph layout, and can thus be used to generate automatically a GIF or PNG of the dependencies between all your modules.<br class="xooki-br"/><br class="xooki-br"/><strong>Limitation</strong>: this task requires to be able to browse the repository, and is thus limited to resolvers supporting repository listing. In particular, it means it doesn't work to report all organizations in a repository using m2compatible mode.<br class="xooki-br"/>Moreover, to be able to list organizations, this task requires an [organisation] token in the resolver(s) used.<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>organisation</td><td>A pattern matching the organisation of the modules for which the report should be generated</td>
        <td>No, defaults to '*'</td></tr>
    <tr><td>module</td><td>A pattern matching the name of the modules for which the report should be generated</td>
        <td>No, defaults to '*'</td></tr>
    <tr><td>branch</td><td>The name of the branch of the modules for which the report should be generated</td>
        <td>No, defaults to no branch specified</td></tr>
    <tr><td>revision</td><td>The revision of the modules for which the report should be generated. Only one revision per module will be used, so most of the time keeping the default (latest.integration) is the best thing to do, because it's not very easy to specify only one revision for several modules.</td>
        <td>No, defaults to 'latest.integration'</td></tr>
    <tr><td>todir</td><td>the directory to which reports should be generated</td>
        <td>No, defaults to execution directory</td></tr>
    <tr><td>outputname</td><td>the name to use for the generate file (without extension)</td>
        <td>No, defaults to ivy-repository-report</td></tr>
    <tr><td>xml</td><td>true to generate a xml report, false otherwise</td>
        <td>No, defaults to true</td></tr>
    <tr><td>xsl</td><td>true to generate a report using xslt, false otherwise</td>
        <td>No, defaults to false</td></tr>
    <tr><td>xslfile</td><td>indicates which xsl file should be used to generate the report</td>
        <td>Yes if you want to use xsl transformation</td></tr>
    <tr><td>xslext</td><td>indicates the extension to use when generating report using xsl</td>
        <td>No defaults to 'html'</td></tr>
    <tr><td>graph</td><td>true to generate graphml file, false otherwise</td>
        <td>No, defaults to false</td></tr>
    <tr><td>dot</td><td>true to generate graphviz dot format file, false otherwise</td>
        <td>No, defaults to false</td></tr>
    <tr><td>matcher</td><td>the name of the matcher to use for matching modules names and organisations in your repository</td>
        <td>No. Defaults to exactOrRegexp</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr></tbody>
</table>

<h1>Examples</h1>
To generate a xml report for all the latest versions of all the modules in your repository:
<pre>
&lt;ivy:repreport /&gt;
</pre>

<hr/>
To generate a graphml report for all the latest versions of all the modules in your repository:
<pre>
&lt;ivy:repreport xml="false" graph="true" /&gt;
</pre>

<hr/>
To generate a xml report for all the latest versions of the modules from the organisation foo in your repository:
<pre>
&lt;ivy:repreport organisation="foo" /&gt;
</pre>

<hr/>
To generate a xml report for all the versions on the 1.x stream of the modules named bar* from the organisation foo in your repository:
<pre>
&lt;ivy:repreport organisation="foo" module="bar*" revision="1.+" matcher="glob" /&gt;
</pre>

<hr/>
To generate an XML report using a custom stylesheet:
<pre>
&lt;ivy:repreport xsl="true" xslfile="my-custom-stylesheet.xsl" xslext="xml" /&gt;
</pre>

<hr/>
To generate an XML report using a custom stylesheet which needs some parameters:
<pre>
&lt;ivy:repreport xsl="true" xslfile="my-custom-stylesheet.xsl" xslext="xml"&gt;<br class="xooki-br"/>    &lt;param name="param1" expression="value1" /&gt; <br class="xooki-br"/>    &lt;param name="param2" expression="value2" /&gt; <br class="xooki-br"/>&lt;/report&gt;
</pre>

	<hr/><div class='toc-title toc-title-4'>resolve</div><br class="xooki-br"/>The resolve task actually resolve dependencies described in an <a href="../ivyfile.html">ivy file</a>, and put the resolved dependencies in the ivy cache.<br class="xooki-br"/>If configure has not been called before resolve is called, a default configuration will be used (equivalent to call configure with no attributes).<br class="xooki-br"/><br class="xooki-br"/>After the call to this task, four properties are set in ant:
<ul>
<li>ivy.organisation</li>
set to the organisation name found in the ivyfile which was used for resolve
<li>ivy.module</li>
set to the module name found in the ivyfile which was used for resolve
<li>ivy.revision</li>
set to the revision name found in the ivyfile which was used for resolve, or a generated revision name if no revision was specified in the file
<li>ivy.resolved.configurations</li>
set to the comma separated list of configurations resolved
</ul>
<b>Since 1.2:</b><br class="xooki-br"/>An additional property is set to true if the resolved dependencies are changes since the last resolve, and to false otherwise: <pre>ivy.deps.changed</pre>
<b>Since 2.0:</b><br class="xooki-br"/>The property ivy.deps.changed will not be set (and not be computed) if you set the parameter <i>checkIfChanged</i> to false. (by default it is true to keep backward compatibility).  This allow to optimize your build when you have multi-module build with multiple configurations.<br class="xooki-br"/><br class="xooki-br"/><b>Since 2.0:</b><br class="xooki-br"/>In addition, if the <i>resolveId</i> attribute has been set, the following properties are set as well:
<ul>
<li>ivy.organisation.${resolveId}</li>
<li>ivy.module.${resolveId}</li>
<li>ivy.revision.${resolveId}</li>
<li>ivy.resolved.configurations.${resolveId}</li>
<li>ivy.deps.changed.${resolveId}</li>
</ul>

When ivy has finished the resolve task, it outputs a summary of what has been resolved. This summary looks like this:
<pre>
---------------------------------------------------------------------<br class="xooki-br"/>|                  |            modules            ||   artifacts   |<br class="xooki-br"/>|       conf       | number| search|dwnlded|evicted|| number|dwnlded|<br class="xooki-br"/>---------------------------------------------------------------------<br class="xooki-br"/>|      default     |   4   |   0   |   0   |   0   ||   4   |   0   |<br class="xooki-br"/>---------------------------------------------------------------------
</pre>
This table gives some statistics about the dependency resolution. Each line correspond to a configuration resolved. Then the table is divided in two parts:
<ul>
<li>modules</li>
<ul>
<li>number</li>
This is the total number of dependency modules resolved in this configuration, including transitive ones
<li>search</li>
This is the number of dependency modules that required a repository access. The repository access is needed if the module is not yet in cache, or if a latest version is required, or in some other cases (depending on checkModified, for instance)
<li>dwnlded</li>
This is the number of dependency ivy files downloaded from the repository. This number can be less than the total number of modules even with a clean cache, if no ivy file is provided for some dependencies.
<li>evicted</li>
This is the number of dependency module evicted by conflict managers.
</ul>
<li>artifacts</li>
<ul>
<li>number</li>
This is the total number of artifacts resolved in the given configuration.
<li>dwnlded</li>
This is the number of artifacts actually downloaded from the repository.
</ul>
</ul>

<h2>Inline mode</h2>
<span class="since">since 1.4</span> The inline mode allow to call a resolve without an ivy file, by setting directly the module which should be resolved from the repository. It is particularly useful to install released software, like an ant task for example. When inline is set to true, the organisation module and revision attributes are used to specify which module should be resolved from the repository. <br class="xooki-br"/><br class="xooki-br"/><b>Remark:</b> if you want the standard ivy properties to be set or to reuse the results of an inline resolve by other post-resolve tasks like retrieve, cachepath, report, ..., you must set the keep attribute to true!<br class="xooki-br"/><br class="xooki-br"/><h2>Resolve mode</h2>
<span class="since">since 2.0</span> The resolve mode allows to define how Ivy should use dependency revision constraints when performing the resolution.<br class="xooki-br"/><br class="xooki-br"/>Two modes are available:
<ul>
<li>default</li> In this mode the default revision constraint (expressed with the rev attribute in the <a href="ivyfile/dependency.html">dependency</a> element) is used.
<li>dynamic</li> In this mode the dynamic revision constraint (expressed with the revConstraint attribute in the <a href="ivyfile/dependency.html">dependency</a> element) is used.
</ul>

<h2>Concurrency</h2>
During resolve, Ivy creates a file in the <a href="settings/caches.html">resolution cache</a>. The creation of this file is not aimed to support concurrency, meaning that you can't have two concurrent resolve of the same module, in the same resolution cache, with the same resolveId. <br class="xooki-br"/><br class="xooki-br"/><i>Note for developers:<br class="xooki-br"/>After the call to this task, a reference to the module descriptor resolved is put in the ant project under the id <pre>"ivy.resolved.descriptor"</pre>.</i><br class="xooki-br"/><br class="xooki-br"/><h1>Attributes</h1>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>file</td><td>path to the ivy file to use for resolution</td>
        <td>No. Defaults to ${ivy.dep.file} or nothing in inline mode</td></tr>

    <tr><td>conf</td><td>a comma separated list of the configurations to resolve, or '*'.  <br class="xooki-br"/><span class="since">Since 2.0</span>, you can also use '*(private)', '*(public)'.  Note that when inline is true, the configuration '*' is equivalent as '*(public)'.</td><td>No. Defaults to ${ivy.configurations}</td></tr>

    <tr><td>refresh</td><td>true to force Ivy to resolve dynamic revision in this resolve process, false to use cached resolved revision <span class="since">since 2.0</span></td><td>No. defaults to false</td></tr>

    <tr><td>resolveMode</td><td>the resolve mode to use for this dependency resolution process <span class="since">since 2.0</span></td><td>No. defaults to using the resolve mode set in the <a href="settings.html">settings</a></td></tr>

    <tr><td>inline</td><td>true to use inline mode, false to resolve an ivy file <span class="since">since 1.4</span></td><td>No. defaults to false</td></tr>

    <tr><td>keep</td><td>true to keep the results of the resolve in memory, false to discard them. When this is false, the standard ivy properties won't be set and other postresolve-tasks (like retrieve and cachepath) won't be able to resuse the results of this resolve!</td><td>No. defaults to false for an inline resolve and to true in any other case</td></tr>

    <tr><td>organisation</td><td>the organisation of the module to resolve in inline mode <span class="since">since 1.4</span></td><td>Yes in inline mode, no otherwise.</td></tr>

    <tr><td>module</td><td>the name of the module to resolve in inline mode <span class="since">since 1.4</span></td><td>Yes in inline mode, no otherwise.</td></tr>

    <tr><td>revision</td><td>the revision constraint to apply to the module to resolve in inline mode <span class="since">since 1.4</span></td><td>No. Defaults to "latest.integration" in inline mode, nothing in standard mode.</td></tr>

    <tr><td>branch</td><td>the name of the branch to resolve in inline mode <span class="since">(since 2.1.0)</span></td><td>Defaults to no branch in inline mode, nothing in standard mode.</td></tr>

    <tr><td>changing</td><td>indicates that the module may change when resolving in inline mode. See <a href="../concept.html#change">cache and change management</a> for details. Ignored when resolving in standard mode. <span class="since">(since 1.4)</span></td><td>No. Defaults to false.</td></tr>

    <tr><td>type</td><td>comma separated list of accepted artifact types (<span class="since">since 1.2</span>)</td><td>No. defaults to ${ivy.resolve.default.type.filter}</td></tr>

    <tr><td>haltonfailure</td><td>true to halt the build on ivy failure, false to continue</td><td>No. Defaults to true</td></tr>

    <tr><td>failureproperty</td><td>the name of the property to set if the resolve failed <span class="since">since 1.4</span></td><td>No. No property is set by default.</td></tr>

    <tr><td>transitive</td><td>true to resolve dependencies transitively, false otherwise <span class="since">since 1.4</span></td><td>No. Defaults to true</td></tr>

    <tr><td>showprogress</td><td>true to show dots while downloading, false otherwise</td><td>No. Defaults to true</td></tr>

    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td><td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>

    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr>

    <tr><td>resolveId</td><td>An id which can be used later to refer to the results of this resolve <span class="since">(since 2.0)</span></td><td>No, defaults to '[org]-[module]'.</td></tr>

    <tr><td>log</td><td>the log setting to use during the resolve process. <span class="since">(since 2.0)</span><br/>
Available options are:
<ul><li>default</li> the default log settings, where all usual messages are output to the console
<li>download-only</li> disable all usual messages but download ones. A resolve with everything in cache won't output any message.
<li>quiet</li> disable all usual messages, making the whole resolve process quiet unless errors occur
</ul></td><td>No, defaults to 'default'.</td></tr>

     <tr><td>checkIfChanged</td><td>When set to true, the resolve will compare the result with the last resolution done on this module, with those configurations in order to define the property ivy.deps.changed.  Put it to false may provides slightly better performance. <span class="since">(since 2.0)</span></td><td>No, default to 'true'</td></tr>

     <tr><td>useCacheOnly</td><td>When set to true, it forces the resolvers to only use their caches and not their actual contents.<span class="since">(since 2.0)</span></td><td>No, default to 'false'</td></tr>

</tbody>
</table>

<h1>Child elements</h1>

<b><i>(Since 2.3)</i></b><br class="xooki-br"/><br class="xooki-br"/>These child elements are defining an inlined ivy.xml's <a href="../ivyfile/dependencies.html">dependencies</a> elements. Thus these child elements cannot be used together with the <i>inline</i> or <i>file</i> attributes.<br class="xooki-br"/>There is one important difference with the ivy.xml's <a href="../ivyfile/dependencies.html">dependencies</a>: there is no master configuration to handle here. There is actually only one, the one on which the resolve will run. So every attribute in <a href="../ivyfile/dependency.html">dependency</a>, <a href="../ivyfile/exclude.html">exclude</a>,  <a href="../ivyfile/override.html">override</a> or <a href="../ivyfile/conflict.html">conflict</a> which is about a master configuration is not supported. And every attribute about a mapping of a master configuration on a dependency configuration is now expecting only the dependency configuration. <br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Element</th><th class="ant-desc">Description</th><th class="ant-req">Cardinality</th></tr>
</thead>
<tbody>
    <tr><td><a href="../ivyfile/dependency.html">dependency</a></td><td>declares a dependency to resolve</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/exclude.html">exclude</a></td><td>excludes artifacts, modules or whole organizations from the set of dependencies to resolve</td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/override.html">override</a></td><td>specify an override mediation rule, overriding the revision and/or branch requested for a transitive dependency <span class="since">since 2.0</span></td>
        <td>0..n</td></tr>
    <tr><td><a href="../ivyfile/conflict.html">conflict</a></td><td>specify a a conflict manager for one or several dependencies <span class="since">since 2.0</span></td>
</tbody>
</table>

<h1>Examples</h1>
<pre>
&lt;ivy:resolve file="path/to/ivy.xml"/&gt;
</pre>
Resolve all dependencies declared in path/to/ivy.xml file.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:resolve file="path/to/ivy.xml" transitive="false" /&gt;
</pre>
Same as above, but with transitive dependencies disabled.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:resolve file="path/to/ivy.xml" conf="default, test"/&gt;
</pre>
Resolve the dependencies declared in the configuration default and test of the path/to/ivy.xml file.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:resolve file="path/to/ivy.xml" type="jar"/&gt;
</pre>
Resolve all dependencies declared in path/to/ivy.xml file, but download only jar artifacts.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:resolve organisation="apache" module="commons-lang" revision="2+" inline="true" /&gt;
</pre>
Resolve the commons-lang module revision 2+ from the repository, with its dependencies.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:resolve&gt;<br class="xooki-br"/>    &lt;dependency org="apache" name="commons-lang" rev="2+" /&gt;<br class="xooki-br"/>    &lt;dependency org="apache" name="commons-logging" rev="1.1" /&gt;<br class="xooki-br"/>    &lt;exclude org="apache" module="log4j" /&gt;<br class="xooki-br"/>&lt;/ivy:resolve&gt;
</pre>
Resolve of both commons lang and commons logging, with their dependencies but not log4j.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:resolve&gt;<br class="xooki-br"/>    &lt;dependency org="org.slf4j" module="slf4j" rev="1.6" conf="api,log4j" /&gt;<br class="xooki-br"/>&lt;/ivy:resolve&gt;
</pre>
Resolve the configurations "api" and "log4j" of "slf4j".<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>resources</div><br class="xooki-br"/><b><i>(since 2.3) (Ant 1.7 required)</i></b><br class="xooki-br"/><tt>ivy:resources</tt> is an Ant <a href="http://ant.apache.org/manual/Types/resources.html#collection">resource collection</a>, which files are based on an Ivy resolve, and then can be used with any task which is working with resources like <tt>copy</tt> or <tt>import</tt>.<br class="xooki-br"/><br class="xooki-br"/>This datatype share the same attributes, child elements and behaviour of a <a href="use/postresolvetask.html">post resolve task</a>. It is not expected to be used as an Ant task though, only as a resource collection.<br class="xooki-br"/><br class="xooki-br"/><h1>Examples</h1>
<pre>
&lt;ivy:resources file="path/to/ivy.xml"/&gt;
</pre>
Build a resource collection of every artifacts of all dependencies declared in path/to/ivy.xml file.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:resources file="path/to/ivy.xml" transitive="false" /&gt;
</pre>
Same as above, but with transitive dependencies disabled.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:resources file="path/to/ivy.xml" conf="default, test"/&gt;
</pre>
Build a resource collection of every artifacts of the dependencies declared in the configuration default and test of the path/to/ivy.xml file.<br class="xooki-br"/><br class="xooki-br"/><hr/>

<pre>
&lt;ivy:resources file="path/to/ivy.xml" type="jar"/&gt;
</pre>
Build a resource collection of every jar artifact of all dependencies declared in path/to/ivy.xml file.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:resources organisation="apache" module="commons-lang" revision="2+" inline="true" /&gt;
</pre>
Build a resource collection of every artifacts of commons-lang module revision 2+ from the repository, with its dependencies.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:resources&gt;<br class="xooki-br"/>    &lt;dependency org="apache" module="commons-lang" rev="2+" /&gt;<br class="xooki-br"/>    &lt;dependency org="apache" module="commons-logging" rev="1.1" /&gt;<br class="xooki-br"/>    &lt;exclude org="apache" module="log4j" /&gt;<br class="xooki-br"/>&lt;/ivy:resources&gt;
</pre>
Build a resource collection of every artifacts of both commons lang and commons logging, with their dependencies but not log4j.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:resources&gt;<br class="xooki-br"/>    &lt;dependency org="org.slf4j" module="slf4j" rev="1.6" conf="api,log4j" /&gt;<br class="xooki-br"/>&lt;/ivy:resources&gt;
</pre>
Build a resource collection of every artifacts of the configurations "api" and "log4j" of "slf4j".<br class="xooki-br"/><br class="xooki-br"/><hr/><div class='toc-title toc-title-4'>retrieve</div><br class="xooki-br"/>The retrieve task copies resolved dependencies anywhere you want in your file system.<br class="xooki-br"/><br class="xooki-br"/>This is a <a href="use/postresolvetask.html">post resolve task</a>, with all the behaviour and attributes common to all post resolve tasks.<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 1.4</span> This task can even be used to synchronize the destination directory with what should actually be in according to the dependency resolution. This means that by setting sync="true", Ivy will not only copy the necessary files, but it will also remove the files which do not need to be there.<br class="xooki-br"/><br class="xooki-br"/>The synchronisation actually consists in deleting all filles and directories in the root destination directory which are not required by the retrieve.<br class="xooki-br"/><br class="xooki-br"/>The root destination directory is the the directory denoted by the first level up the first token in the destination pattern.<br class="xooki-br"/>Example:<br class="xooki-br"/>pattern: lib/[conf]/[artifact].[ext]<br class="xooki-br"/>root: lib<br class="xooki-br"/><br class="xooki-br"/><span class="since">since 2.3</span> A nested <a href="http://ant.apache.org/manual/Types/mapper.html">mapper</a> element can be used to specify more complex filename transformations of the retrieved files. See the examples below.<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>pattern</td><td>the pattern to use to copy the dependencies</td>
        <td>No. Defaults to ${ivy.retrieve.pattern}</td></tr>
    <tr><td>ivypattern</td><td>the pattern to use to copy the ivy files of dependencies <span class="since">since 1.3</span></td>
        <td>No. Dependencies ivy files are not retrieved by default.</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations to retrieve</td>
        <td>No. Defaults to the configurations resolved by the last resolve call, or * if no resolve was explicitly called</td></tr>
    <tr><td>sync</td><td>true to synchronize the destination, false to just make a copy <span class="since">since 1.4</span></td>
        <td>No. Defaults to false</td></tr>
    <tr><td>type</td><td>comma separated list of accepted artifact types <span class="since">since 1.4</span></td>
        <td>No. All artifact types are accepted by default.</td></tr>
    <tr><td>overwriteMode</td><td>option to configure when the destination file should be overwritten if it exist <span class="since">(since 2.2.0)</span>.<br class="xooki-br"/>Possible values are:
<ul><li><b>newer</b> (default)</li> overwrite the destination file if a more recent one is available (based on timestamp)
<li><b>different</b></li> overwrite the destination file if the timestamp is different
<li><b>always</b></li> always overwrite the destination file
<li><b>never</b></li> never overwrite the destination file
</ul></td><td>No. Defaults to 'newer'.</td></tr>
    <tr><td>symlink</td><td>true to create symbolic links, false to copy the artifacts. The destination of the symbolic links depends on the value of the useOrigin attribute <span class="since">(since 2.0)</span></td><td>No. Defaults to false</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr></tbody>
    <tr><td>log</td><td>the log setting to use during the resolve and retrieve process. <span class="since">(since 2.0)</span><br/>
Available options are the same as for <a href="use/resolve.html">resolve</a> when used to trigger resolve automatically (see <a href="use/postresolvetask.html">postresolvetask</a>), or the following for the retrieve process only:
<ul><li><b>default</b></li> the default log settings, where all usual messages are output to the console
<li><b>quiet</b></li> disable all usual messages, making the whole retrieve process quiet unless errors occur
</ul></td><td>No, defaults to 'default'.</td></tr>
    <tr><td>pathId</td><td>the id of the path to create containing the retrieved artifacts. <span class="since">since 2.3</span></td>
        <td>No. No path is created by default.</td></tr>
    <tr><td>setId</td><td>the id of the fileset to create containing the retrieved artifacts. <span class="since">since 2.3</span></td>
        <td>No. No fileset is created by default.</td></tr>
</table>
<h1>Examples</h1>
<pre>
&lt;ivy:retrieve /&gt;
</pre>
Retrieves dependencies using default parameters. This usually retrieves all the dependencies of the last resolve call to a lib directory.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:retrieve pattern="${lib.dir}/[conf]/[artifact].[ext]"/&gt;
</pre>
Retrieves all dependencies of the last resolve call to a lib directory, dependencies being separated in directories named by configuration, each conf directory containing corresponding artifacts without the revision.<br class="xooki-br"/>For instance, if the ivy file declares two configurations default and test, the resulting lib dir could look like this:
<pre>
lib<br class="xooki-br"/>  default<br class="xooki-br"/>    commons-lang.jar<br class="xooki-br"/>    commons-logging.jar<br class="xooki-br"/>  test<br class="xooki-br"/>    junit.jar
</pre>
Note that if a dependency is required in the two configurations, it will be copied in the two directories. The download of the dependency is however only made once at resolve time.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:retrieve pattern="${lib.dir}/[conf]/[artifact].[ext]" sync="true" /&gt;
</pre>
Same as before, but with synchronisation enabled.<br class="xooki-br"/><br class="xooki-br"/>For instance, if the ivy file declares two configurations default and test, the resulting lib dir could look like this:
<pre>
lib<br class="xooki-br"/>  default<br class="xooki-br"/>    commons-lang.jar<br class="xooki-br"/>    commons-logging.jar<br class="xooki-br"/>  test<br class="xooki-br"/>    junit.jar
</pre>
And now suppose commons-logging is no longer part of the dependencies of the default configuration, then a new call to retrieve will result in:
<pre>
lib<br class="xooki-br"/>  default<br class="xooki-br"/>    commons-lang.jar<br class="xooki-br"/>  test<br class="xooki-br"/>    junit.jar
</pre>
With no synchronisation, commons-logging would not have been removed by the call.<br class="xooki-br"/><br class="xooki-br"/><hr/>
<pre>
&lt;ivy:retrieve pattern="${lib.dir}/[type]/[artifact]-[revision].[ext]" conf="runtime"/&gt;
</pre>
Retrieves only the dependencies of the <pre>runtime</pre> configuration in directories named by artifact type. The resulting lib dir could look like this:
<pre>
lib<br class="xooki-br"/>  jar<br class="xooki-br"/>    commons-lang-1.0.jar<br class="xooki-br"/>    looks-1.1.jar<br class="xooki-br"/>  source<br class="xooki-br"/>    looks-1.1.zip
</pre>

<hr/>
<pre>
&lt;ivy:retrieve pattern="${lib.dir}/[organisation]/[artifact]-[revision].[ext]" /&gt;
</pre>
Retrieves all dependencies of the last resolve call to a lib directory. The [organisation] token will get the unmodified organisation value. The resulting lib dir could look like this:
<pre>
lib<br class="xooki-br"/>  org.apache<br class="xooki-br"/>    commons-lang-1.0.jar<br class="xooki-br"/>  org.junit<br class="xooki-br"/>    junit-4.1.jar<br class="xooki-br"/>    junit-4.1.zip
</pre>

<pre>
&lt;ivy:retrieve pattern="${lib.dir}/[orgPath]/[artifact]-[revision].[ext]" /&gt;
</pre>
Retrieves all dependencies of the last resolve call to a lib directory. The [orgPath] token will get a tree structure. The resulting lib dir could look like this:
<pre>
lib<br class="xooki-br"/>  org<br class="xooki-br"/>    apache<br class="xooki-br"/>      commons-lang-1.0.jar<br class="xooki-br"/>    junit<br class="xooki-br"/>      junit-4.1.jar<br class="xooki-br"/>      junit-4.1.zip
</pre>

<hr/>
<pre>
&lt;ivy:retrieve organisation="foo" module="bar" inline="true" pattern="${my.install.dir}/[artifact].[ext]"/&gt;
</pre>
Resolves and retrieve the latest version of the module bar and its dependencies in the directory pointed by ${my.install.dir}.<br class="xooki-br"/><hr/>
<pre>
&lt;ivy:retrieve pattern="lib/[artifact]-[revision].[ext]"&gt;<br class="xooki-br"/>    &lt;firstmatchmapper&gt;<br class="xooki-br"/>        &lt;globmapper from="lib/*-SNAPSHOT.jar" to="lib/snapshots/*-SNAPSHOT.jar" /&gt;<br class="xooki-br"/>        &lt;globmapper from="lib/*" to="lib/releases/*"/&gt;<br class="xooki-br"/>    &lt;/firstmatchmapper&gt;<br class="xooki-br"/>&lt;/ivy:retrieve&gt;
</pre>
Retrieves all dependencies of the last resolve call to a lib directory. The jar files with a version equal to 'SNAPSHOT' are retrieved in a 'snapshots' directory. The other ones are retrieved in a 'releases' directory.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>report</div><br class="xooki-br"/>Generates reports of dependency resolving. One report per configuration is generated, but all reports generated together are hyperlinked one to each other.<br class="xooki-br"/><br class="xooki-br"/>This task should be used only after a call to resolve, even if the call was not done during the same ant build.<br class="xooki-br"/>In fact, this task uses xml report generated by resolve in cache. So if you call resolve on a module for a given configuration, you can call report safely on this module and this configuration as long as you do not clean your ivy cache.<br class="xooki-br"/><br class="xooki-br"/>If you want to have an idea of what reports look like, check this very simple <a href="../samples/jayasoft-ivyrep-example-default.html">example</a>.<br class="xooki-br"/>The task also generates a graphml file which can be loaded with the free <a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> graph editor.<br class="xooki-br"/>Then following a few <a href="../yed.html">simple steps</a> you can obtain a graph like this <a href="../samples/jayasoft-ivyrep-example-default.jpg">one</a>.<br class="xooki-br"/>
<div class="since">since 1.4</div> If a custom XSL is specified, it's possible to specify additional parameters to the stylesheet.<br class="xooki-br"/>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>todir</td><td>the directory to which reports should be generated</td>
        <td>No, defaults to ${ivy.report.todir}, or execution directory if not defined</td></tr>
    <tr><td>outputpattern</td><td>the generated report names pattern</td>
        <td>No, defaults to ${ivy.report.output.pattern}, or [organisation]-[module]-[conf].[ext] if not defined</td></tr>
    <tr><td>xsl</td><td>true to generate a report (by default html report) using xslt, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to true</td></tr>
    <tr><td>xml</td><td>true to generate a xml report, false otherwise <span class="since">since 1.3</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>graph</td><td>true to generate graphml files, false otherwise</td>
        <td>No, defaults to true</td></tr>
    <tr><td>dot</td><td>true to generate <a href="http://www.graphviz.org/">graphviz dot</a> files, false otherwise <span class="since">since 1.4</span></td>
        <td>No, defaults to false</td></tr>
    <tr><td>conf</td><td>a comma separated list of the configurations for which a report should be generated</td>
        <td>No. Defaults to the configurations resolved by the last resolve call (during same ant build), or ${ivy.resolved.configurations} if no resolve was called</td></tr>
    <tr><td>organisation</td><td>the name of the organisation of the module for which report should be generated</td>
        <td>No, unless resolveId has not been specified and no resolve was called during the build. Defaults to last resolved module organisation.</td></tr>
    <tr><td>module</td><td>the name of the module for which report should be generated</td>
        <td>No, unless resolveId has not been specified and no resolve was called during the build. Defaults to last resolved module.</td></tr>
    <tr><td>validate</td><td>true to force ivy files validation against ivy.xsd, false to force no validation</td>
        <td>No. Defaults to default ivy value (as configured in configuration file)</td></tr>
    <tr><td>xslfile</td><td>indicates which xsl file should be used to generate the report</td>
        <td>No, defaults to ivy provided xsl which generates html report</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr>
    <tr><td>resolveId</td><td>The id which was used for a previous resolve <span class="since">(since 2.0)</span></td><td>No, defaults to '[org]-[module]'.</td></tr>
</tbody>
</table>

<h1>Examples</h1>
To generate a HTML and graphml report:
<pre>
&lt;report conf="compile" /&gt;
</pre>

<hr/>
To generate a HTML report only:
<pre>
&lt;report conf="compile" graph="false" /&gt;
</pre>

<hr/>
To generate an XML report using a custom stylesheet:
<pre>
&lt;report conf="compile" xslfile="my-custom-stylesheet.xsl" xslext="xml" /&gt;
</pre>

To generate an XML report using a custom stylesheet which needs some parameters:
<pre>
&lt;report conf="compile" xslfile="my-custom-stylesheet.xsl" xslext="xml"&gt;<br class="xooki-br"/>    &lt;param name="param1" expression="value1" /&gt; <br class="xooki-br"/>    &lt;param name="param2" expression="value2" /&gt; <br class="xooki-br"/>&lt;/report&gt;
</pre>

	<hr/><div class='toc-title toc-title-5'>Using yEd to layout report graphs</div><br class="xooki-br"/><a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> is a free graph editor, benefiting from<br class="xooki-br"/>all the automatic layouts of yFiles. Ivy is able to generate graphs which are readable by yEd.<br class="xooki-br"/><br class="xooki-br"/>The graphs generated by ivy are not layed out (in fact it's why we use yEd), so you have to follow a simple sequence of steps to layout the generated graphs.<br class="xooki-br"/><br class="xooki-br"/><h2>Preparation</h2>
First you have to generate a graphml file. Simply call the report task (see ivy use documentation) for that.<br class="xooki-br"/><br class="xooki-br"/><h2>Step 1: open the graphml file</h2>
Launch yEd editor, and open the graphml file generated by the report task. You should obtain something like this:<br class="xooki-br"/><center>
<img src="images/yed-step1.jpg"/><br/>
</center>

<h2>Step 2: ask yEd to adjust nodes size</h2>
<center>
<img src="images/yed-step2.jpg"/><br/>
<img src="images/yed-step3.jpg"/><br/>
<img src="images/yed-step3-2.jpg"/><br/>
</center>

<h2>Step 3: ask yEd to layout nodes</h2>
<center>
<img src="images/yed-step4.jpg"/><br/>
<img src="images/yed-step5.jpg"/><br/>
<img src="images/yed-step6.jpg"/><br/>

That's all, you should have obtained something like this:<br class="xooki-br"/><br class="xooki-br"/><img src="images/yed-step7.jpg"/><br/>

Note that this is only one possibility, test the available layouts yourself, you could find one better in your case.<br class="xooki-br"/>Once you have layed out the graph, you can either save it with in the same file (but be warned that it will be overwritten at next ivy report call), or another file, export it to jpg, gif, svg, etc. (see <a href="http://www.yworks.com/en/products_yed_about.htm">yEd</a> site for details).<br class="xooki-br"/></center>


	<hr/><div class='toc-title toc-title-4'>settings</div><br class="xooki-br"/><span class="since">(since 2.0)</span>

The settings declaration is used to configure ivy with an xml settings file. The difference with the <a href="use/configure.html">configure</a> task is that when using the settings declaration, the configuration of Ivy will be done when the settings are first needed (for instance when you do a resolve), while the configure task will perform a configuration of Ivy instantly, which makes it easier to see the problem if something goes wrong.<br class="xooki-br"/><br class="xooki-br"/>See <a href="settings.html">Settings Files</a> for details about the settings file itself.<br/><br/>

Multiple settings can be defined in a build script. Every task can reference its own settings.<br class="xooki-br"/><br class="xooki-br"/>All Ivy variables set during the settings are available in the Ant project as long as they were not set in Ant before (Ant properties are immutable). <br class="xooki-br"/>Moreover, the variables are exposed under two names: the variable name, and the variable name suffixed by dot + the settings id. <br class="xooki-br"/>For instance, if you load a settings with the id 'myid', and define a variable my.variable=my.value in the Ivy settings, both my.variable and my.variable.myid will now be available as properties in Ant and equal to 'my.value'. If you later load another settings with the id 'yourid', and in this settings assign the variable 'my.variable' the value 'your.value', in the Ant project you will have:
<pre>
my.variable=my.value<br class="xooki-br"/>my.variable.myid=my.value<br class="xooki-br"/>my.variable.yourid=your.value
</pre>

<h2>Attributes</h2>
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>id</td><td>The settings id useable in the settingsRef attributes of the ivy task that needs a setting.  Note that the ivy tasks will search by default for the settings with the id "ivy.instance", which is the default value.</td><td>No, defaults to "ivy.instance"</td></tr>
    <tr><td>file</td><td>path to the settings file to use</td>
        <td rowspan="2">No. If a file is provided, url is ignored. If none are provided, then it attempts to find a file at ${ivy.settings.file}, and if this file does not exist, it uses a <a href="tutorial/defaultconf.html">default settings file</a></td></tr>
    <tr><td>url</td><td>url of the settings file to use</td></tr>
    <tr><td>host</td><td>http authentication host</td><td rowspan="4">No, unless authentication is required</td></tr>
    <tr><td>realm</td><td>http authentication realm</td></tr>
    <tr><td>username</td><td>http authentication user name</td></tr>
    <tr><td>passwd</td><td>http authentication password</td></tr>
</tbody>
</table>
<h2>HTTP Authentication</h2>
<i>Note: HTTP Authentication can be used only if <a href="http://jakarta.apache.org/commons/httpclient/">commons-httpclient.jar</a> is in your classpath</i><br class="xooki-br"/>If any of the url you use in ivy (especially in dependency resolvers) need http<br class="xooki-br"/>authentication, then you have to provide the host, realm, username and passwd<br class="xooki-br"/>attributes of the configure task. These settings will then be used in any<br class="xooki-br"/>further call to ivy tasks.<br/><br/>

<h2>Multiple classloader</h2>
A special attention should be applied when you have a multi-project build with <i>subant</i> call, using ivy task loaded by a <i>typedef</i>.  Indeed in this situation, it is possible to pass settings reference to a subbuild.  When you do that, you should take of the classloader.  The ivy task of your subant should not be defined in a different classloader than the parent one.  This can be achieved by using the <i>loader</i> parameter of the antlib declaration, or avoid to reload the ivy antlib in the subbuild (place the taskdef in a target only executed when the antlib is not yet loaded).<br/><br/>


<h2>Examples</h2>
<h3>Simplest settings</h3>
<pre>&lt;ivy:settings /&gt;</pre>
Use either ${ivy.settings.file} if it exists, or the <a href="../samples/ivysettings-default.xml">default settings file</a><br>
This simplest setting is implicit.<br class="xooki-br"/><h3>Configure with a file</h3>
<pre>&lt;ivy:settings file="mysettings.xml" /&gt;</pre>
<h3>Configure with an url</h3>
<pre>&lt;ivy:settings url="<a href="http://mysite.com/mysettings.xml">http://mysite.com/mysettings.xml</a>" /&gt;</pre>
<h3>Configure multiple realms which require autentication</h3>
<pre>
&lt;ivy:settings file="path/to/my/ivysettings.xml"&gt;<br class="xooki-br"/>  &lt;credentials host="myhost.com" realm="My Realm" username="myuser" passwd="mypasswd" /&gt;<br class="xooki-br"/>  &lt;credentials host="yourhost.com" realm="Your Realm" username="myuser" passwd="myotherpasswd" /&gt;<br class="xooki-br"/>&lt;/ivy:settings&gt; 
</pre>
<h3>Configure 2 different settings</h3>
You can use multiple ivy settings during a build. Then every ivy task should specify the settings it uses using the settingsRef attribute.
<pre>
 &lt;ivy:settings id="ivy.normal.settings" file="normal_settings.xml" /&gt;<br class="xooki-br"/> &lt;ivy:settings id="ivy.release.settings" file="release_settings.xml" /&gt;<br class="xooki-br"/><br class="xooki-br"/> &lt;ivy:resolve settingsRef="ivy.normal.settings" /&gt;<br class="xooki-br"/> &lt;ivy:resolve settingsRef="ivy.release.settings" /&gt;
</pre>
<hr/><div class='toc-title toc-title-4'>var</div><br class="xooki-br"/>Sets a variable (by name and value), or set of variables (from file or url) in ivy. <br/>
Variables are case sensitive.<br/><br/>
Contrary to ant properties, ivy variables are mutable. But a problem with this is that you do not control when <br class="xooki-br"/>variables are substituted, and usually it is done as soon as possible. So changing the value of a variable will<br class="xooki-br"/>have no effect if it has already been substituted. Consequently, <b>using this task is NOT recommended</b>.<br class="xooki-br"/>See <a href="../reference.html">reference</a> page for details about ivy variables.<br class="xooki-br"/><br/><br/>
  
<table class="ant">
<thead>
    <tr><th class="ant-att">Attribute</th><th class="ant-desc">Description</th><th class="ant-req">Required</th></tr>
</thead>
<tbody>
    <tr><td>name</td><td>the name of the variable to set</td>
        <td>No</td></tr>
    <tr><td>value</td><td>the value of the variable to set</td>
        <td>Yes when using the name attribute</td></tr>
    <tr><td>file</td><td>the filename of the property file to load as ivy variables</td>
        <td rowspan="2">One of these, when <b>not</b> using the name attribute</td></tr>
    <tr><td>url</td><td>the url from which to read ivy variables</td></tr>
    <tr><td>prefix</td><td>Prefix to apply to variables. A "." is appended to the prefix if not specified.</td>
        <td>No</td></tr>
    <tr><td>settingsRef</td><td>A reference to the ivy settings that must be used by this task <span class="since">(since 2.0)</span></td><td>No, 'ivy.instance' is taken by default.</td></tr>
</tbody>
</table>

	<hr/><div class='toc-title toc-title-3'>Using standalone</div><br class="xooki-br"/>Ivy can be used as a standalone program very easily. All you need is a java 1.4+ runtime environment (JRE)!<br class="xooki-br"/><br class="xooki-br"/>Then here is how to call it:
<pre>
java -jar ivy.jar -?
</pre>
It will display an online help like this:
<pre>
==== settings options<br class="xooki-br"/> -settings &lt;settingsfile&gt;     use given file for settings<br class="xooki-br"/> -cache &lt;cachedir&gt;            use given directory for cache<br class="xooki-br"/> -novalidate                  do not validate ivy files against xsd<br class="xooki-br"/> -m2compatible                use maven2 compatibility<br class="xooki-br"/><br class="xooki-br"/>==== resolve options<br class="xooki-br"/> -ivy &lt;ivyfile&gt;               use given file as ivy file<br class="xooki-br"/> -dependency &lt;organisation&gt; &lt;module&gt; &lt;revision&gt;<br class="xooki-br"/>                              use this instead of ivy file to do the rest of the<br class="xooki-br"/>                               work with this as a dependency.<br class="xooki-br"/> -confs &lt;configurations&gt;      resolve given configurations<br class="xooki-br"/><br class="xooki-br"/>==== retrieve options<br class="xooki-br"/> -retrieve &lt;retrievepattern&gt;  use given pattern as retrieve pattern<br class="xooki-br"/> -sync                        use sync mode for retrieve<br class="xooki-br"/><br class="xooki-br"/>==== cache path options<br class="xooki-br"/> -cachepath &lt;cachepathfile&gt;   outputs a classpath consisting of all dependencies<br class="xooki-br"/>                               in cache (including transitive ones) of the given<br class="xooki-br"/>                               ivy file to the given cachepathfile<br class="xooki-br"/><br class="xooki-br"/>==== deliver options<br class="xooki-br"/> -deliverto &lt;ivypattern&gt;      use given pattern as resolved ivy file pattern<br class="xooki-br"/><br class="xooki-br"/>==== publish options<br class="xooki-br"/> -publish &lt;resolvername&gt;      use given resolver to publish to<br class="xooki-br"/> -publishpattern &lt;artpattern&gt; use given pattern to find artifacts to publish<br class="xooki-br"/> -revision &lt;revision&gt;         use given revision to publish the module<br class="xooki-br"/> -status &lt;status&gt;             use given status to publish the module<br class="xooki-br"/><br class="xooki-br"/>==== http auth options<br class="xooki-br"/> -realm &lt;realm&gt;               use given realm for HTTP AUTH<br class="xooki-br"/> -host &lt;host&gt;                 use given host for HTTP AUTH<br class="xooki-br"/> -username &lt;username&gt;         use given username for HTTP AUTH<br class="xooki-br"/> -passwd &lt;passwd&gt;             use given password for HTTP AUTH<br class="xooki-br"/><br class="xooki-br"/>==== launcher options<br class="xooki-br"/> -main &lt;main&gt;                 the FQCN of the main class to launch<br class="xooki-br"/> -args &lt;args&gt;                 the arguments to give to the launched process<br class="xooki-br"/> -cp &lt;cp&gt;                     extra classpath to use when launching process<br class="xooki-br"/><br class="xooki-br"/>==== message options<br class="xooki-br"/> -debug                       set message level to debug<br class="xooki-br"/> -verbose                     set message level to verbose<br class="xooki-br"/> -warn                        set message level to warn<br class="xooki-br"/> -error                       set message level to error<br class="xooki-br"/><br class="xooki-br"/>==== help options<br class="xooki-br"/> -?                           display this help<br class="xooki-br"/> -deprecated                  show deprecated options
</pre> 

<span class="since">since 1.3</span> System properties are included as ivy variables, so you can easily define an ivy variable like this:
<pre>
java -Dmyivyvar=myvalue org.apache.ivy.Main [parameters]
</pre>


<h1>Examples</h1>
<pre>
java -jar ivy.jar
</pre>
calls ivy with default configuration using ivy.xml in the current dir<br class="xooki-br"/><hr/>
<pre>
java -jar ivy.jar -settings path/to/myivysettings.xml -ivy path/to/myivy.xml
</pre>
calls ivy with given ivysettings file using given ivy file<br class="xooki-br"/><hr/>
<span class="since">since 1.3</span>
<pre>
java -jar ivy.jar -settings path/to/myivysettings.xml -dependency apache commons-lang 2.0
</pre>
calls ivy with given ivysettings file and resolve apache commons-lang 2.0. <br class="xooki-br"/><br class="xooki-br"/>This is equivalent to:
<pre>
java -jar ivy.jar -settings path/to/myivysettings.xml -ivy ivy.xml
</pre>
with ivy.xml like this:
<pre>
&lt;ivy-module version="1.0"&gt;<br class="xooki-br"/>  &lt;info organisation="org"<br class="xooki-br"/>       module="standalone"<br class="xooki-br"/>       revision="working"<br class="xooki-br"/>   /&gt;<br class="xooki-br"/>  &lt;dependencies&gt;<br class="xooki-br"/>    &lt;dependency org="apache" name="commons-lang" rev="2.0" conf="default-&gt;*"/&gt;<br class="xooki-br"/>  &lt;/dependencies&gt;<br class="xooki-br"/>&lt;/ivy-module&gt;
</pre>
<hr/>
<span class="since">since 1.3</span>
<pre>
java -jar ivy.jar -settings path/to/myivysettings.xml -ivy path/to/myivy.xml -cachepath mycachefile.txt
</pre>
calls ivy with given ivysettings file and resolve the dependencies found in the given ivy file, and then output the classpath of resolved artifacts in cache in a file. This file can then be used to define a classpath corresponding to all the resolved dependencies for any java program. <br class="xooki-br"/><br class="xooki-br"/><hr/>
<span class="since">since 1.4</span>
<pre>
java -jar ivy.jar -settings path/to/myivysettings.xml -dependency bar foo 2.0 -main org.bar.foo.FooMain
</pre>
calls ivy with given ivysettings file and resolve bar foo 2.0, and then run org.foo.FooMain class with the resolved artifacts as classpath<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-3'>OSGi</div><br class="xooki-br"/><br class="xooki-br"/>Since Apache Ivy&#153; 2.3, some support for OSGi&#153; dependency management has been introduced.<br class="xooki-br"/>
<table class="notice">
  <tr>
    <td style="vertical-align: top"><img src="images/warning.png" style="float:left;" /></td>
    <td>
    Note that this feature is considered as <b>experimental</b>. It should work with simple configuration but may not in complex ones. If you have any issue with that feature, you are welcomed to come discussed your use case on the <a href="http://ant.apache.org/ivy/mailing-lists.html">ivy-user</a> mailing list, or discuss about implementation issues or improvement you may have found on <a href="http://ant.apache.org/ivy/mailing-lists.html">ant-dev</a>.<br class="xooki-br"/>    </td>
  </tr>
</table>

So with a standard ivy.xml, you can express some dependency on some OSGi bundle and every of their trasitive dependencies will be resolved. You can also declare in your ivy.xml some OSGi dependency, like a <tt>Require-Bundle</tt>, an <tt>Import-Package</tt> or an <tt>Import-Service</tt>, miming an OSGi MANIFEST.MF.<br class="xooki-br"/><br class="xooki-br"/><h2>Note on the implementation</h2>

With OSGi we can declare different kind of capabilites of a bundle which can match different kind of requirements of some other bundles (<tt>Require-Bundle</tt>/<tt>Bundle-SymbolicName</tt>, <tt>Import-Package</tt>/<tt>Export-Package</tt>, <tt>Import-Service</tt>/<tt>Export-Service</tt>). In Ivy we only have one kind of requirement and one kind of capability: the symbolic name of the bundle. Due to that restriction Ivy may not resolve exactly how we would expect with OSGi.  The runtime of Ivy won't be as smart as a pure OSGi dependency manager. But we think that the mapping is working for most of the use cases involing OSGi dependencies management.<br class="xooki-br"/><br class="xooki-br"/>Details on the mapping of the OSGi dependency model into Ivy's one can be found in that <a href="osgi/osgi-mapping.html">page</a>.<br class="xooki-br"/><br class="xooki-br"/><h2>Repository descriptor based resolvers</h2>

Since the nature of the OSGi dependencies, resolving against a repository cannot be started before acquiring the metadata of every bundle of the repository. To resolve an <tt>Import-Package</tt>, Ivy has to find every bundle which has the proper <tt>Export-Package</tt>. So unlike the usual Ivy resolvers, the OSGi capable ones have to get the descriptor before starting a resolve.<br class="xooki-br"/><br class="xooki-br"/>The descriptor probably being not instantanly downloaded, the descriptor is put in cache. (FIXME not implemented)<br class="xooki-br"/><br class="xooki-br"/><h2>Use cases</h2>

Here are different use case of using the OSGi capabilities of Ivy:
<ul>
    <li><a href="osgi/eclipse-plugin.html">building an Eclipse&#153; plugin</a></li>
    <li><a href="osgi/standard-osgi.html">building a standard OSGi bundle</a></li>
    <li><a href="osgi/target-platform.html">managing a "target" platform</a></li>
</ul>

	<hr/><div class='toc-title toc-title-4'>OSGi mapping</div><br class="xooki-br"/><br class="xooki-br"/>This page is a description of how OSGi&#153; dependencies are mapped into Apache Ivy&#153; ones<br class="xooki-br"/><br class="xooki-br"/><u>Goal:</u> the purpose of this mapping is to transform an OSGi manifest into an ivy.xml, so Ivy can understand OSGi bundles and resolve them. We don't want to do the reverse here.<br class="xooki-br"/><br class="xooki-br"/><h2>Bundle Symbolic name / Ivy organisation and module</h2>

In OSGi a bundle is identified by its symbolic name. In Ivy there is a notion of organisation and module name.<br class="xooki-br"/><br class="xooki-br"/>The choosen mapping is:
<ul>
<li>The organisation is "bundle" (transitive dependencies like pakages or services have their own organisations, "package" and "service")</li>
<li>The module name is the symbolic name</li>
</ul>

<table border="1" cellspacing="1" cellpadding="4">
<tr>
<td> <b>OSGi</b> </td>
<td> <b>Ivy</b> </td>
</tr>
<tr>
<td> <tt>Bundle-SymbolicName: com.acme.product.plugin</tt> </td>
<td>
<pre>
&lt;info organisation="bundle" module="com.acme.product.plugin" /&gt;
</pre>
</td>
</tr>
</table>

<h2>Version and version range</h2>

The OSGi specification is defining a version as a composition of 3 numbers and an arbitrary qualifier. This fit well into the lazy definition of Ivy. We will just have to use a special latest strategy in Ivy.<br class="xooki-br"/><br class="xooki-br"/>Then about version range, Ivy will understand correctly fully defined range as <tt>[1.2.3,1.4.9)</tt> or <tt>(1.2.3,1.4.9]</tt>. But for OSGi version range defined as in <tt>1.2.3</tt>, it has to be transformed into <tt>[1.2.3,)</tt>

<table border="1" cellspacing="1" cellpadding="4">
<tr>
<td> <b>OSGi</b> </td>
<td> <b>Ivy</b> </td>
</tr>
<tr>
<td> <tt>Bundle-Version: 3.3.3</tt> </td>
<td> <tt>revision="3.3.3"</tt> </td>
</tr>
<tr>
<td><tt>Require-Bundle: com.acme.product.plugin;bundle-version="3.2.1"</tt> </td>
<td>
<pre>
&lt;dependency org="bundle" name="com.acme.product.plugin" rev="[3.2.1,)" /&gt;
</pre>
</td>
</tr>
</table>

<h2>Ivy configurations</h2>

The Ivy configuration is a notion that doesn't exist explicitely in OSGi, but some notion of the latter can be expressed with that configurations.<br class="xooki-br"/><br class="xooki-br"/>First the mapping is defining three configurations:
<ul>
<li><tt>default</tt> : it will contain every required dependency (transitively)</li>
<li><tt>optional</tt> : it will contain every optional dependency and every required depedency the the first degree dependencies.</li>
<li><tt>transitive-optional</tt> : it will contain every optional dependency (optional transitively)</li>
</ul>

Then there will be some configurations used for the <tt>use</tt> parameter of the <tt>Import-Package</tt> OSGi manifest header. All of these kinds of configuration have their names starting with "use_". See in the next section.<br class="xooki-br"/><br class="xooki-br"/><h2>OSGi capabilities</h2>

Generally speaking, declaring capabilities in an ivy.xml is useless (in the scope of this mapping which is to transform an OSGi manifest into an ivy.xml and not the reverse). In the resolve process we want to find the bundle which have the capability matching the expected requirement. In Ivy, if we are about to get the ivy.xml of a module, we are getting the bundle so we already have reached the requirement.<br class="xooki-br"/><br class="xooki-br"/>So OSGi capabilities of bundles in a repo will be gathered direclty from the manifests to passed directly to the Ivy resolver, no need to express them into ivy.xml, except for the Export-Package, see the next section.<br class="xooki-br"/><br class="xooki-br"/><h3>Export-Package</h3>

Exported package are declaring capabilities of the bundle in term of package. But they also declare dependencies between the declared package via the parameter <tt>use</tt>. These dependencies have to be declared in the ivy.xml. And we will use Ivy configurations for that.<br class="xooki-br"/><br class="xooki-br"/>First, each exported package will be declared in the ivy.xml as a configuration. The name of the configuration will start will <tt>use_</tt> and will finished with the name of that package.<br class="xooki-br"/><br class="xooki-br"/>Then each time an exported package is declared to use some other one, it will be mapped as a dependency between the Ivy configurations coresponding to those packages. <br class="xooki-br"/>
<table border="1" cellspacing="1" cellpadding="4">
<tr>
<td> <b>OSGi</b> </td>
<td> <b>Ivy</b> </td>
</tr>
<tr>
<td> <tt>Export-Package: com.acme.product.plugin.utils</tt> </td>
<td>
<pre>
&lt;configuration name="use_com.acme.product.plugin.utils" extends="default" /&gt;
</pre>
</td>
</tr>
<tr>
<td> <tt>Export-Package: com.acme.product.plugin.utils,com.acme.product.plugin.common;use:=com.acme.product.plugin.utils</tt> </td> <td>
<pre>
&lt;configuration name="use_com.acme.product.plugin.utils" extends="default" /&gt;<br class="xooki-br"/>&lt;configuration name="use_com.acme.product.plugin.common" extends="default,use_com.acme.product.plugin.utils" /&gt;
</pre> 
</td>
</tr>
</table>

<h2>OSGi Requirements / Ivy dependencies</h2>

In OSGi there are different kind of dependencies, which is an OSGi bundle repository documentation is called a "requirement". The problem is that Ivy is understanding only one kind of requirement, so we use here some extra attribute to declare those different kind of dependency.<br class="xooki-br"/><br class="xooki-br"/><h3>Require-Bundle</h3>

The OSGi <tt>Require-Bundle</tt> is some a requirement directly on a specific bundle. Ivy does it too. So we just use the <tt>osgi="bundle"</tt> extra attribute.<br class="xooki-br"/><br class="xooki-br"/>If there is the OSGi <tt>resolution</tt> parameter specified to <tt>optional</tt>, then the dependency will be declared in the configuration <tt>optional</tt> and <tt>transitive-optional</tt>. Otherwise it will be declared in the <tt>default</tt> configuration.<br class="xooki-br"/>
<table border="1" cellspacing="1" cellpadding="4">
<tr>
<td> <b>OSGi</b> </td>
<td> <b>Ivy</b> </td>
</tr>
<tr>
<td> <tt>Require-Bundle: com.acme.product.plugin;bundle-version="3.2.1"</tt> 
</td>
<td>
<pre>
&lt;dependency osgi="bundle" org="" name="com.acme.product.plugin" rev="[3.2.1,)" conf="default-&gt;default" /&gt;
</pre>
</td>
</tr>
<tr>
<td> <tt>Require-Bundle: com.acme.product.plugin;bundle-version="3.2.1";resolution:="optional"</tt> </td>
<td>
<pre>
&lt;dependency org="bundle" name="com.acme.product.plugin" rev="[3.2.1,)" conf="optional-&gt;default;transitive-optional-&gt;transitive-optional" /&gt;
</pre>
</td>
</tr>
</table>

<h3>Import-Package</h3>

The OSGi <tt>Import-Package</tt> is some a requirement on a package of a bundle. Ivy has no notion of package. So we will use the <tt>osgi="pkg"</tt> extra attribute.<br class="xooki-br"/><br class="xooki-br"/>If there is the OSGi <tt>resolution</tt> parameter specified to <tt>optional</tt>, then the dependency will be declared in the configuration <tt>optional</tt> and <tt>transitive-optional</tt>. Otherwise it will be declared in the <tt>default</tt> configuration.<br class="xooki-br"/><br class="xooki-br"/>As it is an import package the configuration of the dependency will be the <tt>use_XXX</tt> one. So that transitive dependency via the use parameter will be respected in the dependency.<br class="xooki-br"/>
<table border="1" cellspacing="1" cellpadding="4">
<tr>
<td> <b>OSGi</b> </td>
<td> <b>Ivy</b> </td>
</tr>
<tr>
<td> <tt>Import-Package: com.acme.product.plugin.utils;version="3.2.1"</tt> 
</td>
<td>
<pre>
&lt;dependency org="package" name="com.acme.product.plugin.utils" rev="[3.2.1,)" conf="default-&gt;default;use_com.acme.product.plugin.utils-&gt;use_com.acme.product.plugin.utils" /&gt;
</pre>
</td>
</tr>
<tr>
<td> <tt>Import-Package: com.acme.product.plugin.utils;version="3.2.1";resolution:="optional"</tt> </td>
<td>
 <pre>
&lt;dependency org="package" name="com.acme.product.plugin.utils" rev="[3.2.1,)" conf="optional-&gt;default;transitive-optional-&gt;transitive-optional;use_com.acme.product.plugin.utils-&gt;use_com.acme.product.plugin.utils" /&gt;
</pre>
</td>
</tr>
</table>

<h2>Execution environment</h2>

The OSGi <tt>Bundle-RequiredExecutionEnvironment</tt> manifest attribute is specifing is which environment the bundle is expected to run. In our problematic of dependency management it means that some of the transitive dependencies won't be resolved within the OSGi space but will be provided by the JRE. So we have to exclude from the dependency tree every requirement that will be provided by the environment. Basically it will be about excluding the packaged declared in the JRE.<br class="xooki-br"/>
<table border="1" cellspacing="1" cellpadding="4">
<tr>
<td> <b>OSGi</b> </td>
<td> <b>Ivy</b> </td>
</tr>
<tr>
<td> <tt>Bundle-RequiredExecutionEnvironment: JavaSE-1.6</tt> </td>
<td>
<pre>
&lt;dependencies&gt;<br class="xooki-br"/>    &lt;exclude org="package" module="javax.accessibility" /&gt;<br class="xooki-br"/>    &lt;exclude org="package" module="javax.activation" /&gt;<br class="xooki-br"/>    &lt;exclude org="package" module="javax.activity" /&gt;<br class="xooki-br"/>    ...<br class="xooki-br"/>&lt;/dependencies&gt;
</pre>
</td>
</tr>
</table>

<h2>Bundle Fragment</h2>

Ivy doesn't support the header <tt>Fragment-Host</tt>.<br class="xooki-br"/><br class="xooki-br"/>The work around is to manually specify as dependencies in the ivy.xml the bundles which would fit to be the extensions of the host bundle.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>Building an Eclipse plugin</div><br class="xooki-br"/>
<table class="notice">
  <tr>
    <td style="vertical-align: top"><img src="images/warning.png" style="float:left;" /></td>
    <td>
    Note that this feature is considered as <b>experimental</b>. It should work with simple configuration but may not in complex ones. If you have any issue with that feature, you are welcomed to come discussed your use case on the <a href="http://ant.apache.org/ivy/mailing-lists.html">ivy-user</a> mailing list, or discuss about implementation issues or improvement you may have found on <a href="http://ant.apache.org/ivy/mailing-lists.html">ant-dev</a>.<br class="xooki-br"/>    </td>
  </tr>
</table>

This page describes how to build an Eclipse&#153; plugin with Apache Ivy&#153; and its OSGi&#153; capabilities.<br class="xooki-br"/><br class="xooki-br"/><h1>Quick setup</h1>

In few steps, we will setup a build to compile and package an Eclipse plugin.<br class="xooki-br"/><br class="xooki-br"/><ol>
<li>download this <a href="../samples/eclipse-plugin/ivy.xml">ivy.xml<a>, this <a href="../samples/eclipse-plugin/ivysettings.xml">ivysettings.xml</a>, this <a href="../samples/eclipse-plugin/ivysettings.properties">ivysettings.properties</a>, this <a href="../samples/eclipse-plugin/build.xml">build.xml</a>, and put them into your plugin folder;</li>
<li>in the ivysettings.properties, specify the location of the plugins folder of your Eclipse target;</li>
<li>in the ivy.xml, change the symbolic name declared in the extends element;</li>
<li><i>(optional)</i> by default the build.xml is expecting the sources to be in the <tt>src</tt> folder. You may want to edit it if it is not the case</li>
<li><i>(optional)</i> if Ivy is not in Ant's classpath, get the jar of <a href="../download.html">Apache Ivy</a> and edit the build.xml accordingly (see the comments at the begining of the file)</li>
</ol>

And that's it ! Now let's use it.<br class="xooki-br"/><br class="xooki-br"/>First, Ivy needs to aggregate the OSGi metadata of the target platform. To do so just launch:
<pre>ant buildobr</pre>
You need to run that command only once. Or each time your target platform get modified.<br class="xooki-br"/><br class="xooki-br"/>Then to resolve and build, just run:
<pre>ant build</pre>

<h2>Eclipse setup</h2>

You probably have already configured your project in Eclipse via the PDE. Let's see how to chnage that and use <a href="http://ant.apache.org/ivy/ivyde/">Apache IvyDE</a>.<br class="xooki-br"/><br class="xooki-br"/><ol>
<li>so first remove from your project's classpath the PDE dependencies container;</li>
<li>then right click on the ivy.xml you just added and select "Add Ivy library";</li>
<li>in the configuration panel of the IvyDE classpath container, as the settings file put '${workspace_loc:mypluginproject/ivysettings.xml}';</li>
<li>click finish and your Eclipse project should build now.</li>
</ol>

Nota Bene: to be resolved correctly Ivy is relying on the aggregated metadata of your target platform. Even if you want to only build with Eclipse, you will have to run the command <tt>ant obrindex</tt> at least one time.<br class="xooki-br"/><br class="xooki-br"/><h1>Details on the setup</h1>

<h2>The repository</h2>

When building an Eclipse plugin, we are relying on a "target platform", the Eclipse installation we want our plugin to be eventually installed into. For Ivy, this will represent the repository of artifacts.<br class="xooki-br"/><br class="xooki-br"/>Ivy needs an aggragation of the OSGi metadata in order to resolve a such repository. The Ant task <a href="../use/buildobr.html">buildobr</a> build a OBR (OSGi Bundle Repository) descriptor file from a set of OSGi bundles. So here we are using this Ant task to gather OSGi metadata from the Eclipse plugins in the "target platform". In the above exemple, the file is build in <tt>target/repo-eclipse.xml</tt>.<br class="xooki-br"/><br class="xooki-br"/>The plugin to be build has then a ivy.xml file describing its depedencies to be used by Ivy. Since the actual depedencies are in the MANIFEST.MF file, in the ivy.xml file we specify that it extends <tt>META-INF/MANIFEST.MF</tt>. So there not much dependencies specified in the ivy.xml. But as Ivy doesn't support the <tt>Bundle-Fragment</tt> OSGi feature, the ivy.xml can help specify the missing dependencies. <br class="xooki-br"/><br class="xooki-br"/>Having this setup, it is then a standard Ant+Ivy build. Ivy computes the classpath to be then used by the <tt>javac</tt> tasks. Note that <tt>javac</tt> is not aware of the OSGi metadata and is then incapable of failing to compile if private packages are accessed.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-4'>Building a standard OSGi bundle</div><br class="xooki-br"/>
<table class="notice">
  <tr>
    <td style="vertical-align: top"><img src="images/warning.png" style="float:left;" /></td>
    <td>
    Note that this feature is considered as <b>experimental</b>. It should work with simple configuration but may not in complex ones. If you have any issue with that feature, you are welcomed to come discussed your use case on the <a href="http://ant.apache.org/ivy/mailing-lists.html">ivy-user</a> mailing list, or discuss about implementation issues or improvement you may have found on <a href="http://ant.apache.org/ivy/mailing-lists.html">ant-dev</a>.<br class="xooki-br"/>    </td>
  </tr>
</table>

<hr />
<center><b>TODO - WORK IN PROGRESS</b></center>
<hr />

This page describes how to build an OSGi&#153; bundle with Apache Ivy&#153;. In this use case, we just basically want to compute a classpath to compile, optionaly one for testing too, and then publish our bundle in a OSGi aware repository.<br class="xooki-br"/><br class="xooki-br"/>In oder to produce OSGi metadata of suffient quality and to avoid maintaining them manually, the <a href="http://www.aqute.biz/Code/Bnd">bnd</a> tool will be used. The approach taken is then an "Ivy file first" approach. The dependencies will be specified in the ivy.xml file, the MANIFEST.MF being generated from the computed classpath.<br class="xooki-br"/><br class="xooki-br"/><br class="xooki-br"/><h1>Quick setup</h1>

In few steps, we will setup a build to compile and publish an OSGi bundle.<br class="xooki-br"/><br class="xooki-br"/><ol>
<li>download this <a href="../samples/standard-osgi/ivy.xml">ivy.xml<a>, this <a href="../samples/standard-osgi/ivysettings.xml">ivysettings.xml</a>, this <a href="../samples/standard-osgi/build.xml">build.xml</a>, this <a href="../samples/standard-osgi/org.apache.ivy.sample.standard-osgi.bnd">bnd file</a>, and put them into your project folder;</li>
<li>in the ivysettings.properties, specify the location of the plugins folder of your Eclipse target;</li>
<li><i>(optional)</i> by default the build.xml is expecting the sources to be in the <tt>src</tt> folder. You may want to edit it if it is not the case</li>
<li><i>(optional)</i> if Ivy is not in Ant's classpath, get the jar of <a href="../download.html">Apache Ivy</a> and edit the build.xml accordingly (see the comments at the begining of the file)</li>
</ol>

	<hr/><div class='toc-title toc-title-4'>Managing a target platform</div><br class="xooki-br"/>
<table class="notice">
  <tr>
    <td style="vertical-align: top"><img src="images/warning.png" style="float:left;" /></td>
    <td>
    Note that this feature is considered as <b>experimental</b>. It should work with simple configuration but may not in complex ones. If you have any issue with that feature, you are welcomed to come discussed your use case on the <a href="http://ant.apache.org/ivy/mailing-lists.html">ivy-user</a> mailing list, or discuss about implementation issues or improvement you may have found on <a href="http://ant.apache.org/ivy/mailing-lists.html">ant-dev</a>.<br class="xooki-br"/>    </td>
  </tr>
</table>

<hr />
<center><b>TODO - WORK IN PROGRESS</b></center>
<hr />

Building an OSGi&#153; bundle with standard tools like <tt>javac</tt> and a classpath computed by Apache Ivy&#153; can be erroneous as these tools doesn't take into account the package visibility enforced by the OSGi metadata. Then switching to OSGi dedicated tools like the Eclipse&#153; JDT can be prefered. This kind of tools still need a "target platform", a set of jars against to compile and then later run. A target platform can be easily managed with Ivy and its OSGi capabilities.<br class="xooki-br"/>
<ul>Some links of interest:<br class="xooki-br"/>  <li><a href="../resolver/obr.html">OSGi Bundle Repository Resolver</a></li>
  <li><a href="../resolver/updatesite.html">Eclipse updatesite Resolver</a></li>
  <li><a href="../use/retrieve.html">Ant ivy:retrieve task</a></li>
</ul>

	<hr/><div class='toc-title toc-title-4'>Apache Felix Sigil</div><br class="xooki-br"/><br class="xooki-br"/>Another initiative to manage OSGi&#153; dependencies is the project <a href="http://felix.apache.org/site/apache-felix-sigil.html">Apache Felix Sigil&#153;</a>. Sigil can used also together with Ivy. We will try to explain here the different approach taken there compared to the build-in OSGi capabilities of Ivy.<br class="xooki-br"/><br class="xooki-br"/><h1>A different approach</h1>

Apache Felix Sigil is at its core about managing OSGi dependencies, not directly related to Ivy. Most of it core feature is about the implementation of the not yet released OBR (OSGi Bundle Repository) specification. It then provides integration layers with sevral tools so human being can actually use the OBR API. As "layer" there is an Eclipse plugin, and there are the Ant/Ivy tasks and resolver.<br class="xooki-br"/><br class="xooki-br"/>On the other hand the build in OSGi capabilities in Ivy are targeted against users already familiar with Ivy and their <a href="http://ant.apache.org/ivy/links.html">tools</a> like <a href="http://ant.apache.org/ivy/ivyde">Apache IvyDE&#153;</a>. So with a minimum of effort, they can get OSGi dependency management.<br class="xooki-br"/><br class="xooki-br"/><h1>Resulting differences</h1>

<h2>Resolve</h2>

The build-in OSGi resolver is <i>obviously</i> using the Ivy engine to do the resolution of the dependencies. The OSGi capability of Ivy is mainly implemented with a module descriptor parser which understands the OSGi metadata of a MANIFEST.MF.<br class="xooki-br"/><br class="xooki-br"/>On the other hand, Sigil is using a separate "engine" to do the resolution, the OBR, an engine which is dedicated to understand the OSGi metadata and their semantics.<br class="xooki-br"/><br class="xooki-br"/>The immediate consequence of this difference is that the build-in resolver is probably less accurate than the Sigil one as to understand the OSGi dependencies semantics. As explained in this <a href="osgi-mapping.html">page</a>, the OSGi model doesn't fit well into the Ivy one.<br class="xooki-br"/><br class="xooki-br"/>Whereas Ivy is not ready yet to fill most OSGi use cases, OSGi dependency management at build time is not that complex, contrary to the runtime one. We hope that Ivy will catch up soon.<br class="xooki-br"/><br class="xooki-br"/><h2>Source of metadata</h2>

Apache Felix Sigil has its own format about specifying the OSGi dependencies. Whereas Ivy requires an ivysettings.xml and an ivy.xml, Sigil requires a sigil-repos.properties and a sigil.properties. Then if you want to use the Sigil resolver in Ivy, you will need 4 files, the 2 Ivy ones and the 2 Sigil ones, as described <a href="http://felix.apache.org/site/apache-felix-sigil-ivy-quickstart.html">there</a>.<br class="xooki-br"/><br class="xooki-br"/>To support OSGi directly in Ivy, you just need to add an extra namespace in the ivy.xml, and in the ivysettings.xml, just declare the proper resolver and latest revision strategy.<br class="xooki-br"/><br class="xooki-br"/>	<hr/><div class='toc-title toc-title-2'>Developer doc</div><br class="xooki-br"/><h1>Building from source</h1>
To build Ivy from source it's really easy. <br class="xooki-br"/><h2>Requirements</h2>
All you need is 
<ul>
<li>an <a href="http://subversion.tigris.org/">svn</a> client</li>
<em>to check out Ivy sources from apache svn, not required if you build from sources packaged in a release</em>
<li><a href="http://ant.apache.org/">Apache Ant</a> 1.6.0 or greater</li>
<em>We recommend either ant 1.6.5 or 1.7.0</em>
<li><a href="http://junit.org">junit</a> 3.8.2 jar in your ant lib</li>
<em> this is not required if you use ant 1.7</em>
<li>a <a href="http://java.sun.com/">jdk</a> 1.4 or greater</li>
<em>Build instructions have been successfully tested with sun jdk 1.4.2, 1.5.0 and 1.6.0</em>
</ul>

<h2>Procedure</h2>
<h3>Get the source</h3>
You can either get the sources from a release, or get them directly from svn. For instance, to get the trunk version:
<pre>
svn co <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk">https://svn.apache.org/repos/asf/ant/ivy/core/trunk</a> ivy
</pre>
<h3>Build</h3>
Go to the directory where you get the Ivy sources (you should see a file named build.xml) and run:
<pre>
ant
</pre>
<h3>Check the result</h3>
The ant build will compile the core classes of Ivy and use them to resolve the dependencies (used for some optional features). Then it will compile and run tests with coverage metrics.<br class="xooki-br"/><br class="xooki-br"/>If everything goes well, you should see the message
<pre>
BUILD SUCCESSFUL
</pre>
Then you can check the test results in the build/doc/reports/test directory, the jars are in build/artifacts, and the test coverage report in build/doc/reports/coverage<br class="xooki-br"/><h1>Coding conventions</h1>
The Ivy code base is supposed to follow the standard java conventions:<br class="xooki-br"/><a href="http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html">http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html</a><br class="xooki-br"/><br class="xooki-br"/>This is a work in progress though (see <a href="https://issues.apache.org/jira/browse/IVY-511">IVY-511</a>), but patches helping migration to these conventions are welcome.<br class="xooki-br"/><br class="xooki-br"/><h1>Developing with eclipse</h1>
Even though you can develop Ivy with your IDE of choice, we support eclipse development by providing ad hoc metadata.<br class="xooki-br"/><br class="xooki-br"/>We currently provide two options:<br class="xooki-br"/><h2>Eclipse alone</h2>
To develop with a simple eclipse install all you need is eclipse 3.1 or greater, with no particular plugin.<br class="xooki-br"/>First call the following ant target in your Ivy workspace:
<pre>
ant eclipse-default
</pre>
This will resolve the dependencies of Ivy and produce a .classpath using the resolved jars for the build path.<br class="xooki-br"/>Then you can use the "Import->Existing project into workspace" eclipse feature to import the Ivy project in your workspace.<br class="xooki-br"/><h2>Eclipse + IvyDE</h2>
You can also leverage the latest IvyDE version to be able to easily resolve the ivy dependencies from Eclipse.<br class="xooki-br"/>To do so all you need is call the following ant target in your Ivy workspace:
<pre>
ant eclipse-ivyde
</pre>
or if you don't have ant installed you can simply copy the file .classpath.ivyde and rename it to .classpath<br class="xooki-br"/>Then you can import the project using "Import->Existing project into workspace" as long as you already have latest IvyDE installed.<br class="xooki-br"/><br class="xooki-br"/>To install latest IvyDE version compatible with the latest Ivy used to resolve Ivy dependencies, you will need to use a snapshot build, not endorsed by the ASF, available here:<br class="xooki-br"/><a href="http://people.apache.org/~xavier/ivyde/snapshot/">http://people.apache.org/~xavier/ivyde/snapshot/</a><br class="xooki-br"/><br class="xooki-br"/>Download the file and unzip its content in your eclipse installation directory.<br class="xooki-br"/><br class="xooki-br"/><h2>recommended plugins</h2>
The Ivy project comes with settings for the <a href="http://eclipse-cs.sourceforge.net/">checkstyle plugin</a> we recommend to use to avoid introducing new disgression to the checkstyle rules we use.<br class="xooki-br"/>If you use this plugin, you will many errors in Ivy. As we said, following strict checkstyle rules is a work in progress and we used to have pretty different code conventions (like using _ as prefix for private attributes), so we still have things to fix. We usually use the filter in the problems view to filter out checkstyle errors from this view, which helps to know what the real compilation problem are.<br class="xooki-br"/><br class="xooki-br"/>Besides this plugin we also recommend to use a subversion plugin, <a href="http://www.eclipse.org/subversive/">subversive</a> or <a href="http://subclipse.tigris.org">subclipse</a> being the two options currently available in the open source landscape.<br class="xooki-br"/><hr/><div class='toc-title toc-title-3'>Extending Ivy</div><br class="xooki-br"/>Many things are configurable in Ivy, and many things are available with Ivy core. But when you want to do something not built in ivy core, you can still plug your own code.<br class="xooki-br"/><br class="xooki-br"/>Many things are pluggable in Ivy:
<ul>
<li>module descriptor parsers</li>
<li>dependency resolvers</li>
<li>lock strategies</li>
<li>latest strategies</li>
<li>circular dependency strategies</li>
<li>conflict managers</li>
<li>report outputters</li>
<li>version matchers</li>
<li>triggers</li>
</ul>

Before trying to implement your own, we encourage you to check if the solution to your problem cannot be addressed by existing features, or by contributed ones. Do not hesitate to ask for help on the mailing-lists.<br class="xooki-br"/><br class="xooki-br"/>If you still don't find what you need, then you'll have to develop your own plugin or find someone who could do that for you.<br class="xooki-br"/><br class="xooki-br"/>All ivy plug-ins use the same code patterns as ant specific tasks for parameters. This means that if you want to have a "myattribute" of type String, you just have to declare a method called setMyattribute(String val) on your plug-in. The same applies to child tags, you just have to follow Ant specifications.<br class="xooki-br"/><br class="xooki-br"/>All pluggable code in Ivy is located in the <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk/src/java/org/apache/ivy/plugins">org.apache.ivy.plugins</a> package. In each package you will find an interface that you must implement to provide a new plugin. We usually also provide an abstract class easing the implementation and making your code more independent of interface changes. We heavily recommend using these abstract classes as a base class.<br class="xooki-br"/><br class="xooki-br"/>To understand how your implementation can be done, we suggest looking at existing implementations we provide, it's the best way to get started.<br class="xooki-br"/>	<hr/><div class='toc-title toc-title-3'>Making a release</div><br class="xooki-br"/><h1>Making a release</h1>
<h2>Requirements</h2>
Requirements for making a release are similar to the requirements for building from source, except that sun jdk 1.6 and ant 1.7 are required.<br class="xooki-br"/><h2>Procedure</h2>
<h3>1. Check the files which needs to be updated for the release.</h3>
On the trunk, check that files which require update for the release are up to date.<br class="xooki-br"/>This includes particularly:<br class="xooki-br"/>RELEASE_NOTES<br class="xooki-br"/>CHANGES<br class="xooki-br"/>README<br class="xooki-br"/><h3>2. Create a release branch</h3>
This will allow to work separately from other developers, in case you need any last modification.
<pre>
svn copy <a href="https://svn.apache.org/repos/asf/ant/ivy/core/trunk">https://svn.apache.org/repos/asf/ant/ivy/core/trunk</a> \<br class="xooki-br"/>           <a href="https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1">https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1</a> \<br class="xooki-br"/>      -m "Creating a release branch for 2.0.0-beta1."
</pre>
<h3>3. Check out the branch</h3>
<pre>
svn co <a href="https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1">https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1</a> ivy-2.0.0-beta1
</pre>
<h3>4. Add Ivy xsd file.</h3>
You need to store the current ivy xml schema in the documentation, so that it will later be accessible on public web site. To do so, run the following command in the directory in which you checked out the release branch:
<pre>
ant -f build-release.xml release-xsd
</pre>

<h3>5. Add release note page in the documentation.</h3>
Open the file doc/index.html with your favorite browser, and click on the plus button in the upper right. Choose "Release Notes" as title, and "release-notes" as page id. <br class="xooki-br"/><br class="xooki-br"/>Then edit the page (hit the first button at the upper right), and copy the content of the RELEASE_NOTES file. You can also add the announcement for the release if it's already ready.<br class="xooki-br"/><br class="xooki-br"/>Move the page up in the TOC using the arrow button in the toolbar at the upper right, so that it's the first child page under the "Documentation" page.<br class="xooki-br"/><br class="xooki-br"/>If you take the time to make the content of the release notes more "xooki compliant" (by removing unnecessary end of lines and adding h2 h3 and h4 tags), the page could then look like something like that:<br class="xooki-br"/><a href="http://ant.apache.org/ivy/history/2.0.0-alpha-1.html">http://ant.apache.org/ivy/history/2.0.0-alpha-1.html</a><br class="xooki-br"/><br class="xooki-br"/><h3>6. Commit your changes</h3>
<pre>
svn status<br class="xooki-br"/>svn add doc/ivy.xsd<br class="xooki-br"/>svn add doc/release-notes.html<br class="xooki-br"/>svn ci -m "update templates, add release notes and ivy.xsd in documentation."
</pre>
<h3>7. Check that you have no pending modifications</h3>
<pre>
svn status
</pre>
If your working copy is clean, you can launch the release script. If it isn't, make sure to clean it properly. Sometimes you may need to call ant clean-all if you have started to work with ant builds. If you are confused about your working copy state, delete it and check it out again.<br class="xooki-br"/><h3>8. Launch the release script</h3>
<pre>
ant -f build-release.xml release
</pre>
The status should be release only for final releases, and milestone for any other intermediate release.<br class="xooki-br"/>If anything is wrong, fix and go back to step 4.<br class="xooki-br"/>If the release script is successful, release artifacts will be waiting for you in the build/distrib directory.<br class="xooki-br"/><h3>9. Verify the release</h3>
Check that all zips can be opened correctly, and that running 'ant' after unzipping the source distribution works properly.<br class="xooki-br"/>You can also do a smoke test with the generated ivy.jar , to see if it is able to resolve properly a basic module (for instance you can run some tutorials provided in the src/example directory in all distributions).<br class="xooki-br"/><h3>10. Sign and upload the artifacts</h3>
It's now time to sign the release artifacts and upload them to a location accessible by other Apache commiters.<br class="xooki-br"/><br class="xooki-br"/>Here is a simple way to sign the files using gnupg:
<pre>
gpg --armor --output file.zip.asc --detach-sig file.zip
</pre>

Here is a ruby script you can use to sign the files:
<pre>
require 'find'<br class="xooki-br"/><br class="xooki-br"/>Find.find('build/distrib') do |f| <br class="xooki-br"/>    `gpg --armor --output #{f}.asc --detach-sig #{f}` if File.file?(f) && ['.zip', '.gz', '.jar', '.pom'].include?(File.extname(f))<br class="xooki-br"/>end
</pre>
Be prepared to enter your passphrase several times if you use this script, gpg will ask for your passphrase for each file to sign.<br class="xooki-br"/><br class="xooki-br"/>When you're done upload the content of the distrib directory to a publicly accessible web site, your apache personal site being a good location for this. Make sure you include some kind of disclaimer somewhere to inform people the release is not approved yet.<br class="xooki-br"/><br class="xooki-br"/>You can for example add a HEADER.html like this:
<pre>
&lt;h2&gt;WARNING: files available here are NOT an Apache approved release yet.&lt;/h2&gt;
</pre>

<h3>11. Prepare the Eclipse update site</h3>

To be able to test the release within IvyDE, it can be deployed in the IvyDE update site. See <a href="http://ant.apache.org/ivy/ivyde/history/trunk/dev/updatesite.html">that page</a> to know how to process.<br class="xooki-br"/><br class="xooki-br"/><h3>12. Tag the svn repository</h3>
As soon as you are happy with the artifacts to be released, it is time to tag the svn repo
<pre>
svn copy <a href="https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1">https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1</a> \<br class="xooki-br"/>           <a href="https://svn.apache.org/repos/asf/ant/ivy/core/tags/2.0.0-beta1">https://svn.apache.org/repos/asf/ant/ivy/core/tags/2.0.0-beta1</a> \<br class="xooki-br"/>      -m "Tag release 2.0.0-beta1."
</pre>

And don't forget to set the svn:external on doc/xooki to a fixed revision. Edit the svn:external property on the folder doc/xooki in the tag and set it to the revision of the commit of the tag. It should look like:
<pre>
xooki -r790212 <a href="https://svn.apache.org/repos/asf/ant/ivy/site/xooki/">https://svn.apache.org/repos/asf/ant/ivy/site/xooki/</a>
</pre>

And commit that modification.<br class="xooki-br"/><br class="xooki-br"/><h3>Publish the release candidate</h3>

<ul>Two choices here:<br class="xooki-br"/>  <li>commit them into the dev dist area: <a href="https://dist.apache.org/repos/dist/dev/ant/ivy/$VERSION">https://dist.apache.org/repos/dist/dev/ant/ivy/$VERSION</a></li>
  <li>or simply put it in your <tt>public_html</tt> folder on people.apache.org so it will be avalaible at <a href="http://people.apache.org/~$LOGIN/$RELEASENAME">http://people.apache.org/~$LOGIN/$RELEASENAME</a></li>
</ul>

<h3>13. Call for a vote to approve the release</h3>
Cast a vote to approve the release on the dev@ant.apache.org mailing list.<br class="xooki-br"/><br class="xooki-br"/>Here is an example:
<pre>
Subject: [VOTE] Ivy ${version} Release<br class="xooki-br"/><br class="xooki-br"/>I have built a release candidate for Ivy ${version}<br class="xooki-br"/><br class="xooki-br"/>You can download it from this URL: ${url}<br class="xooki-br"/><br class="xooki-br"/>Do you vote for the release of these binaries?<br class="xooki-br"/><br class="xooki-br"/>[ ] Yes<br class="xooki-br"/>[ ] No<br class="xooki-br"/><br class="xooki-br"/>Regards,<br class="xooki-br"/><br class="xooki-br"/>${me}, Ivy ${version} release manager
</pre>
<h3>14. Publish the release</h3>

If the release is approved, it's now time to make it public. The apache dist is manage by svnpubsub, so releases should be committed into <a href="https://dist.apache.org/repos/dist/dev/ant/ivy/$VERSION">https://dist.apache.org/repos/dist/dev/ant/ivy/$VERSION</a><br class="xooki-br"/><br class="xooki-br"/>If the release candidate has been staged into the dev area, then just do:
<pre>
$ svn mv <a href="https://dist.apache.org/repos/dist/dev/ant/ivy/$VERSION">https://dist.apache.org/repos/dist/dev/ant/ivy/$VERSION</a> <a href="https://dist.apache.org/repos/dist/release/ant/ivy/$VERSION">https://dist.apache.org/repos/dist/release/ant/ivy/$VERSION</a>
</pre>

If the candidate has been published on people.apache.org, just directly commit the artifacts into the subversion repository <a href="https://dist.apache.org/repos/dist/release/ant/">https://dist.apache.org/repos/dist/release/ant/</a> <br class="xooki-br"/><br class="xooki-br"/>In order to keep the main dist area of a reasonable size, old releases should be removed. They will disapear from the main dist but will still be available via the <a href="http://archive.apache.org/dist/ant/ivy/">archive</a>. To do so, just use the <tt>svn rm</tt> command against the artifacts or folders to remove.<br class="xooki-br"/><br class="xooki-br"/><h3>15. Update the web site</h3>
Add a link to the released version documentation in the web site. <br class="xooki-br"/><br class="xooki-br"/>To do so, you need to:<br class="xooki-br"/><ol>
<li>add a svn externals reference to the documentation</li>
edit the svn properties of site/history, and in the svn:externals property, add a line like this one:
<pre>
2.0.0-beta1 <a href="https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1/doc">https://svn.apache.org/repos/asf/ant/ivy/core/branches/2.0.0-beta1/doc</a>
</pre>
You should also change the latest-milestone external link.<br class="xooki-br"/><br class="xooki-br"/>You can use "svn propedit svn:externals path/to/history" to do so.<br class="xooki-br"/><br class="xooki-br"/>Once you've changed the property, use "svn up" to checkout the proper documentation.
<li>edit the toc.json file in the site component of Ivy</li>
and add something like that:
<pre>
{<br class="xooki-br"/>   "title":"2.0.0-beta1",<br class="xooki-br"/>   "url":"<a href="http://ant.apache.org/ivy/history/2.0.0-beta1/index.html">http://ant.apache.org/ivy/history/2.0.0-beta1/index.html</a>"<br class="xooki-br"/>}
</pre>
You can also edit the title of the main documentation node pointing to latest-milestone / latest-release if necessary.<br class="xooki-br"/></ol>

Then you can update the release notes page of the imported documentation if necessary, to include the announcement for example.<br class="xooki-br"/><br class="xooki-br"/>It's time to update the download image used on the home page and the download page. Use site/images/ivy-dl.xcf as a basis if you have <a href="http://www.gimp.org/">gimp</a> installed. Then you can update the home page to refer to this image, and add a news item announcing the new version. Update also the download page with the new image and update the links to the download location (using a search/replace on the html source is recommended for this).<br class="xooki-br"/><br class="xooki-br"/>All site editing being done, commit your changes.<br class="xooki-br"/><br class="xooki-br"/>And now let's generate the site and deploy it:<br class="xooki-br"/><ol>
    <li>generate the part of the site for the new version:</li>
<pre>
ant generate-history-ivy -Dhistory.version=2.0.0-beta1
</pre>
<u>WARNING:</u> that target is modifiying the toc.json in the imported branch so that the generated html have a proper version declared in the toc. You should not commit that change. Once the site has been generated, you may want to revert the changes so you won't commit it by mistake. (TODO: process to improve so we shouldn't worry).<br class="xooki-br"/>    <li>generate the website with the new toc:</li>
<pre>
ant /all generate-site-ivy
</pre>
    <li>you should verify that the site generated in target is OK. And once your happy with it, commit the changes in target (some svn add might be needed !)</li>
    <li>deploy the website: go on people.apache.org and <tt>svn up /www/ant.apache.org/ivy/</tt></li>
</ol>

<h3>16. Deploy the Eclipse updatesite</h3>

If the Eclipse update site has already been prepared to include that new Ivy release, it is now needed to be deployed. Then follow the deployment instruction on <a href="http://ant.apache.org/ivy/ivyde/history/trunk/dev/updatesite.html">that page</a>.<br class="xooki-br"/><br class="xooki-br"/><h3>17. Announce</h3>
Announce the release on the dev@ant.a.o, ivy-user@ant.a.o, user@ant.apache.org and announce@apache.org mailing lists.<br class="xooki-br"/>You can also announce the release on popular web sites, like freshmeat.net (xavier is the owner of the Ivy project on freshmeat), javalobby.org, theserverside.com, dzone.com, ...<br class="xooki-br"/><h3>16. Update this doc</h3>
If you feel like anything is missing or misleading in this release doc, update it as soon as you encounter the problem.<br class="xooki-br"/><h3>17. Merge your modifications back to the trunk if necessary.</h3>
Modifications on the template files do not need to be merged, but if you had troubles during your release you may want to merge your fixes back to the trunk.<br class="xooki-br"/><h3>18. Prepare next release</h3>
Update the file version.properties with the version of the next release so that anyone building from the trunk will obtain jar with the correct version number.<br class="xooki-br"/><br class="xooki-br"/>Release the version in <a href="https://issues.apache.org/jira/browse/IVY">jira</a>, and create a new unreleased version for the next planned version.
 		</div><!-- main -->

<div id="footer-message" class="footer">
    <hr />
    <i>Copyright &#169; 2013 The Apache Software Foundation, Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0.txt">Apache License, Version 2.0</a>.</i><br />
    <i>Apache Ivy, Apache Ant, Ivy, Ant, Apache, the Apache Ivy logo, the Apache Ant logo and the Apache feather logo are trademarks of The Apache Software Foundation.</i><br />
    <i>All other marks mentioned may be trademarks or registered trademarks of their respective owners. </i>
</div>

</div><!-- body -->
</body>
</html>
